<script>

        var currentStatementSidePanelMode = "EDIT";
        
        function updateStatementSidePanel() {
            if(currentStatementSidePanelMode === "EDIT") switchToEdit()
            if(currentStatementSidePanelMode === "SEARCH") switchToSearch()
           
        }
        
        function switchToSearch() {
            switchStatementMenu('finds');
            sidePanelContent().hide('#edit-panel');
            sidePanelContent().show('#search-panel');
            searchForm().autofill();
            localStorage.setItem('entrypanel', 'search');
            changeEntriesHeight(200)
            hideFooter()
        }
        
        function switchToEdit() {
            if (userFactory.getViewType() == 'internal') {
                switchStatementMenu('adds');
                sidePanelContent().hide('#search-panel');
                sidePanelContent().show('#edit-panel');
                localStorage.setItem('entrypanel', 'edit');
                // TODO: get the logic from entries.ejs starting from (topmenuaction == 'adds') {
                changeEntriesHeight(400)
                showFooter()    
            }
        }
        
        function switchToInterpret() {
            // create a new graph
            // add the current (old) context
            // add interpretation functionality 
                // a. remove all visible entries from the "old" context
                // b. switch the way both graph intersection is colored
            // open the page with the parameters above
            navigation().redirect('');
        }
        
        function changeEntriesHeight(height) {
            statements().fillSpace(height);
        }
        
        function changeSidePanelHeight(height) {
            sidePanel().resize(height);
        }
        
        function switchStatementMenu(element) {
            statementMenu().switch(element);
        }
        
        function hideFooter(){
            deleteContextButton().hide()
            privacyLinkButton().hide()
            collaborateButton().hide();
            importLinkButton().hide();
        }
        
        function showFooter(){
            deleteContextButton().show()
            privacyLinkButton().show()
            collaborateButton().show();
            importLinkButton().show();
        }
        
        function changeModeTo(mode) {
            currentStatementSidePanelMode = mode
            updateStatementSidePanel()
        }
        
        function sendToImport() {
            var fornode = $('#statement').val();
            if (pinnedNodes.length > 0) {
                fornode = pinnedNodes.join("+");
            }
            navigation().redirect('/import?context=' + userFactory.getCurrentContext() + '&fornode=' + fornode);
        }
        
        function changeModeToSearch() {changeModeTo('SEARCH')}
        function changeModeToEdit() {changeModeTo('EDIT')}
        function changeModeToInterpret() {changeModeTo('INTERPRET')}
        function togglePanel() {
            if (currentStatementSidePanelMode === 'SEARCH') {
                currentStatementSidePanelMode = 'EDIT'
            }
            else if (currentStatementSidePanelMode === 'EDIT') {
                currentStatementSidePanelMode = 'SEARCH';
            }
            changeModeTo(currentStatementSidePanelMode);
        }
        
        findsButton().onClick(changeModeToSearch);
        editButton().onClick(changeModeToEdit);
        interpretButton().onClick(changeModeToInterpret);
        minimizeButton().onClick(togglePanel);
        closeStatementMenuButton().onClick(hideStatements);
        importLinkButton().onClick(sendToImport);
        
        
        function sidePanelContent() {
            return {
                show: function(element){
                    $(element).show();
                },
                hide: function(element){
                    $(element).hide();
                }
            }
        }
        
        function hideStatements() {
            statementsPanel().toggleStatementsPanel();
        }
        
        
        // Select the default view for entrycontrol
        
        if (userFactory.getViewType() == 'external' || localStorage.getItem('entrypanel') == 'search') {    
            currentStatementSidePanelMode = "SEARCH"
        }
        
        changeModeTo(currentStatementSidePanelMode);
        
        // OnLoad get the right height for the entries elements — this depends on the form so it's here
        
        let uproll = $('#entryform').height();
        
        if (userFactory.getViewOption('hide_edit')) {
          uproll = 50;
        }
        
        statements().fillSpace(uproll + 100);
        
        // Scroll down all the entries
        
        statements().scroll();
        
        // Do the same with when the window is resized 
        
        $(window).resize(function() {
            statements().fillSpace(uproll + 100);
            statements().scroll();
        });
        
        // Make texarea automatically resizeable
        $('textarea').autosize();
        
        
        // Here we perform some live updates of the graph on receiving a Socket.IO message
        // We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties
        
        // TODO set up chatroom, make better design, think of graph sharing functionality
        
        socket.on('chat message', function(msg){
            
            let selfPosted = userFactory.getSelfPosted();
        
            let perceivedby = userFactory.getLoggedInUser();    
        
            let posted_by = msg.postedby;
        
            let alien = false;
        
            let chatbot = false;
        
            // if the message is not self-posted and also if the poster of the message is not the same as the guy logged in (in case there's two logins simultaneously)
            if (!selfPosted && perceivedby != posted_by) {
        
                // add the alien class so the posted message looks like it's from elsewhere
                alien = true;
        
                // add another class if this is a help message from the chatbot
                if (msg.help) {
                    chatbot = true;
                }
        
                // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
                var receivedby = userFactory.getWatchedUser();
        
                // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
                // This is only for collaboration - we resubmit, otherwise it's already submitted before
                if ((receivedby != msg.postedby) && !msg.mute) {
                    // Populate the form and submit
                    addEntryForm().populateAndPost(msg.entrytext, addEntryForm().post);
                }
            }
        
            // So let's add that entry to the #entries div
            statements().append(msg.entrytext, msg.entryuid, msg.entryname, msg.postedby, alien, chatbot);
        
            // Unfocus and reFocus again on the entry field
            addEntryForm().refocus();
        
            // Add some behavior hooks again onto that element
            // One click will filter the nodes / edges of the statement on the graph
            // Doubleclick will open the edit pane
        
            statements().onClick(statements().select);
        
            if (dynamic_watch == 1 && dynamic_graph == 1) {
              $('#watch-link').trigger('click');
              setTimeout(function() {
                statements().scroll();
              }, 500);
              setTimeout(function() {
                $('#watch-link').trigger('click');
              }, 4000);
            }
            else {
                statements().scroll();
            }
        
            // Add new nodes and edges — these are all the nodes and edges of the graph, not newly added only
            // TODO IMPROVEMENT maybe we could return only the new ones for efficiency
            var addednodes = msg.graph.nodes;
            var addededges = msg.graph.edges;
        
            // Add to the stats and then add to the graph (inside graphFactory function)
            graphFactory.addNewNodes(addednodes, addededges, msg.entryuid);
        
            // This is for special cases where the user is on a graph, but they are adding their own stuff to this graph into a new graph, so we only show the entries that he added, not the previous ones
            statements().removeAddContext();
        
            // Play MIDI notes
            playNodesMIDI().addition(addednodes, addededges);
        
        
        });
        
        
        
        // This is called when an entry is deleted
        
        socket.on('delete message', function(msg){
        
            $('[data-uid="' + msg.entryuid + '"]').fadeOut();
        
            $("#statement").val('');
        
            // We remove the nodesOfStatement[statement] for that statement
            // When searched for nodes in that statement, nothing will appear 
            graphFactory.removeNodesFromStatement(msg.entryuid);
        
            // Let's set up which nodes we will keep
            let nodesToKeep = [];
        
            // Reiterate through Sigma
            sigma.instances(0).graph.edges().forEach(function(e) {
        
                // If a node appears in at least one statement, we add him in ToKeep list
                for (let item of e.statement_id) {
                
                    if (graphFactory.existNodeInStatement(item, e.source) == true) {
                        nodesToKeep.push(e.source);
                    }
        
                    if (graphFactory.existNodeInStatement(item, e.target) == true) {
                        nodesToKeep.push(e.target);
                    }
        
                    graphFactory.removeStatementFromContext(e.edge_context, item);
        
                    if (item == msg.entryuid) {
                        sigma.instances(0).graph.dropEdge(e.id);
                    }
                    
                }
        
            });
        
            let nodesToDelete = [];
            sigma.instances(0).graph.nodes().forEach(function(n) {
                if (nodesToKeep.indexOf(n.id) < 0) {
                    graphFactory.removeNode(n.originalLabel);
                    nodesToDelete.push(n.originalLabel);
                }
        
            });
        
            graphFactory.deleteGraphNodes(nodesToDelete);
        
        });
        
    </script>