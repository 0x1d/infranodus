
<div id="entries">

    <div id="explanation"></div>

    <% entries.forEach(function(entry) { %>
        <%- include('./StatementEntry', {entry}); %>
    <% }) %>

    <%- include('../../common/messages', {messages:locals.messages, removeMessages: locals.removeMessages}); %>

    <div id="warnings"></div>

</div>

<script>

var currentEntriesPanelMode = "VISIBLE"

var visibleentries_original = '0';

if (localStorage.getItem('folded') == 1) {
    currentEntriesPanelMode = "HIDDEN"
    changeEntriesModeTo(currentEntriesPanelMode);
}    
        
function changeEntriesModeTo(mode) {
    currentEntriesPanelMode = mode
    updateEntriesPanel()
}

function checkEntriesMode() {
    return {
        visibility: function() {
            if ($("#entries").css('visibility') == 'hidden') {
                    return 'HIDDEN'
            }
            else if ($("#entries").css('visibility') == 'visible') {
                    return 'VISIBLE'
            }
        }
    }    
}

function updateEntriesPanel() {
    if(currentEntriesPanelMode === "HIDDEN") entries().hide();
    if(currentEntriesPanelMode === "VISIBLE") entries().show();
}

function entries() {
    return {
        fillSpace: function(heightToReduce){
            $('#entries').css({height:  $(window).height() - heightToReduce});
        },
        show: function() {
                $("#entries").css('z-index','5');
                $("#entries").css('visibility','visible');
                $('#topnav').fadeIn();
                localStorage.setItem('folded', 0);
                // TODO move color to another function
                $('#statements-link').removeClass('statements-link-on-dark');
                $('#statements-link').removeClass('statements-link-on');
        },
        hide: function() {
                $("#entries").css('z-index','-2'); 
                $("#entries").css('visibility','hidden');
                $('#topnav').fadeOut();
                localStorage.setItem('folded', 1);
                // TODO move color to another function
                if (background == 'dark') {
                    $('#statements-link').addClass('statements-link-on-dark');
                }
                else {
                    $('#statements-link').addClass('statements-link-on');
                }
                
        }
    }
}


    // Filter out the statements that don't have any of the nodes clicked

    var timesfiltered = 0;

    function filter_statements(pinnedNodes, origin) {

        var visibleentries = visibleentries_original;

        var nodeIDs_reversed = _.invert(nodeIDs);

        // Hide the sentences that don't contain the terms

        if (origin != 'stopwords') {

             if (pinnedNodes.length == 0) {

               $(".entry").fadeIn(500);

             }

             else {

               $(".entry").each(function(){

                  var currentDiv = $(this).attr('data-uid');

                  // Retrieve the statement text from the entry, clean from html
                  var originaltext = $(this).children('.entry-text').html();

                  var nodesfound = 0;

                  var matched1entry = 0;

                  // For each node present in this statement:
                  for (var item in nodesOfStatement[currentDiv]) {

                    var nmarker = nodesOfStatement[currentDiv][item]; //

                    // Is this node in pinnedNodes?
                    if (pinnedNodes.indexOf(nodeIDs_reversed[nmarker]) > -1) {
                      nodesfound = nodesfound + 1;
                      if (nodesfound == pinnedNodes.length) {
                          matched1entry = 1;
                      }

                    }
                  }

                // All the pinned nodes are not found in the entry
                if (matched1entry == 0) {

                    // Hide this entry
                    $(this).fadeOut(500);

                    // Set the counter
                    visibleentries = visibleentries - 1;

                    // We finished iterating through all the entries and nothing is shown
                    // Then launch a different logic

                    if (visibleentries == 0) {


                        // #1 Logic for intersections

                        var lastNode = pinnedNodes[pinnedNodes.length - 1];

                        var nnodes = sigma.instances(0).graph.neighbors(nodeIDs[lastNode]);

                        var selectedNNodes = [];

                        // We create an array from neighbors that looks like toKeep one

                        for (var key in nnodes) {
                            selectedNNodes.push(nnodes[key].label);
                        }

                        var overlapNodes = [];
                        overlapNodes = _.intersection(selectedNNodes, selectedNodes);

                        // TODO we always should have ONLY entries with one intersection and at least one of the pinned
                        // This breaks when we start navigating in the graph and have 3 pinned items — in this case no neighbors and it breaks

                        // Also some problems with deselection

                        $(".entry").each(function(){
                            var matchedentry = 0;
                            var currentDiv = $(this).attr('data-uid');

                            // For each node present in this statement:
                            for (var item in nodesOfStatement[currentDiv]) {
                              var nmarker = nodesOfStatement[currentDiv][item];

                              // Does this node belong to the Overlap nodes AND at the same time
                              if (overlapNodes.indexOf(nodeIDs_reversed[nmarker]) > -1) {
                                for (var node in nodesOfStatement[currentDiv]) {
                                  var n2marker = nodesOfStatement[currentDiv][node];
                                  if (pinnedNodes.indexOf(nodeIDs_reversed[n2marker]) > -1 || lastNode == nodeIDs_reversed[n2marker]) {
                                    matchedentry = 1;
                                  }
                                }
                              }
                            }
                            if (matchedentry == 1) {
                                $(this).fadeIn(500);
                                visibleentries = visibleentries + 1;
                            }
                        });


                        if (visibleentries == 0) {

                            $('.entry').fadeIn(500);
                            // #2 Logic
                            // This is if we want to remove the node before the last one.

                            // timesfiltered = timesfiltered + 1;
                            // var posnodes = pinnedNodes.length - timesfiltered - 1;

                            var posnodes = 0;

                            // Final nodes to search

                            splicedNodes = [];

                            // First all of them

                            for (var k = 0; k < pinnedNodes.length; k++) {
                                splicedNodes[k] = pinnedNodes[k];
                            }

                            // Remove the one we can't find (the very first one of the bunch)

                            splicedNodes.splice(posnodes, 1);

                            // Save that one also into the list of the nodes we removed

                            notfoundNodes.push(pinnedNodes[posnodes]);

                            // This is for alert
                            // var r = confirm('No link between ' + pinnedNodes + '.\nShow entries just with ' + splicedNodes + '?');

                            // This is for plain message
                            // $('#messages').html('No entries contain "' + pinnedNodes.join(' and ') + '".<br>Showing entries that contain "' + splicedNodes.join(' and ') + '" only:<br>&nbsp;');

                            // Get the pinnedNodes back to a good shape
                            pinnedNodes = [];
                            for (var l = 0; l < splicedNodes.length; l++) {
                                pinnedNodes[l] = splicedNodes[l];
                            }

                            // Relaunch the function with the newly cleared list of pinnedNodes

                            filter_statements(pinnedNodes, origin);
                      }

                    }
                // END OF not found any entries with the nodes clicked
                }

                // FOUND something with the nodes clicked
                else {

                    // Populate statement with a new text

                  //  $(this).children('.entry-text').html(newtext);

                    // $(this).find('.nonmatched-sentence').fadeOut(500); this is only if we want to fade non-matched sentences - see above also



                }


            });
          }



                        if (pinnedNodes.length > 0) {
                                if (background == 'dark') {
                                  $('#deletenodes').addClass('deletenodes-dark');
                                  $('#undo').addClass('undo-dark');
                                }
                                else {
                                  $('#deletenodes').addClass('deletenodes-on');
                                  $('#undo').addClass('undo-on');
                                }

                        }
                        else {
                          if (background == 'dark') {
                            $('#deletenodes').removeClass('deletenodes-dark');
                            $('#undo').removeClass('undo-dark');
                          }
                          else {
                            $('#deletenodes').removeClass('deletenodes-on');
                            $('#undo').removeClass('undo-on');
                          }

                        }

                        // Show tags that are currently used in search

                        var htmlNodes =  '<ul class="tags">';
                        var pinnedNodes_string = '';

                        if (pinnedNodes.length == 0) { notfoundNodes = [] }

                        for (var x = 0; x < notfoundNodes.length; x++) {
                            htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + notfoundNodes[x] + '</a></li>';
                            pinnedNodes_string = pinnedNodes_string + '#' + notfoundNodes[x] + ' ';
                        }

                        for (var q = 0; q < pinnedNodes.length; q++) {
                            htmlNodes = htmlNodes + '<li><a href="#">' + pinnedNodes[q] + '</a></li>';
                            pinnedNodes_string = pinnedNodes_string + '#' + pinnedNodes[q] + ' ';
                        }

                        if ($('#addnodeinput').val().length == 0 || $('#addnodeinput').val().charAt(0) == '#') {
                          $('#addnodeinput').val(pinnedNodes_string);
                        }

                        if ($('#statement').val().length == 0 || $('#statement').val().charAt(0) == '#') {
                          $('#statement').val(pinnedNodes_string);
                        }


                        htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

                        //  notfoundNodes = [];

                        $('#pinnednodeslist').html(htmlNodes);


        // Highlight the nodes that were clicked

        $(".entry").removeHighlight();


        for (var i=0; i<pinnedNodes.length; i++) {
            if (pinnedNodes[i].match(/[а-яА-Я]/)) {
              $(".entry").highlight(window.jstemmer(pinnedNodes[i]));
            }
            else {
              $(".entry").highlight(pinnedNodes[i]);
            }

        }

        // Show only the clicked nodes and their neighbors in the graph
        if (origin != 'community' && origin != 'stopwords') {
          filter_graph(pinnedNodes, origin);
        }


        // END OF if origin != stopwords
      }

       // If we're coming from stopwords, adjust deletedNodes
        if (origin == 'stopwords') {
                deletedNodes = pinnedNodes;
                  if ($('#summary').hasClass('pure-menu-selected-top')) {
                      $('#summary').click();
                  }
                  if ($('#insight').hasClass('pure-menu-selected-top')) {
                      $('#insight').click();
                  }
        }

        // Then generate the interface
        var stopNodesList = '<ul class="tags">';
        for (var x = 0; x < deletedNodes.length; x++) {
            stopNodesList = stopNodesList + '<li><a class="deleted" href="#">' + deletedNodes[x] + '</a></li>';
        }
        stopNodesList = stopNodesList + '</ul>';


        // Save all this data in localStorage

        if (localStorage.getItem("selections")) {
            var localstore = JSON.parse(localStorage.getItem("selections"));
        }
        else {
            var localstore = {};
        }

        var localstore_cell = {};

        localstore_cell.stopnodes = deletedNodes;
        localstore_cell.pinnednodes = pinnedNodes;

        if (deletedNodes.length == 0 && pinnedNodes.length == 0) {
          delete localstore[window.location.href]
        }
        else {
          localstore[window.location.href] = localstore_cell;
        }

        localStorage.setItem("selections",JSON.stringify(localstore));

        if (deletedNodes.length > 0) {
          if (background == 'dark') {
            $('#stopsave').addClass('stopsave-dark');

          }
          else {
            $('#stopsave').addClass('stopsave-on');

          }
        }
        else {
          if (background == 'dark') {
            $('#stopsave').removeClass('stopsave-dark');

          }
          else {
            $('#stopsave').removeClass('stopsave-on');

          }

        }

        $('#stopnodeslist').html(stopNodesList);

        // Add triggers to newly shown Tags elements

        addTagTriggers();


        if (pinnedNodes.length == 0) {
            if (addcontext && interpret) {


              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

          }
        }

        if ($('#summary').hasClass('pure-menu-selected-top')) {
          if (pinnedNodes.length == 0) {
            $('#summary').click();
          }
        }
        if ($('#insight').hasClass('pure-menu-selected-top')) {
          if (pinnedNodes.length == 0) {
            $('#insight').click();
          }
        }

    }


</script>