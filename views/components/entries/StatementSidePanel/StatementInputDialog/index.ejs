<div id="entryform" class="editorpane">
    <%- include('./Header',
        {perceivername, addcontext, context}); %>

    <%- include('./Footer',
        {perceivername, context, contextpublic}); %>

        <!-- the panel to show content -->
    <%- include('./Body',
        {perceivername, url, urltitle}); %>
</div>

<script>


var currentStatementSidePanelMode = "EDIT"

if (userFactory.getViewType() == 'external') {    
    currentStatementSidePanelMode = "SEARCH"
}

changeModeTo(currentStatementSidePanelMode);

function updateStatementSidePanel() {
    if(currentStatementSidePanelMode === "EDIT") switchToEdit()
    if(currentStatementSidePanelMode === "SEARCH") switchToSearch()
   
}

function switchToSearch() {
    switchStatementMenu('finds');
    sidePanelContent().hide('#edit-panel');
    sidePanelContent().show('#search-panel');
    searchForm().autofill();
    changeEntriesHeight(200)
    hideFooter()
}

function switchToEdit() {
    if (userFactory.getViewType() == 'internal') {
        switchStatementMenu('adds');
        sidePanelContent().hide('#search-panel');
        sidePanelContent().show('#edit-panel');
        // TODO: get the logic from entries.ejs starting from (topmenuaction == 'adds') {
        changeEntriesHeight(400)
        showFooter()    
    }
}

function switchToInterpret() {
    // create a new graph
    // add the current (old) context
    // add interpretation functionality 
        // a. remove all visible entries from the "old" context
        // b. switch the way both graph intersection is colored
    // open the page with the parameters above
    navigation().redirect('');
}

function changeEntriesHeight(height) {
    entries().fillSpace(height);
}

function changeSidePanelHeight(height) {
    sidePanel().resize(height);
}

function switchStatementMenu(element) {
    statementMenu().switch(element);
}

function hideFooter(){
    deleteContextButton().hide()
    privacyLinkButton().hide()
    collaborateButton().hide();
    importLinkButton().hide();
}

function showFooter(){
    deleteContextButton().show()
    privacyLinkButton().show()
    collaborateButton().show();
    importLinkButton().show();
}

function changeModeTo(mode) {
    currentStatementSidePanelMode = mode
    updateStatementSidePanel()
}

function sendToImport() {
    var fornode = $('#statement').val();
    if (pinnedNodes.length > 0) {
        fornode = pinnedNodes.join("+");
    }
    navigation().redirect('/import?context=' + current_context + '&fornode=' + fornode);
}

function changeModeToSearch() {changeModeTo('SEARCH')}
function changeModeToEdit() {changeModeTo('EDIT')}
function changeModeToInterpret() {changeModeTo('INTERPRET')}
function togglePanel() {
    if (currentStatementSidePanelMode === 'SEARCH') {
        currentStatementSidePanelMode = 'EDIT'
    }
    else if (currentStatementSidePanelMode === 'EDIT') {
        currentStatementSidePanelMode = 'SEARCH';
    }
    changeModeTo(currentStatementSidePanelMode);
}

findsButton().onClick(changeModeToSearch);
editButton().onClick(changeModeToEdit);
interpretButton().onClick(changeModeToInterpret);
minimizeButton().onClick(togglePanel);
closeStatementMenuButton().onClick(hideStatements);
importLinkButton().onClick(sendToImport);


function sidePanelContent() {
    return {
        show: function(element){
            $(element).show();
        },
        hide: function(element){
            $(element).hide();
        }
    }
}

function hideStatements() {
    toggleStatementSidePanel();
}



// OnLoad get the right height for the entries elements â€” this depends on the form so it's here

var uproll = $('#entryform').height();

if (hide_edit) {
  uproll = 50;
}

entries().fillSpace(uproll + 100);

// Scroll down all the entries

entries().scroll();

// Do the same with when the window is resized 

$(window).resize(function() {
    entries().fillSpace(uproll + 100);
    entries().scroll();
});

// Make texarea automatically resizeable
$('textarea').autosize();




// Here we perform some live updates of the graph on receiving a Socket.IO message
// We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

// TODO set up chatroom, make better design, think of graph sharing functionality

socket.on('chat message', function(msg){
    
    let selfPosted = userFactory.getSelfPosted();

    let perceivedby = userFactory.getLoggedInUser();    

    let posted_by = msg.postedby;

    let alien = false;

    let chatbot = false;

    // if the message is not self-posted and also if the poster of the message is not the same as the guy logged in (in case there's two logins simultaneously)
    if (!selfPosted && perceivedby != posted_by) {

        // add the alien class so the posted message looks like it's from elsewhere
        alien = true;

        // add another class if this is a help message from the chatbot
        if (msg.help) {
            chatbot = true;
        }

        // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var receivedby = userFactory.getWatchedUser();

        // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
        // This is only for collaboration - we resubmit, otherwise it's already submitted before
        if ((receivedby != msg.postedby) && !msg.mute) {
            // Populate the form and submit
            addEntryForm().populateAndPost(msg.entrytext, addEntryForm().post);
        }
    }

    // So let's add that entry to the #entries div
    entries().append(msg.entrytext, msg.entryuid, msg.entryname, msg.posted_by, alien, chatbot);

    // Unfocus and reFocus again on the entry field
    addEntryForm().refocus();

    // Add some behavior hooks again onto that element
    // One click will filter the nodes / edges of the statement on the graph
    // Doubleclick will open the edit pane

    entries().onClick(entryClick);
    entryDoubleClick();


    adding_entry = true;
    if (dynamic_watch == 1 && dynamic_graph == 1) {
      $('#watch-link').trigger('click');
      setTimeout(function() {
        entries().scroll();
      }, 500);
      setTimeout(function() {
        adding_entry = false;
        $('#watch-link').trigger('click');
      }, 4000);
    }
    else {
        entries().scroll();
    }

    var addednodes = msg.graph.nodes;
    var addededges = msg.graph.edges;

    var nodes_added = [];
    var edges_added = [];


    // Let's add the nodes to the Sigma graph
    for (var i = 0; i < addednodes.length; i++) {

        if (graphFactory.getNodeNames().indexOf(addednodes[i].label) == -1) {

           // var angle = Math.PI * 2 * i / len;

            sigma.instances(0).graph.addNode({
                id: (id = addednodes[i].id),
                label: addednodes[i].label,
                originalLabel: addednodes[i].label,
                originalColor: color_context,
                size: maxnodesize - 2,
                x: Math.random(),
                y: Math.random(),
                color: color_context
            });
            graphFactory.addNode(addednodes[i].label, addednodes[i], id);
            nodes_added.push(addednodes[i]);
            if (!nodeIDs[addednodes[i].label]) {
              nodeIDs[addednodes[i].label] = addednodes[i].id;
            }


        }


    }

    // Let's add the edges to the Sigma graph

    for (var j = 0; j < addededges.length; j++) {

       if ((addededges[j].statement_id == msg.entryuid)) {


         var unique_edge_id = '';

         // Let's see if the edge source in alphabetical order is further than its target and change places

         if (addededges[j].source > addededges[j].target) {
             unique_edge_id = addededges[j].target + '-' + addededges[j].source;
         }
         else {
             unique_edge_id = addededges[j].source + '-' + addededges[j].target;
         }


            sigma.instances(0).graph.addEdge({
                id: addededges[j].id,
                source: addededges[j].source,
                target: addededges[j].target,
                weight: addededges[j].weight,
                size: addededges[j].weight,
                statement_id: addededges[j].statement_id,
                edge_context: addededges[j].edge_context
            });

            edges_added.push(addededges[j]);


        }

    }

    // Let's create a new collection for Cytoscape - used to calculate node metrics for the graph
    var collection = cy.elements();
    cy.remove(collection);

    elesnodes = [];

    // Adding all the refreshed nodes into Cytoscape
    sigma.instances(0).graph.nodes().forEach(function(n) {
        if (n.id == 'dummy') {
            sigma.instances(0).graph.dropNode('dummy');
        }
        else {

          // Add to Cytoscape
          elesnodes.push({
              group: "nodes",
              data: { id: n.id, name: n.label}
          });

        }

      //n.size = sigma.instances(0).graph.degree(n.id);

    });

    // For each edge in the graph recalculate some important metrics
    // And update global parameters which we use to track the state of each element
    // TODO this code duplicates from above - move into a function

    // jsnetworkx
    var jsGraphEdges = [];
    nodeIDs_rev = _.invert(nodeIDs);

    sigma.instances(0).graph.edges().forEach(function(e) {

      var unique_edge_id = '';

      // Let's see if the edge source in alphabetical order is further than its target and change places

      if (e.source > e.target) {
          unique_edge_id = e.target + '-' + e.source;
      }
      else {
          unique_edge_id = e.source + '-' + e.target;
      }


        // Make and index of nodes to statement

          if (nodesOfStatement[e.statement_id]) {
              if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                  nodesOfStatement[e.statement_id].push(e.source);
              if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                  nodesOfStatement[e.statement_id].push(e.target);
          }
          else {
              nodesOfStatement[e.statement_id] = [];
              nodesOfStatement[e.statement_id].push(e.source);
              nodesOfStatement[e.statement_id].push(e.target);
          }

        // Which statements belong to which context / graph
        if (statementsOfContext[e.edge_context]) {
              if (statementsOfContext[e.edge_context].indexOf(e.statement_id[0]) < 0) {
                statementsOfContext[e.edge_context].push(e.statement_id[0]);
              }
        }
        else {
            statementsOfContext[e.edge_context] = [];
            statementsOfContext[e.edge_context].push(e.statement_id[0]);
        }


                        // Make an index of nodes to context
                        if (contextNodeID[e.edge_context]) {
                            if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                                contextNodeID[e.edge_context].push(e.source);
                            if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                                contextNodeID[e.edge_context].push(e.target);
                        }
                        else {
                            contextNodeID[e.edge_context] = [];
                            contextNodeID[e.edge_context].push(e.source);
                            contextNodeID[e.edge_context].push(e.target);
                        }


        // Add to Cytoscape for betweenness centrality calculation
        elesnodes.push({
            group: "edges",
            data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
        });

        // TODO remove that, this is just to check data consistentency
        e.sourcename = nodeIDs_rev[e.source];
        e.targetname = nodeIDs_rev[e.target];

        // Add to jsnetworkx

        var edge_params = {
                     weight: 1/e.weight,
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
        };

        var edge_object = [e.source, e.target, edge_params];
                 
        jsGraphEdges.push(edge_object);


    });


    // Betweenness Centrality Calculation using Cytoscape
    eless = cy.add(elesnodes);

    var jsG = new jsnx.DiGraph();
    // jsG = jsnx.convertToUndirected(jsG);
           
    jsG.addEdgesFrom(jsGraphEdges);

    // console.log(eles.nodes().length);

    betweennessCentrality(eless, jsG);
    communityDetect();

    //sigma.refresh();

    // Launch new layout
    if (forcedatlas_running) {
      $('#improve-layout').trigger('click');
      setTimeout(function() {
        $('#improve-layout').trigger('click');
      }, 500);
    }
    else {
      sigma.instances(0).startForceAtlas2(forceatlas_options);
      setTimeout(function() {

          sigma.instances(0).stopForceAtlas2();
          sigma.instances(0).killForceAtlas2();

      }, 3000);
    }

    // MIDI activation

    // Play a note on adding nodes / edges

    <% if (locals.user) { %>
    <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


    console.log('using MIDI data ' + midi);
    console.log('playing MIDI device:');
    console.log(output);

    var timecode = 0;

    var note_node = midi.substr(10,2);
    if (note_node.substr(1,1) == '0') {
      note_node = note_node.substr(0,1) + '1';
    }

    var note_edge = midi.substr(12,2);
    if (note_edge.substr(1,1) == '0') {
      note_edge = note_edge.substr(0,1) + '1';
    }



    for (var m = 0; m < nodes_added.length; m++) {


        setTimeout(function () {
          output.playNote(note_node, parseInt(midi.substr(0,2)));
          output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
          console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
        }, timecode);
        timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
    }

    var timecodea = 0;

    for (var ed = 0; ed < edges_added.length; ed++) {

        setTimeout(function () {
          output.playNote(note_edge, parseInt(midi.substr(2,2)));
          output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
          console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
        }, timecodea);
          timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

    }

    <% } %>
    <% } %>




    //console.log(newnodes);
    // console.log(msg.graph.edges);
    // console.log(sigma.instances(0).graph.edges());

    // TODO right now it doubles the code above

    // This is for special cases where the user is on a graph, but they are adding their own stuff to this graph into a new graph, so we only show the entries that he added, not the previous ones
    if (addcontext && interpret) {

      $('.entry').hide();

      for (var ite in statementsOfContext[current_context]) {

        $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
          $(this).show();
        });

      }


  }


});



// What do do when the form is submitted and a new entry (text) is added?




</script>