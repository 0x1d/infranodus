<div id="entryform" class="editorpane">
    <%- include('./Header',
        {perceivername, addcontext, context}); %>

    <%- include('./Footer',
        {perceivername, context, contextpublic}); %>

        <!-- the panel to show content -->
    <%- include('./Body',
        {perceivername, url, urltitle}); %>
</div>

<script>


var currentStatementSidePanelMode = "EDIT";



function updateStatementSidePanel() {
    if(currentStatementSidePanelMode === "EDIT") switchToEdit()
    if(currentStatementSidePanelMode === "SEARCH") switchToSearch()
   
}

function switchToSearch() {
    switchStatementMenu('finds');
    sidePanelContent().hide('#edit-panel');
    sidePanelContent().show('#search-panel');
    searchForm().autofill();
    localStorage.setItem('entrypanel', 'search');
    changeEntriesHeight(200)
    hideFooter()
}

function switchToEdit() {
    if (userFactory.getViewType() == 'internal') {
        switchStatementMenu('adds');
        sidePanelContent().hide('#search-panel');
        sidePanelContent().show('#edit-panel');
        localStorage.setItem('entrypanel', 'edit');
        // TODO: get the logic from entries.ejs starting from (topmenuaction == 'adds') {
        changeEntriesHeight(400)
        showFooter()    
    }
}

function switchToInterpret() {
    // create a new graph
    // add the current (old) context
    // add interpretation functionality 
        // a. remove all visible entries from the "old" context
        // b. switch the way both graph intersection is colored
    // open the page with the parameters above
    navigation().redirect('');
}

function changeEntriesHeight(height) {
    entries().fillSpace(height);
}

function changeSidePanelHeight(height) {
    sidePanel().resize(height);
}

function switchStatementMenu(element) {
    statementMenu().switch(element);
}

function hideFooter(){
    deleteContextButton().hide()
    privacyLinkButton().hide()
    collaborateButton().hide();
    importLinkButton().hide();
}

function showFooter(){
    deleteContextButton().show()
    privacyLinkButton().show()
    collaborateButton().show();
    importLinkButton().show();
}

function changeModeTo(mode) {
    currentStatementSidePanelMode = mode
    updateStatementSidePanel()
}

function sendToImport() {
    var fornode = $('#statement').val();
    if (pinnedNodes.length > 0) {
        fornode = pinnedNodes.join("+");
    }
    navigation().redirect('/import?context=' + userFactory.getCurrentContext() + '&fornode=' + fornode);
}

function changeModeToSearch() {changeModeTo('SEARCH')}
function changeModeToEdit() {changeModeTo('EDIT')}
function changeModeToInterpret() {changeModeTo('INTERPRET')}
function togglePanel() {
    if (currentStatementSidePanelMode === 'SEARCH') {
        currentStatementSidePanelMode = 'EDIT'
    }
    else if (currentStatementSidePanelMode === 'EDIT') {
        currentStatementSidePanelMode = 'SEARCH';
    }
    changeModeTo(currentStatementSidePanelMode);
}

findsButton().onClick(changeModeToSearch);
editButton().onClick(changeModeToEdit);
interpretButton().onClick(changeModeToInterpret);
minimizeButton().onClick(togglePanel);
closeStatementMenuButton().onClick(hideStatements);
importLinkButton().onClick(sendToImport);


function sidePanelContent() {
    return {
        show: function(element){
            $(element).show();
        },
        hide: function(element){
            $(element).hide();
        }
    }
}

function hideStatements() {
    toggleStatementSidePanel();
}


// Select the default view for entrycontrol

if (userFactory.getViewType() == 'external' || localStorage.getItem('entrypanel') == 'search') {    
    currentStatementSidePanelMode = "SEARCH"
}

changeModeTo(currentStatementSidePanelMode);

// OnLoad get the right height for the entries elements â€” this depends on the form so it's here

var uproll = $('#entryform').height();

if (hide_edit) {
  uproll = 50;
}

entries().fillSpace(uproll + 100);

// Scroll down all the entries

entries().scroll();

// Do the same with when the window is resized 

$(window).resize(function() {
    entries().fillSpace(uproll + 100);
    entries().scroll();
});

// Make texarea automatically resizeable
$('textarea').autosize();





// Here we perform some live updates of the graph on receiving a Socket.IO message
// We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

// TODO set up chatroom, make better design, think of graph sharing functionality

socket.on('chat message', function(msg){
    
    let selfPosted = userFactory.getSelfPosted();

    let perceivedby = userFactory.getLoggedInUser();    

    let posted_by = msg.postedby;

    let alien = false;

    let chatbot = false;

    // if the message is not self-posted and also if the poster of the message is not the same as the guy logged in (in case there's two logins simultaneously)
    if (!selfPosted && perceivedby != posted_by) {

        // add the alien class so the posted message looks like it's from elsewhere
        alien = true;

        // add another class if this is a help message from the chatbot
        if (msg.help) {
            chatbot = true;
        }

        // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var receivedby = userFactory.getWatchedUser();

        // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
        // This is only for collaboration - we resubmit, otherwise it's already submitted before
        if ((receivedby != msg.postedby) && !msg.mute) {
            // Populate the form and submit
            addEntryForm().populateAndPost(msg.entrytext, addEntryForm().post);
        }
    }

    // So let's add that entry to the #entries div
    entries().append(msg.entrytext, msg.entryuid, msg.entryname, msg.postedby, alien, chatbot);

    // Unfocus and reFocus again on the entry field
    addEntryForm().refocus();

    // Add some behavior hooks again onto that element
    // One click will filter the nodes / edges of the statement on the graph
    // Doubleclick will open the edit pane

    entries().onClick(entrySelect);

    adding_entry = true;
    if (dynamic_watch == 1 && dynamic_graph == 1) {
      $('#watch-link').trigger('click');
      setTimeout(function() {
        entries().scroll();
      }, 500);
      setTimeout(function() {
        adding_entry = false;
        $('#watch-link').trigger('click');
      }, 4000);
    }
    else {
        entries().scroll();
    }

    var addednodes = msg.graph.nodes;
    var addededges = msg.graph.edges;

    graphFactory.addNewNodes(addednodes, addededges, msg.entryuid);

   

    // MIDI activation

    // Play a note on adding nodes / edges

    <% if (locals.user) { %>
    <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


    console.log('using MIDI data ' + midi);
    console.log('playing MIDI device:');
    console.log(output);

    var timecode = 0;

    var note_node = midi.substr(10,2);
    if (note_node.substr(1,1) == '0') {
      note_node = note_node.substr(0,1) + '1';
    }

    var note_edge = midi.substr(12,2);
    if (note_edge.substr(1,1) == '0') {
      note_edge = note_edge.substr(0,1) + '1';
    }



    for (var m = 0; m < nodes_added.length; m++) {


        setTimeout(function () {
          output.playNote(note_node, parseInt(midi.substr(0,2)));
          output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
          console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
        }, timecode);
        timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
    }

    var timecodea = 0;

    for (var ed = 0; ed < edges_added.length; ed++) {

        setTimeout(function () {
          output.playNote(note_edge, parseInt(midi.substr(2,2)));
          output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
          console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
        }, timecodea);
          timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

    }

    <% } %>
    <% } %>




    //console.log(newnodes);
    // console.log(msg.graph.edges);
    // console.log(sigma.instances(0).graph.edges());

    // TODO right now it doubles the code above

    // This is for special cases where the user is on a graph, but they are adding their own stuff to this graph into a new graph, so we only show the entries that he added, not the previous ones
    entries().removeAddContext();


});



// What do do when the form is submitted and a new entry (text) is added?




</script>