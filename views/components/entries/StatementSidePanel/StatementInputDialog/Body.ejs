 
<div id="edit-panel">
    <form action='/post' name='submitform' id="submitform" method='post' class='pure-form'>

            <textarea columns="40" rows="4" name='entry[body]' id="statement" placeholder='type in some words or #hashtags to see how they connect'><% if (url) { %><%= urltitle %> <%= url %><% } %></textarea>
            <div id="addToContextsLabel">in context:</div>
            <ul id="addToContexts"></ul>
            <input type="hidden" id="addedContexts" name="addedContexts">
            <input type="hidden" id="context" name="context" value="<%= context %>">
            <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
            <input type="hidden" id="statementid" name="statementid" value="">
            <input type="hidden" name="timestamp" value="">
            &nbsp;<br>
            <input type='submit' id="submitbutton" name="btnSubmit" value="save" class="pure-button pure-button-primary">

    </form>
</div>

<div id="search-panel">
    <form class="pure-form" id="searchform">
        <input type="text" id="search" size="14" maxlength="20" class="pure-input" placeholder="search...">
        &nbsp;&nbsp;
        <input type='submit' name="submit" value=">" class="pure-button pure-button-primary">
    </form>
</div>

<script>


    let mute = getUrlVars()["mute"];

    // Used to populate entry textfield
    let current_context_field = [];

    // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
    let postedby = '';

    <% if (receivername) { %>
    postedby = '<%= receivername %>';
    <% } %>
    
    searchForm().onSubmit(submitSearchForm);

    addEntryForm().activate();

    addEntryForm().onSubmit(submitEditForm);

    function submitButton() {
        return {
            disable: function() {
                $('#submitbutton').attr('disabled', 'disabled');
            },
            enable: function() {
                $('#submitbutton').removeAttr('disabled');
            }
        }
    }

    function searchForm() {
        return {
            autofill: function() {
                autoComplete('#search',graphFactory.getNodeNames());  
            },
            onSubmit: function(onSubmit) {   
                $('#searchform').on('submit', onSubmit);
            }
        }
    }

    function addEntryForm() {
        return {
            update: function(content) {          
                if ($('#statement').val().length == 0 || $('#statement').val().charAt(0) == '#') {
                    $('#statement').val(arrayToHashtagString(content));
                }
            },
            onSubmit: function(onSubmit) {
                $('#submitform').on('submit', onSubmit);
            },
            activate: function() {
                // Submit the form on enter
                $('#statement').keypress(function(e){            
                    if(e.which == 13 && !e.shiftKey) {
                        e.preventDefault();
                        $('#submitbutton').trigger('click');
                    }
                });

                // Let's add the right context into the entry form
                if (document.getElementById('context').value) {
                    current_context_field = [document.getElementById('context').value];
                    $("#addedContexts").val(document.getElementById('context').value);
                }

                // if not, we're making the 'private' context default
                else {
                    var lastcontexts = [];
                    var laststatement = $(".entry:last").attr('data-uid');
                    for (var key in statementsOfContext) {
                        var reiteratestatements = statementsOfContext[key];
                        for (var i = 0; i< reiteratestatements.length; i++) {
                            if (laststatement == reiteratestatements[i]) {
                                lastcontexts.push(key);
                                console.log(key);
                            }
                        }

                    }
                    if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                        current_context_field = ['private'];
                        $("#addedContexts").val('private');
                    }

                    else {
                        current_context_field = lastcontexts;
                        $("#addedContexts").val(current_context_field.join());
                    }
                }

                // Let's add into the contexts field
                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in hidden field: ' + current_context_field.join());
                    },
                    afterDelete: function(tag) {
                        console.log('initiated delete from sigma');
                        for (var i=current_context_field.length-1; i>=0; i--) {
                            if (current_context_field[i] === tag) {
                                current_context_field.splice(i, 1);
                            }
                        }
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in hidden field: ' + current_context_field.join());
                    }
                });
            },
            disable: function() {
                $('#statement').addClass('loading');
            },
            enable: function() {
                $('#statement').removeClass('loading');
            },
            clear: function() {
                $("#statement").val('');
            },
            refocus: function() {
                $('#statement').blur();
                $('#statement').focus();
            },
            populateAndPost: function(text, callback) {
                let to_submit = $('#submitform').serializeArray();
                for (let key in to_submit) {
                    if (to_submit[key].name == 'entry[body]') {
                        to_submit[key].value = text;
                    }
                }
                callback($.param(to_submit));
            },
            post: function(submitData) {
                if (!submitData) {
                    submitData = $("#submitform").serialize();
                }
                $.post('/post', submitData)
                    .done(function(res) {
                        // Get the response from the server (ID of the entry added)
                        if (res.entryuid) {
                     
                            addEntryForm().clear();
                            addEntryForm().enable();
                            submitButton().enable();

                            // This below if a few statements were posted
                            // TODO as we can now get all the s.uid back as an array this could be rewritten so no need for the condition after
                            if (res.entryuid == 'multiple') {
                                socket.emit('chat message', {postedby: postedby, entryuid: 'multiplesocket', entrytext: res.entrycontent, graph: res.graph});
                                if (res.successmsg) {
                                   userMessages().display('Please, reload the page after a few seconds to see the graph.');
                                }
                                setTimeout(function() {
                                    location.reload();
                                },3000);
                            }
                            else {
                                // Only one statement added? Initiate processing that will show it both to the user and the collaborator (if exists)
                                socket.emit('chat message', {postedby: postedby, entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                            }

                        }
                        else if (res.errormsg) {
                            addEntryForm().enable();
                            submitButton().enable();
                            displayAlert(res.errormsg);
                        }
                        else {
                            displayAlert('Something went wrong, please, try again...');
                        }
                    })
                    .fail(function(res) {
                        displayAlert("Server Error: " + res.status + " " + res.statusText);
                    });
            } 
        }
    }


    function submitSearchForm(e) {

    
        e.preventDefault();
        // What are we searching?
        var searchPhrase = $('#search').val();

        if (searchPhrase.length > 1) {

            // Clean up the search string
            searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

            // Separate terms into array
            var searchArray = searchPhrase.toLowerCase().split(" ");

            var searchPhraseLemmas = [];


            for (var j = 0; j < searchArray.length; j++) {
                // Is the search term cyrillic?
                var search_cyrillic = searchArray[j].match(/[а-яА-Я]/);

                // SEARCHMOD
                // var search_lemma = window.jstemmer(searchArray[j]);

                var search_lemma = searchArray[j];

                searchPhraseLemmas.push(search_lemma);

            }

            for (var k = 0; k < searchPhraseLemmas.length; k++) {
                if (graphFactory.checkIfPinned(searchPhraseLemmas[k]) == false) {
                    graphFactory.addToPinnedNodes(searchPhraseLemmas[k]);
                }
            }

        }

    }
    

    function submitEditForm() {

        addEntryForm().disable();

        submitButton().disable();

        voiceInputPanel().update();

        // is urlvars mute off? in this case we submit this entry
        if (!mute) {
            userFactory.updateSelfPosted('true');
            addEntryForm().post();
        }
        // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
        // This was made before to introduce a chat feature — so the software can "talk" to the user without adding stuff into the graph
        else {
            addEntryForm().enable();
            submitButton().enable();
            addEntryForm().clear();
            socket.emit('chat message', {mute: 1, postedby: postedby, entryuid: '', entrytext: $('#statement').val(), graph: '' });
        }

        return false;
        
    }


    // Textarea select conversion to hashtags

    // For now it's disabled, but will be enabled for bulk statement correction later

    var getSelected = function(){
        var t = '';
        if(window.getSelection) {
            t = window.getSelection();
        } else if(document.getSelection) {
            t = document.getSelection();
        } else if(document.selection) {
            t = document.selection.createRange().text;
        }
        return t;
    }


    $("#statement").select(function(eventObject) {
        var selectedText = getSelected().toString();

        var statementReplace = $("#statement").val();

        if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

            var regex = RegExp(selectedText, "g");

            var dasherized = S(selectedText).underscore().chompLeft('_').s;

            // TODO check words for morphology (if found, alert)

            var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
            $("#statement").val(replacedString);
        }

    });




</script>