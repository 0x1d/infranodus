<script>

var jsonpath = '';

// Path to the JSON graph file (specific context or a general one)
<% if (addcontext) { %>
    jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
    addcontext = "<%= addcontext %>";

<% } else if (showcontexts) { %>
    jsonpath = '/api/user/nodes/<%= context %>?showcontexts=<%= showcontexts %>';
    addcontext = "";

<% } else if (maxnodes) { %>
    jsonpath = '/api/user/nodes/<%= context %>?maxnodes=<%= maxnodes %>';
    maxnodes = '<%= maxnodes %>';
    addcontext = "";

<% } else { %>
    jsonpath = '/api/user/nodes/<%= context %>';
    addcontext = "";
<% }  %>

// Is the user going to look at somebody else's graph?

<% if (perceivername) { %>
    <% if (showcontexts && maxnodes) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>&maxnodes=<%= maxnodes %>';
    <% } else if (showcontexts) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>';
    <% } else if (maxnodes) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= maxnodes %>';
    <% } else  { %>
        <% if (locals.vieweduser && vieweduser.maxnodes) { %>
            maxnodes = '<%= vieweduser.maxnodes %>';
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= vieweduser.maxnodes %>';
        <% } else { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>';
        <% } %>
<% } %>
<% } %>


// Do we show abstract graph and no nodes?
var abstract;

<% if (locals.user && locals.user.abstract != undefined) { %>
        abstract = '<%=locals.user.abstract%>';
<% } %>

if (getUrlVars()["abstract"]) {
      abstract = getUrlVars()["abstract"];
}



// default label threshold
var in_label_threshold = 8;

var default_label_color = '#000000';

if (background == 'dark') {
  default_label_color = '#ffffff';
}

var minnodesize = 5;
var maxnodesize = 16;

if (abstract && abstract != 'no') {
    minnodesize = 1;
    maxnodesize = 1;
    in_label_threshold = 20;
}

// default most influential nodes are displayed according to Betwenness Centrality (bc) or Degree (degree)
var most_influential = 'bc';

<% if (locals.user.topnodes) { %>
most_influential = '<%= user.topnodes %>';
<% } %>

if (getUrlVars()["most_influential"] == 'bc' || getUrlVars()["most_influential"] == 'bc2' || getUrlVars()["most_influential"] == 'degree') {
  most_influential = getUrlVars()["most_influential"];
}

// Sigma graph layout options
var forceatlas_options = {worker: false, startingIterations: 100, scalingRatio: 0.1, slowDown: 100, strongGravityMode: true};


// Create node ID - Name index for filtering
var nodeIDs = {};

var nodeIDs_rev = {};

// Initial graph model saved
var nodesDB = [];
var edgesDB = [];

// Create context-node index for filtering
var contextNodeID = [];

// Create statement-node index for filtering
var nodesOfStatement = [];

// What are the concepts present in the graph?
var contextNames = [];

// What are the concepts present in the graph?
var statementsOfContext = [];

// Cytoscape object

var elesnodes = [];

// Add Cytoscape Library - to calculate betweenness centrality for nodes and other stuff

var cy = cytoscape({
    container: undefined,
    headless: true
});

var eles;

var topbc_nodes = [];

var top_components = [];

// Let's record all the unique edges we've got
var edgesList = [];

var community_of_node = [];


var sigma_dragged = 0;


sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: minnodesize,
                maxNodeSize: maxnodesize,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: in_label_threshold,
                defaultLabelColor: default_label_color
            }
        },
        function(sigma) {
            var i,
                    timeout = 4000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#cccccc',
                    len = nodes.length;

            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
            // We also make the initial graph layout circular, so that ForceAtlas always looks the same

            var maxnodesize = 0;

            for (i = 0; i < len; i++) {
                var nodesize = 0;
                var angle = Math.PI * 2 * i / len;
                nodes[i].x = Math.cos(angle);
                nodes[i].y = Math.sin(angle);
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodesize = nodes[i].size;
                if (maxnodesize < nodesize) maxnodesize = nodesize;
                nodes[i].color = color_context;

                // Add to Cytoscape
                elesnodes.push({
                    group: "nodes",
                    data: { id: nodes[i].id, name: nodes[i].label}
                });
               

            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

            //  console.log(e.source + ' ' + e.target + ' ' + e.weight);

                var unique_edge_id = '';

                // Let's see if the edge source in alphabetical order is further than its target and change places

                if (e.source > e.target) {
                    unique_edge_id = e.target + '-' + e.source;
                }
                else {
                    unique_edge_id = e.source + '-' + e.target;
                }


                // Let's make a unique list of edges to count how many there are of the same kind

                if (edgesList[unique_edge_id]) {
                    ++edgesList[unique_edge_id];

                    // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                    e.size = e.weight + edgesList[unique_edge_id];
                }
                else {
                    edgesList[unique_edge_id] = 1;
                    e.size = e.weight;
                }


                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement
                for (let item of e.statement_id) {
                  if (nodesOfStatement[item]) {
                      if (nodesOfStatement[item].indexOf(e.source) < 0)
                          nodesOfStatement[item].push(e.source);
                      if (nodesOfStatement[item].indexOf(e.target) < 0)
                          nodesOfStatement[item].push(e.target);
                  }
                  else {
                      nodesOfStatement[item] = [];
                      nodesOfStatement[item].push(e.source);
                      nodesOfStatement[item].push(e.target);
                  }
                }

                if (statementsOfContext[e.edge_context]) {
                    for (let item of e.statement_id) {
                      if (statementsOfContext[e.edge_context].indexOf(item) < 0) statementsOfContext[e.edge_context].push(item);
                    }
                }
                else {
                    statementsOfContext[e.edge_context] = [];
                    for (let item of e.statement_id) {
                      statementsOfContext[e.edge_context].push(item);
                    }
                }

                // Add to Cytoscape
                elesnodes.push({
                    group: "edges",
                    data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                });

               

                // Add to EDGES db
                edgesDB.push(e);

            });




            sigma.graph.nodes().forEach(function(n) {

                // Save node's default color, for hide and show later
                n.originalColor = n.color;
                n.originalLabel = n.label;

                // Creating an index of node labels to IDs for filtering
                var key = n.label;
                nodeIDs[key] = n.id;

            });


           //sigma.refresh();





            // for (var j = 0; j < cy.nodes().length; j++) {
            //    console.log(cy.edges()[j].data());
            // }

            //  console.log(eles.getElementById('d5167020-d3ac-11e3-a954-ab35be27f3fc'));


            // Make a list of all the node labels displayed in the graph (for Autofill)

            nodeNames = _.keys(nodeIDs);



            // Get the context names - all the contexts that exist in the graph we just loaded
            // This IF statement is for the case when the contextlist parameter is not passed on

            // NOTE this function can be activated if you want to get the list of contexts from the visible graph only
            // contextNames = _.keys(contextNodeID);

            // populateContextMenu(contextNames);

            // Now we get the context IDs from the graph - a little bit of a workaround
            var suspects = [];
            var nonsuspects = [];

            nodeIDs_rev = _.invert(nodeIDs);

            var jsGraphEdges = [];

            sigma.graph.edges().forEach(function(e) {

                // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                if (e.id.substr(0,7) == 'context') {
                        if (suspects.indexOf(e.source) < 0) {
                            suspects.push(e.source);
                        }

                        if (suspects.indexOf(e.target) < 0) {
                            suspects.push(e.target);
                        }

                }

                // If an edge doesn't have prefix context, for sure it has only nodes
                else {
                        if (nonsuspects.indexOf(e.source) < 0) {
                            nonsuspects.push(e.source);
                        }

                        if (nonsuspects.indexOf(e.target) < 0) {
                            nonsuspects.push(e.target);
                        }
                }

                // TODO remove that, this is just to check data consistentency
                e.sourcename = nodeIDs_rev[e.source];
                e.targetname = nodeIDs_rev[e.target];

                 // Add to jsnetworkx

                 var edge_params = {
                     weight: e.weight,
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
                 };

                 var edge_object = [e.source, e.target, edge_params];
                 
                 jsGraphEdges.push(edge_object);
                 
                 
            });

            var jsG = new jsnx.DiGraph();
            jsG.addEdgesFrom(jsGraphEdges);

            // console.log(jsG.edges(true));

    
            // Find the difference between two arrays above, so we get contexts only
            var contextids = _.difference(suspects, nonsuspects);


            // Now show those nodes that are contexts bigger and with a special label

            for (i = 0; i < len; i++) {

                if (contextids.indexOf(nodes[i].id) > -1) {
                    nodes[i].size = maxnodesize;
                    nodes[i].originalLabel = 'context: ' + nodes[i].originalLabel;
                    nodes[i].label = 'context: ' + nodes[i].label;
                }


            }




            // Initialize autofill for hashtags and contexts
            autofill(nodeNames,contextNames);


            if (document.getElementById('context').value) {
                current_context_field = [document.getElementById('context').value];
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:last").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                    current_context_field = ['private'];
                    $("#addedContexts").val('private');
                }

                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            if (background == 'dark') { $('#tagInputBox').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'}); }
            // Do ForceAtlasLayout

            if (sigma.isForceAtlas2Running()) {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
            }
            else {
              sigma.startForceAtlas2(forceatlas_options);
            }


            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
                downloadPNG();

            },timeout);


            // Drag nodes function initiated, so we can drag nodes

            dragNodes();

            // Betweenness Centrality Calculation using Cytoscape

            // console.log(elesnodes);
            eles = cy.add(elesnodes);


            //console.log(eles.nodes().length);

            betweennessCentrality(eles, jsG);

            // Community detect algorithm

            communityDetect();


            // TODO make it possible for collaboration also

            if (addcontext && interpret) {

              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

              // $('.entry').each(function() {
              //   if ($(this).is(':hidden')) {
              //     $(this).remove();
              //   }
              // });



            }


            // What happens when we click analytics pane

            $('#analyticsbutton').click(function(){
                      // Process logic and remember settings
                     $('#analytics').toggle('slide', function(){
                       if ($('#analytics').is(":visible")) {
                         localStorage.setItem('analytics', 1);
                         $('#analyticsbutton').addClass('analytics-on');
                         $('#analyticscaption').hide();

                       }
                       else {
                         localStorage.setItem('analytics', 0);
                         $('#analyticsbutton').removeClass('analytics-on')
                         $('#analyticscaption').show();
                       }
                     });



            });

            $('#analytics').on('swipedown',function(){$('#analyticsbutton').trigger('click');});

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {
              if (!sigma_dragged) {
                // A node was clicked, so we assume there was a meaningful graph interaction
                graphInteraction = 1;

                var nodeLabel = e.data.node.originalLabel;

                if (interpret) {
                  $('.entry').show();
                }


                if (nodeLabel.substr(0,9) == 'context: ') {
                    window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>',"_self");
                }
                else {

                    // Was the node clicked already? No? Add it to array of clicked nodes.
                    // Highlight the clicked node in the text.


                    if (splicedNodes.length > 1) {
                         pinnedNodes = [];
                         for (var p = 0; p < splicedNodes.length; p++ ){
                             pinnedNodes[p] = splicedNodes[p];
                         }
                    }
                    else if (splicedNodes.length == 1) {
                        pinnedNodes = [];
                        pinnedNodes[0] = splicedNodes[0];
                        splicedNodes = [];
                    }

                    if (pinnedNodes.indexOf(nodeLabel) < 0) {
                        pinnedNodes.push(nodeLabel);
                    }
                    else {
                        var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                        if (pinnedIndex > -1) {
                            pinnedNodes.splice(pinnedIndex,1);
                            $('.entry').fadeIn(400);
                        }

                    }

                    // console.log("Pinned nodes: " + pinnedNodes);
                    // console.log("Spliced nodes: " + splicedNodes);
                    socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


                    // Now show / hide statements that have the search field

                    filter_statements(pinnedNodes);




                    // If the window is wide enough to show the menu AND div with statements is not visible

                    var isHidden = $("#statements").is(":hidden");

                    // if (isHidden) {
                    //
                    //     var delayShow = 6000;
                    //
                    //     clearTimeout(inactiveTimeout);
                    //     inactiveTimeout = setTimeout(showStatements, delayShow);
                    //
                    //     $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                    //     $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function(){
                    //         if (graphInteraction) {
                    //             clearTimeout(inactiveTimeout);
                    //             inactiveTimeout = setTimeout(showStatements, delayShow);
                    //         }
                    //     });
                    //
                    //
                    // }

                }

              }

              // This is just to reset node drag parameter
              sigma_dragged = 0;


            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && pinnedNodes.indexOf(e.data.node.originalLabel) < 0) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });



            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });

    

            

            // Forward from the graph function

           



            // Here we perform some live updates of the graph on receiving a Socket.IO message
            // We could also move this code and use sigma.instances(0).graph.nodes() to get sigma properties

            // TODO set up chatroom, make better design, think of graph sharing functionality

            socket.on('chat message', function(msg){

                visibleentries_original = visibleentries_original + 1;

                var perceivedby = '';

                <% if (receivername) { %>
                   perceivedby = '<%= receivername %>';
                <% } %>

                var posted_by = msg.postedby;

                var added_entry =  "<div class='entry' style='display: none;' data-uid='" + msg.entryuid + "' data-hashtags='" + msg.entryname + "'><p class='entry-text'>" + msg.entrytext + "</p><p class='entry-date'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                // if the message is not self-posted and also if the poster of the message is not the same as the guy logged in (in case there's two logins simultaneously)
                if (!selfPosted && perceivedby != posted_by) {
                    // add the alien class so the posted message looks like it's from elsewhere
                    added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>by " + posted_by + " at " + moment().format('hh:mm:ss') + "</p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";

                    if (msg.help) {
                        added_entry =  "<div class='entry alien' style='display: none; margin-left: 50px' data-uid='" + msg.entryuid + "'><p class='entry-text gray'>" + msg.entrytext + "</p><p class='entry-date gray'>help tip &nbsp;<em></em><a href='javascript:' class='disablehelp'>disable</a></em></p><div class='separator'>&nbsp;</div><div id='" + msg.entryuid + "' class='hidden'></div></div>";
                    }

                    // We will set a user for receiving. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
                    var receivedby = '';

                     <% if (perceivername) { %>
                        receivedby = '<%= perceivername %>';
                    <% } %>

                    // TODO make it possible that those statements get submitted in both graphs

                    // So the user who posted is not the same who's receiving? then submit the form. If the sender didnt have the mute option
                    // This is only for collaboration - we resubmit, otherwise it's already submitted before
                    if ((receivedby != msg.postedby) && !msg.mute) {


                        /*var temporary_statement = $('#statement').val();
                        $('#statement').val(msg.entrytext);
                        console.log($("#submitform").serialize());*/

                        var to_submit = $('#submitform').serializeArray();

                        for (key in to_submit) {
                            if (to_submit[key].name == 'entry[body]') {
                                to_submit[key].value = msg.entrytext;
                            }
                        }

                        $.post('/post', $.param(to_submit))
                                .done(function(res) {

                          /*          $('#statement').val(temporary_statement);*/

                                    //3. Receive the server response, no need to emit an event
                                    if (res.entryuid) {
                                        //4. Show the updated text

                                        if (res.entryuid == 'multiple') {
                                          if (res.successmsg) {
                                            $("#warnings").append('<p class="warning">Your collaborator submitted a long text. Please, reload the page to see the graph.</p>');
                                            $("#warnings").slideDown('slow');
                                          }
                                          setTimeout(function() {
                                              location.reload();
                                          },3000);
                                        }
                                    }
                                    else if (res.errormsg) {
                                        alert(res.errormsg);
                                    }
                                    else {
                                        alert('Something went wrong, please, try again...');
                                    }
                                })
                                .fail(function(res) {
                                    alert("Server Error: " + res.status + " " + res.statusText);
                                });

                    }



                }
                else {
                    selfPosted = null;
                }

                // So let's add that entry to the #entries DIV

                $(added_entry).appendTo($('#entries')).slideDown("fast");

                // Do some stupid class change for the dark theme background
                if (background == 'dark') {
                  $('.entry').addClass('entry-dark');
                  $('.entry-text').addClass('entry-text-dark');
                }
                // Nicely scroll







                //$('#entries').append(added_entry).slideUp("fast");

                // Unfocus and reFocus again on the entry field
                $('#statement').blur();
                $('#statement').focus();


                    // Add some behavior hooks again onto that element
                    // One click will filter the nodes / edges of the statement on the graph
                    // Doubleclick will open the edit pane

                    entryClick();
                    entryDoubleClick();


                    adding_entry = true;
                    if (dynamic_watch == 1 && dynamic_graph == 1) {
                      $('#watch-link').trigger('click');
                      setTimeout(function() {
                        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
                      }, 500);
                      setTimeout(function() {
                        adding_entry = false;
                        $('#watch-link').trigger('click');
                      }, 4000);
                    }
                    else {
                      $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
                    }

                    var addednodes = msg.graph.nodes;
                    var addededges = msg.graph.edges;

                    var nodes_added = [];
                    var edges_added = [];


                    // Let's add the nodes to the Sigma graph
                    for (var i = 0; i < addednodes.length; i++) {

                        if (nodeNames.indexOf(addednodes[i].label) == -1) {

                           // var angle = Math.PI * 2 * i / len;

                            sigma.graph.addNode({
                                id: (id = addednodes[i].id),
                                label: addednodes[i].label,
                                originalLabel: addednodes[i].label,
                                originalColor: color_context,
                                size: maxnodesize - 2,
                                x: Math.random(),
                                y: Math.random(),
                                color: color_context
                            });
                            nodeNames.push(addednodes[i].label);
                            nodes_added.push(addednodes[i]);
                            if (!nodeIDs[addednodes[i].label]) {
                              nodeIDs[addednodes[i].label] = addednodes[i].id;
                            }


                        }


                    }

                    // Let's add the edges to the Sigma graph

                    for (var j = 0; j < addededges.length; j++) {

                       if ((addededges[j].statement_id == msg.entryuid)) {


                         var unique_edge_id = '';

                         // Let's see if the edge source in alphabetical order is further than its target and change places

                         if (addededges[j].source > addededges[j].target) {
                             unique_edge_id = addededges[j].target + '-' + addededges[j].source;
                         }
                         else {
                             unique_edge_id = addededges[j].source + '-' + addededges[j].target;
                         }


                            sigma.graph.addEdge({
                                id: addededges[j].id,
                                source: addededges[j].source,
                                target: addededges[j].target,
                                weight: addededges[j].weight,
                                size: addededges[j].weight,
                                statement_id: addededges[j].statement_id,
                                edge_context: addededges[j].edge_context
                            });

                            edges_added.push(addededges[j]);


                        }

                    }

                    // Let's create a new collection for Cytoscape - used to calculate node metrics for the graph
                    var collection = cy.elements();
                    cy.remove(collection);

                    elesnodes = [];

                    // Adding all the refreshed nodes into Cytoscape
                    sigma.graph.nodes().forEach(function(n) {
                        if (n.id == 'dummy') {
                            sigma.graph.dropNode('dummy');
                        }
                        else {

                          // Add to Cytoscape
                          elesnodes.push({
                              group: "nodes",
                              data: { id: n.id, name: n.label}
                          });

                        }

                      //n.size = sigma.graph.degree(n.id);

                    });

                    // For each edge in the graph recalculate some important metrics
                    // And update global parameters which we use to track the state of each element
                    // TODO this code duplicates from above - move into a function
                    sigma.graph.edges().forEach(function(e) {

                      var unique_edge_id = '';

                      // Let's see if the edge source in alphabetical order is further than its target and change places

                      if (e.source > e.target) {
                          unique_edge_id = e.target + '-' + e.source;
                      }
                      else {
                          unique_edge_id = e.source + '-' + e.target;
                      }


                        // Make and index of nodes to statement

                          if (nodesOfStatement[e.statement_id]) {
                              if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                                  nodesOfStatement[e.statement_id].push(e.source);
                              if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                                  nodesOfStatement[e.statement_id].push(e.target);
                          }
                          else {
                              nodesOfStatement[e.statement_id] = [];
                              nodesOfStatement[e.statement_id].push(e.source);
                              nodesOfStatement[e.statement_id].push(e.target);
                          }

                        // Which statements belong to which context / graph
                        if (statementsOfContext[e.edge_context]) {
                              if (statementsOfContext[e.edge_context].indexOf(e.statement_id[0]) < 0) {
                                statementsOfContext[e.edge_context].push(e.statement_id[0]);
                              }
                        }
                        else {
                            statementsOfContext[e.edge_context] = [];
                            statementsOfContext[e.edge_context].push(e.statement_id[0]);
                        }


                                        // Make an index of nodes to context
                                        if (contextNodeID[e.edge_context]) {
                                            if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                                                contextNodeID[e.edge_context].push(e.source);
                                            if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                                                contextNodeID[e.edge_context].push(e.target);
                                        }
                                        else {
                                            contextNodeID[e.edge_context] = [];
                                            contextNodeID[e.edge_context].push(e.source);
                                            contextNodeID[e.edge_context].push(e.target);
                                        }


                        // Add to Cytoscape for betweenness centrality calculation
                        elesnodes.push({
                            group: "edges",
                            data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                        });


                    });


                    // Betweenness Centrality Calculation using Cytoscape
                    eless = cy.add(elesnodes);

                    // console.log(eles.nodes().length);

                    betweennessCentrality(eless);
                    communityDetect();

                    //sigma.refresh();

                    // Launch new layout
                    if (forcedatlas_running) {
                      $('#improve-layout').trigger('click');
                      setTimeout(function() {
                        $('#improve-layout').trigger('click');
                      }, 500);
                    }
                    else {
                      sigma.startForceAtlas2(forceatlas_options);
                      setTimeout(function() {

                          sigma.stopForceAtlas2();
                          sigma.killForceAtlas2();

                      }, 3000);
                    }

                    // MIDI activation

                    // Play a note on adding nodes / edges

                    <% if (locals.user) { %>
                    <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


                    console.log('using MIDI data ' + midi);
                    console.log('playing MIDI device:');
                    console.log(output);

                    var timecode = 0;

                    var note_node = midi.substr(10,2);
                    if (note_node.substr(1,1) == '0') {
                      note_node = note_node.substr(0,1) + '1';
                    }

                    var note_edge = midi.substr(12,2);
                    if (note_edge.substr(1,1) == '0') {
                      note_edge = note_edge.substr(0,1) + '1';
                    }



                    for (var m = 0; m < nodes_added.length; m++) {


                        setTimeout(function () {
                          output.playNote(note_node, parseInt(midi.substr(0,2)));
                          output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
                          console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
                        }, timecode);
                        timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
                    }

                    var timecodea = 0;

                    for (var ed = 0; ed < edges_added.length; ed++) {

                        setTimeout(function () {
                          output.playNote(note_edge, parseInt(midi.substr(2,2)));
                          output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
                          console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
                        }, timecodea);
                          timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

                    }

                    <% } %>
                    <% } %>




                    //console.log(newnodes);
                    // console.log(msg.graph.edges);
                    // console.log(sigma.graph.edges());

                    // TODO right now it doubles the code above

                    // This is for special cases where the user is on a graph, but they are adding their own stuff to this graph into a new graph, so we only show the entries that he added, not the previous ones
                    if (addcontext && interpret) {

                      $('.entry').hide();

                      for (var ite in statementsOfContext[current_context]) {

                        $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                          $(this).show();
                        });

                      }


                  }


            });

            // This is called when an entry is deleted

            socket.on('delete message', function(msg){


                $('[data-uid="' + msg.entryuid + '"]').fadeOut();

                $("#statement").val('');

                // When searched for nodes in that statement, nothing will appear.

                nodesOfStatement[msg.entryuid] = [];

                // Let's set up which nodes we will keep
                var nodesToKeep = [];

                sigma.graph.edges().forEach(function(e) {

                    // If a node appears in at least one statement, we add him in ToKeep list
                  for (let item of e.statement_id) {
                    if (nodesOfStatement[item].indexOf(e.source) > -1) {
                        nodesToKeep.push(e.source);
                    }

                    if (nodesOfStatement[item].indexOf(e.target) > -1) {
                        nodesToKeep.push(e.target);
                    }

                    var statePosition = statementsOfContext[e.edge_context].indexOf(item);
                    if (statePosition < 0) {
                        statementsOfContext[e.edge_context].splice(statePosition, 1);
                    }
                }

                });


                // Delete nodes from the graph that are not in nodesToKeep set above

                sigma.graph.nodes().forEach(function(n) {
                    if (nodesToKeep.indexOf(n.id) < 0) {
                        sigma.graph.dropNode(n.id);
                    }

                });

                // Refresh the object and reload the layout

                sigma.refresh();

                sigma.startForceAtlas2(forceatlas_options);

                // Don't run it forever not to overheat :)

                setTimeout(function() {

                    sigma.stopForceAtlas2();
                    sigma.killForceAtlas2();

                }, 3000);

                //console.log(newnodes);
                // console.log(msg.graph.edges);
                // console.log(sigma.graph.edges());


            });




        }
);

 // NOTE here we start some global functions, which perhaps can be extracted if no globals are used inside


 function dragNodes () {
      var dragListener = sigma.plugins.dragNodes(sigma.instances(0), sigma.instances(0).renderers[0]);
      dragListener.bind('startdrag', function(event) {

      });
      dragListener.bind('drag', function(event) {
        sigma_dragged = 1;
        if (sigma.instances(0).isForceAtlas2Running()) {

          sigma.instances(0).stopForceAtlas2();
          sigma.instances(0).killForceAtlas2();
        }


      });
      dragListener.bind('drop', function(event) {


        // sigma.instances(0).refresh();

        var new_forceatlas_options = forceatlas_options;

        new_forceatlas_options.slowDown = 1000;
        new_forceatlas_options.startingIterations = 0;

        sigma.instances(0).startForceAtlas2(new_forceatlas_options);

        // Don't run it forever not to overheat :)

        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 10000);

     });
      dragListener.bind('dragend', function(event) {

      });
    }



    // Calculate Betweenness Centrality

    var bc_nodes_map;

    function betweennessCentrality (eles, jsG) {

      var collection = cy.elements();
      // console.log(eles);
      // console.log(collection);

      var jsbc = jsnx.betweennessCentrality(jsG, {normalized: true, weight: 'weight', endpoints: true});
      var bc_jsx = jsbc._stringValues;
      
      

      var bc = eles.bc({
          weight: function(edges) {
              return edges.data('weight');
          },
          directed: true
      });

      var bcmin = 1;
      var bcmax = 0;

      var bcmap = [];

      topbc_nodes = [];

      if (!jsG) {
      for (var i = 0; i < cy.nodes().length; i++) {

          var nn = eles.getElementById(cy.nodes()[i].data('id'));

          var currentbc = bc.betweennessNormalized(nn);

          bcmap[cy.nodes()[i].data('id')] = currentbc;

          topbc_nodes.push({key: cy.nodes()[i].data('id'), label: cy.nodes()[i].data('name'), bc: currentbc});

          if (bcmin > currentbc && currentbc != 0) {
            bcmin = currentbc;
          }
          else {
            bcmin = 0.00001
          }

          if (bcmax < currentbc) {
            bcmax = currentbc;
          }

      }
    }
    else {
        for (key in bc_jsx) {
            var currentbc = bc_jsx[key];
            topbc_nodes.push({key: key, label: nodeIDs_rev[key], bc: bc_jsx[key]});
            bcmap[key] = bc_jsx[key];

            if (bcmin > currentbc && currentbc != 0) {
                bcmin = currentbc;
            }
            else {
                bcmin = 0.00001
            }

            if (bcmax < currentbc) {
                bcmax = currentbc;
            }
        }
    }
      bc_nodes_map = bcmap;

      topbc_nodes = _.sortBy(topbc_nodes, 'bc').reverse();

      console.log('Top betweenness centrality nodes:');
      console.log(topbc_nodes);

      topbc_nodes = topbc_nodes.slice(0,5);


      sigma.instances(0).graph.nodes().forEach(function(n) {
        if ((most_influential == 'bc' || most_influential == 'bc2') && topbc_nodes[0].bc > 0) {
          if (bcmap[n.id] == 0) { bcscore = bcmin } else { bcscore = bcmap[n.id] }
          n.size = Math.round(normalize(bcscore, bcmin, bcmax, 5, 35));
          n.bc = bcmap[n.id];
        }
        else {
          n.size = sigma.instances(0).graph.degree(n.id);
        }
      });


      top_components = eles.components();

      //sigma.instances(0).refresh();


      //console.log(_.first(_.sortBy(bcmap,'degree').reverse(),3);
      // console.log(bcmin);
      // console.log(bcmax);


    }


        // Community Detect Function

        function communityDetect (coming_from, node_origin) {

// Construct a new Graphology graph object to calculate communities
const grgraph = new graphology.Graph({type: 'undirected'});

// Reiterate nodes
var node_data = [];
sigma.instances(0).graph.nodes().forEach(function(n) {
    node_data.push(n.id);

    // Add nodes into the Graphology object
    grgraph.addNode(n.id);
});

var edge_data = [];

var totaledgescount = 0;

// Reiterate edges
sigma.instances(0).graph.edges().forEach(function(e) {

    var matche = 0;

    for (var i = 0; i < edge_data.length; i++) {
        // replace && with || for undirected graph
      if ((edge_data[i].source == e.source && edge_data[i].target == e.target) || (edge_data[i].target == e.source && edge_data[i].source == e.target)) {
        matche = 1;
        edge_data[i].weight = edge_data[i].weight + parseInt(e.weight);
      }
    }
    if (matche == 0) {
      edge_data.push({source: e.source, target: e.target, weight: parseInt(e.weight)});

    }

    if (e.source != e.target) {
      totaledgescount = totaledgescount + 1;
    }


});

// Add edges into Graphology object
for (var i = 0; i < edge_data.length; i++) {
  grgraph.addEdge(edge_data[i].source, edge_data[i].target, {weight: edge_data[i].weight});
}
// console.log(sigma.instances(0).graph.edges());

console.log('stats')
console.log(node_data);
console.log(edge_data);
console.log(grgraph);

if (node_data.length > 0 && edge_data.length > 0) {

var community = jLouvain().nodes(node_data).edges(edge_data);
var community_assignment_result = community();
var node_ids = Object.keys(community_assignment_result['communities']);
var com_ass = {};
for (var key in community_assignment_result['communities']) {
    com_ass[nodeIDs_rev[key]] = community_assignment_result['communities'][key];
}
// console.log('Resulting Community Data', community_assignment_result['communities']);
console.log('Resulting Louvain Community Data', com_ass);
console.log('Final Louvain Modularity', community_assignment_result['modularity']);

// Get the graph back from Graphology with community attribute for nodes
var newgraph = louvain_process(grgraph);

// Convert community codes into integers
var louvain_communities = {};
var graphology_communities = [];

grgraph.forEachNode((node, attributes) => {
  var tempo_comm = grgraph.getNodeAttribute(node,'community');
  if (graphology_communities.indexOf(tempo_comm) == -1) {
    graphology_communities.push(tempo_comm);
  }
  louvain_communities[node] = graphology_communities.indexOf(tempo_comm);
});

// Let's calculate modularity
var modularity_score = louvain_modularity(newgraph)

console.log('Graphology modularity score: ');
console.log(modularity_score);
var com_ass2 = {};
for (var key in louvain_communities) {
    com_ass2[nodeIDs_rev[key]] = louvain_communities[key];
}
console.log(com_ass2);
var node_ids = Object.keys(louvain_communities);

var max_community_number = 0;

var top_communities = {};

// We now add the new community integer ID to all the nodes in the Sigma graph

sigma.instances(0).graph.nodes().forEach(function(n) {

  n.community = louvain_communities[n.id];

  var commune = n.community;
  if (!top_communities[commune]) {
    top_communities[commune] = []
  }

  top_communities[commune].push({id: n.id, name: n.originalLabel, degree: sigma.instances(0).graph.degree(n.id), bc: bc_nodes_map[n.id]});

  max_community_number = max_community_number < louvain_communities[n.id] ? louvain_communities[n.id]: max_community_number;

});

console.log('Total communities: ');
console.log(parseInt(max_community_number + 1));


   var topp_communities = {};

   var all_communities = {};

   for (var indd in top_communities) {
    if (!topp_communities[indd]) {
     topp_communities[indd] = {};
     all_communities[indd] = {};
     topp_communities[indd].id = indd;
     all_communities[indd].id = indd;
     topp_communities[indd].length = top_communities[indd].length;
     all_communities[indd].length = top_communities[indd].length;
     topp_communities[indd].nodes = top_communities[indd];
     all_communities[indd].nodes = top_communities[indd];
    }
   }

   topp_communities = _.sortBy(topp_communities,'length').reverse();
   all_communities = _.sortBy(all_communities,'length').reverse();


   var advice_iterations = 4;
   var recommender_iterations = 2;
   if (topp_communities.length < advice_iterations) {
     advice_iterations = topp_communities.length;
   }

   topp_communities = _.first(topp_communities,advice_iterations);

   var toppp_communities = [];

   // Slice first 3 off every topp community

   for (var j = 0; j < topp_communities.length; j++) {
     if (most_influential == 'bc2') {
       topp_communities[j].nodes = _.first(_.sortBy(topp_communities[j].nodes,'bc').reverse(),3);
     }
     else {
       topp_communities[j].nodes = _.first(_.sortBy(topp_communities[j].nodes,'degree').reverse(),3);
     }
   }

   //console.log(topp_communities);

   // Give it to the global
   most_inf_comm_nodes = topp_communities;

   // these are top nodes in each community
   var top_nodes = [];

   // TODO move parsing logic away from this function


   var recommender_start = 'next idea tip: what is the relation between "';
   var recommender = '';
   var analytics = "<div id='searchanalytics'>The following texts contain the nodes <div id='searchterms'></div><br><div class='headline'>" + current_user + "'s Texts:<br></div>";
   analytics += '<div id="similarlist">n/a</div><br>';
   analytics += "<div class='headline'>Others' Public Texts:<br></div>";
   analytics += '<div id="similaroutside">none found</div><br>&nbsp;';
   analytics += '</div>';

   analytics += "<div id='mininganalytics'><div class='headline'>Main Topics</div> (according to Latent Dirichlet Allocation):<br>";
   analytics += "<div id='topicsLDA'></div><br>";
   analytics += "<div class='headline'>Most Influential Words</div> (main topics and words according to LDA):<br>";
   analytics += "<div id='termsLDA'></div><br>";
   analytics += "LDA works only for English-language texts at the moment. More support is coming soon, subscribe  @noduslabs to be informed.<br><br>";
   analytics += "<button id='miningbutton' class='panelControlBtn' data-id='mining_analytics'>LDA Data</button> <button id='analbutton' class='panelControlBtn' data-id='analytics'>Graph Stats</button>";
   analytics += "</div>";


   analytics = analytics + "<div id='mainanalytics'><div class='headline'>Main Topics</div> (communities detected):<br>"
   analytics += "1: "
   for (var j = 0; j < topp_communities.length; j++) {

      for (var n = 0; n < topp_communities[j].nodes.length; n++) {
          if (recommender_iterations != 0) {
            recommender += "<a href='#' class='community_node' community='"+topp_communities[j].id+"'>" + topp_communities[j].nodes[n].name +'</a> - ';
          }
          analytics += "<a href='#' class='community_node' community='"+topp_communities[j].id+"'>" + topp_communities[j].nodes[n].name + "</a> <div class='inlinesquare "+(topp_communities[j].id)+"'></div> ";
          top_nodes.push(topp_communities[j].nodes[n].name);
      }
      if (recommender_iterations != 0) {
        recommender = recommender.slice(0, -3);
        if (j != recommender_iterations) {
        recommender += '"</div> and <br><div class="headline">"';
        }
        recommender_iterations = recommender_iterations - 1;
      }
    //  analytics = analytics.slice(0, -3);
      analytics += " <br>" + (j + 2) + ": ";
   }

   //recommender = recommender.slice(0, -10);
   recommender += ''
   analytics = analytics.slice(0, -7);



   // Get the nodes with the highest degree
   var degree_nodes = [];
   sigma.instances(0).graph.nodes().forEach(function(n)  {
      degree_nodes.push({id: n.id, label: n.label, degree: sigma.instances(0).graph.degree(n.id)});
   });

   //console.log(degree_nodes);
   degree_nodes = _.first(_.sortBy(degree_nodes,'degree').reverse(),9).slice(0,4);



  // console.log(top_nodes);
  //console.log(degree_nodes.slice(0,4));



  // TODO to move parsing logic away from this function

   analytics += "<br><br><div class='headline'>Most Influential Words";


   var toppbc_nodes = topbc_nodes.slice(0,4);

   console.log('Top betweenness centrality nodes:')
   console.log(toppbc_nodes);

   most_inf_nodes = toppbc_nodes;

   // TODO   if (most_influential == 'bc' && toppbc_nodes[0].bc > 0) {


   if ((most_influential == 'bc' || (most_influential == 'bc2') && toppbc_nodes[0].bc > 0)) {
     analytics += '</div> (highest betweenness centrality):<br>';
     for (var ind in toppbc_nodes) {
         if (toppbc_nodes[ind].bc > 0) {

           analytics += '<div class="inlinesquare '+toppbc_nodes[ind].key+'"></div> <a href="#" class="top_nodes">' + toppbc_nodes[ind].label + '</a> &nbsp;';

         }
     }
     analytics = analytics.slice(0, -7);


   }
   else {
     analytics += '</div> (highest degree):<br>';
     for (var ind in degree_nodes) {
         analytics += '<div class="inlinesquare '+degree_nodes[ind].id+'"></div> <a href="#" class="top_nodes">' + degree_nodes[ind].label + '</a> &nbsp;';
     }
     analytics = analytics.slice(0, -7);


   }

   analytics += "<br><br><div class='headline'>Question to Ask:</div> <br>What is the relation between <br><div class='headline'>\"" + recommender + "\"</div>?";

   analytics += "<br><br><div id='graphstats'></div>";

   analytics += "<br><br><button id='resetgraph' class='panelControlBtn'>Reset</button> &nbsp; <button id='miningbutton' class='panelControlBtn' data-id='mining_analytics'>LDA Data</button> &nbsp; <button id='requestbutton' class='panelControlBtn' data-id='request_analytics'>Custom Report</button>";

   analytics += "</div>";

   // Add control buttons

   analytics = '<div id="panelControllers"><ul><li><button id="analbutton" class="panelControlBtn" data-id="analytics">This Text</li><li><button id="searbutton" class="panelControlBtn" data-id="search_analytics">Related Texts</button></li></ul></div>' + analytics;

   var currentPanel = 'analytics';


    // Check analytics display

   if (!localStorage.getItem('analytics') || localStorage.getItem('analytics') == 1) {


      $('#analytics').html(analytics);
      $('#analytics').show();

      $("#analbutton").css('background','#ffffff');
      $("#searbutton").css('background','#ededed');
      $("#miningbutton").css('background','#ededed');
      $("#resetgraph").css('background','#ededed');


        $('.panelControlBtn').on("click", function() {
          var ID = $(this).attr('data-id');
          if (ID == 'search_analytics') {
            $("#mainanalytics").fadeOut('fast', function() {
            $("#mininganalytics").fadeOut('fast');
            $("#searchanalytics").fadeIn('fast');
            $("#analbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ededed');
            $("#searbutton").css('background','#ffffff');

            // Show similar texts following a search query on the Connections pane

            var squery = '';

            if (pinnedNodes.length > 0) {
              for (var i = 0; i < pinnedNodes.length; i++) {
                squery += pinnedNodes[i] + '+';
              }
            }
            else {

              if ((most_influential == 'bc' || most_influential == 'bc2') && toppbc_nodes[0].bc > 0) {
                for (var ind in toppbc_nodes) {
                    if (toppbc_nodes[ind].bc > 0) {
                      squery += toppbc_nodes[ind].label + '+';
                    }
                }
              }
              else {
                for (var ind in degree_nodes) {
                    squery += degree_nodes[ind].label + '+';
                }
              }
            }

            // Formed search query for JSON GET
            squery = squery.slice(0, -1);


            // Add search terms into the Statistics pane
            $("#searchterms").html('<em>' + squery.replace(/\+/g, ' ') + '</em>');

            // Request user's context graphs (texts) which contain either the top nodes or the selected ones
            console.log('<%=perceivername %>'); // public view
            console.log('<%=receivername %>'); // private view
            $.getJSON("/api/" + current_user + "/connectedcontexts/?keywords=" + squery + "&user=" + current_user, function( data ) {
              var items = [];
              $.each( data.slice(0,7), function( key, val ) {
                <% if (perceivername) { %>
                items.push("<a href='/<%= perceivername %>/" + val.name + "?keywords=" + squery + "'>" + val.name + "</a><br>");

                <% } else  { %>
                items.push("<a href='/<%= receivername %>/" + val.name + "/edit?keywords=" + squery + "'>" + val.name + "</a><br>");

                <% } %>
              });

              $("#similarlist").html(items.join(""));

            });

            // Request user's context graphs (texts) which contain either the top nodes or the selected ones
            $.getJSON("/api/connectedcontexts/?keywords=" + squery, function( data ) {
              var items = [];
              $.each( data.slice(0,7), function( key, val ) {
                items.push("<a href='/" + val[1] + "/" + val[0].name + "?keywords=" + squery + "'>" + val[0].name + "</a><br>");
              });

              $("#similaroutside").html(items.join(""));

            });

            });
            currentPanel = ID;
          }
          else if (ID == 'analytics') {
            $("#searchanalytics").fadeOut('fast', function() {
            $("#mininganalytics").fadeOut('fast');
            $("#mainanalytics").fadeIn('fast');
            $("#analbutton").css('background','#ffffff');
            $("#searbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ededed');
            });
            currentPanel = ID;
          }
          else if (ID == 'mining_analytics') {

            $("#searchanalytics").fadeOut('fast', function() {
            $("#mainanalytics").fadeOut('fast');
            $("#mininganalytics").fadeIn('fast');
            $("#analbutton").css('background','#ededed');
            $("#searbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ffffff');

            var html = "n/a";

            $.getJSON("/api/" + current_user + "/lda/topics/" + current_context, function( data ) {
              var items = [];
              html = '';
              for (var i = 0; i < data.length; i++) {

                for (var j = 0; j < data[i].length; j++) {
                  //console.log(nodeIDs[data[i][j].term]);
                  items.push('<div class="inlinesquare ' + louvain_communities[nodeIDs[data[i][j].term]] + '"></div> <a href="#" class="top_nodes">' + data[i][j].term + '</a> &nbsp;');
                  if (j == (data[i].length - 1)) {
                    items.push('<br>')
                  }
                }


              }


              $("#topicsLDA").html(items.join(""));

              $.getJSON("/api/" + current_user + "/lda/terms/" + current_context, function( data ) {
                var items = [];
                html = '';
                for (var i = 0; i < data.length; i++) {

                  for (var j = 0; j < data[i].length; j++) {
                    //console.log(nodeIDs[data[i][j].term]);
                    items.push('<div class="inlinesquare ' + louvain_communities[nodeIDs[data[i][j].term]] + '"></div> <a href="#" class="top_nodes">' + data[i][j].term + '</a> &nbsp;');
                    if (j == (data[i].length - 1)) {
                      items.push('<br>')
                    }
                  }


                }


                $("#termsLDA").html(items.join(""));

                for (pall in palette) {
                      if (document.getElementsByClassName("inlinesquare " + pall)) {
                        for (var i = 0; i < document.getElementsByClassName("inlinesquare " + pall).length; i++) {

                          document.getElementsByClassName("inlinesquare " + pall)[i].style.backgroundColor=rgbToHex(palette[pall]._rgb[0],palette[pall]._rgb[1],palette[pall]._rgb[2]);
                        }
                      }
                }
                top_nodes_activate();




              });






            });



            });
            currentPanel = ID;
          }

          else if (ID == 'request_analytics'){
            window.open('https://noduslabs.com/services/connections/', '_blank');
          }


        });


      //localStorage.setItem('analytics', 1);
      $('#analyticsbutton').addClass('analytics-on');
      $('#analyticscaption').hide();
   }

   else {
     $('#analytics').html(analytics);
     $('#analytics').hide();
     $('#analyticsbutton').removeClass('analytics-on');
     $('#analyticscaption').show();
     $("#miningbutton").css('background','#ededed');

   }

   if ((hide_always || hide_edit || hide_when_small) && !show_analytics) {
     $('#analytics').hide();
     $('#analyticsbutton').removeClass('analytics-on');
     $('#analyticscaption').show();
   }

   //console.log(localStorage.getItem('analytics'));

   var recommender_tip = $(recommender).text();

   $("#statement").attr("placeholder", recommender_start + recommender_tip + "?").blur().focus();




// nice color palette
if (graphPalette == 'color') {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 60, lightMax: 75, chromaMin: 2, chromaMax: 15});
}
else if (graphPalette == 'mono') {
// subdued chromo
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 40, lightMax: 60, chromaMin: 2, chromaMax: 8});
//
}
else if (graphPalette == 'contrast') {
// subdued chromo
  if (background == 'dark') {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 75, lightMax: 95, chromaMin: 1, chromaMax: 8});
  }
  else {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 40, lightMax: 60, chromaMin: 1, chromaMax: 2});
  }
//
}
// good chromo
else {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 70, chromaMin: 60, samples: 100});
}

var s_x = 0;
var s_y = 0;
var e_x = 0;
var e_y = 0;

//console.log(palette);
//  console.log(sigma.instances(0).graph.nodes()[54]);


for (pall in palette) {
    if (document.getElementsByClassName("inlinesquare " + pall)) {
      for (var i = 0; i < document.getElementsByClassName("inlinesquare " + pall).length; i++) {
        document.getElementsByClassName("inlinesquare " + pall)[i].style.backgroundColor=rgbToHex(palette[pall]._rgb[0],palette[pall]._rgb[1],palette[pall]._rgb[2]);
      }
    }
}

var totalnodescount = 0;
var addcontextcount = 0;
var nodesfirstcom = 0;
var nodessecondcom = 0;

var diversityindex = 0;

var diversity = '';

var addcontext_nodes = [];


sigma.instances(0).graph.nodes().forEach(function(n) {
  if (top_nodes.indexOf(n.originalLabel) != -1) {

  }

  community_of_node[n.originalLabel] = n.community;

  n.originalColor = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);

  if (pinnedNodes.indexOf(n.originalLabel) < 0) {

        if (selectedNodes.length > 0){
          if (selectedNodes.indexOf(n.originalLabel) > -1) {
            n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
          }
          else if (coming_from == 'node add' && n.originalLabel == node_origin) {
            n.color = deselected_nodes_color;
          }
          else if (!nodeIDs[n.originalLabel]) {
            n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
          }
        }
        else {
          n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
        }

  }

  if (!nodeIDs[n.originalLabel]) {
    nodeIDs[n.originalLabel] == n.id;
  }

  if (n.community == topp_communities[0].id) {
  //  console.log(n.originalLabel + ' ' + n.x);
  // TODO here we can calculate modularity
      s_x += n.x;
      s_y += n.y;
    //  console.log(s_x)
    nodesfirstcom = nodesfirstcom + 1;
  }
  if (topp_communities[1]) {
  if (n.community == topp_communities[1].id) {
    e_x += n.x;
    e_y += n.y;

    nodessecondcom = nodessecondcom + 1;
  }
  }

  totalnodescount = totalnodescount + 1;

  if (document.getElementsByClassName("inlinesquare " + n.id)[0] != undefined) {
        document.getElementsByClassName("inlinesquare " + n.id)[0].style.backgroundColor=rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
  }

  // Check if the node is in additional context and if yes, give it a different color

  if (contextNodeID[addcontext] && contextNodeID[current_context]) {
        if (interpret) {
          if (contextNodeID[current_context].indexOf(n.id) > -1) {

              if (!highlight) {
                n.originalColor = '#90909f';

                if (pinnedNodes.indexOf(n.label) == -1) {
                  if (selectedNodes.length > 0){
                    if (selectedNodes.indexOf(n.originalLabel) > -1) {
                    }
                  }
                  else {
                  n.color = '#90909f';
                  }
                }
              }
          }
          else {
            // This shows intersecting nodes
            if (highlight) {
              n.originalColor = highlight_addcontext;

              if (pinnedNodes.indexOf(n.label) == -1) {
                if (selectedNodes.length > 0){
                  if (selectedNodes.indexOf(n.originalLabel) > -1) {
                  }
                }
                else {
                n.color = highlight_addcontext;
                }
              }
            }
          }
          if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) == -1) {
              addcontextcount = addcontextcount + 1;
              addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});
          }
        }
        else {
          if (!missing) {
            if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) == -1) {
                if (highlight) {
                  n.originalColor = highlight_addcontext;
                  n.color = highlight_addcontext;
                }
                else {
                  n.originalColor = color_addcontext;
                  n.color = color_addcontext;
                }
                addcontextcount = addcontextcount + 1;
                addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});
            }
          }
          else {
            if (contextNodeID[addcontext].indexOf(n.id) == -1 && contextNodeID[current_context].indexOf(n.id) > -1) {
                if (highlight) {
                  n.originalColor = highlight_addcontext;
                  n.color = highlight_addcontext;
                }
                else {
                  n.originalColor = color_addcontext;
                  n.color = color_addcontext;
                }
                addcontextcount = addcontextcount + 1;
                addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});

            }
          }
        }

  }


});

// console.log(nodesfirstcom);
// console.log(nodessecondcom);
// console.log(totalnodescount);

global_totalnodes = totalnodescount;

console.log('Top communities:')
console.log(topp_communities);

addcontext_nodes = _.sortBy(addcontext_nodes, 'size').reverse();

diversityindex = ((((nodesfirstcom) / totalnodescount).toFixed(2))*100).toFixed(0);


var graph_density;
if ((totalnodescount - 1) == 0 || totalnodescount == 0) { graph_density = 0 } else {
graph_density  = ((totaledgescount) / ((totalnodescount)*(totalnodescount - 1))).toFixed(3);
}



var diversitytext = '<div class="headline">Stats:</div> total ' + totalnodescount + ' words, graph density ' + graph_density + ', ';

diversitytext += 'average degree: ' + (totaledgescount / totalnodescount).toFixed(2);

var diversity_score = 0;

// TODO add degree distribution to the indexOf maybe through entropy of degree by nodes

var bc_dist = [];

// For every top BC node
console.log("All the different communities in the graph:")
console.log(all_communities);


for (var bcid in toppbc_nodes) {
 if (toppbc_nodes[bcid].bc > 0) {

 for (var comid in all_communities) {
    // Open first community

        //  For every node in that community

            for (var ccnodes in all_communities[comid].nodes) {

                // If the node's ID equals to the current BC node, add the marker
                if (all_communities[comid].nodes[ccnodes].id == toppbc_nodes[bcid].key) {
                  bc_dist.push(all_communities[comid].id);
                }

            }
 }
 }

}

console.log('Distribution of top nodes across all the communities: ')
console.log(bc_dist);

var bc_dist_string = bc_dist.join('');

// Max entropy for a set of 4 elements is 2

var bc_entropy = shannon(bc_dist_string);

// TODO fix bug for two-digit communities

console.log('BC Entropy: ' + bc_entropy);

var most_num_comm = [];

top_components = _.sortBy(top_components, 'length').reverse();

var num_nodes_component = ((top_components[0].nodes().length / totalnodescount).toFixed(2)*100).toFixed(0);

if ((modularity_score > 0.65 && diversityindex < 50) && ((bc_entropy >= 1.5) || (bc_entropy == 0 && toppbc_nodes[0].bc == 0) || (bc_entropy == 0 && num_nodes_component < 40))) {
  diversity_score = 'Dispersed';
  document.getElementById("biasRange").value = "100";
  $('#biasRange').attr('class', 'slider dispersedslider');
}
else if ((modularity_score > 0.4 && diversityindex < 50) && ((bc_entropy >= 1.5) || (bc_entropy == 0 && toppbc_nodes[0].bc == 0) || (bc_entropy == 0 && num_nodes_component < 40))) {
  diversity_score = 'Diversified';
  document.getElementById("biasRange").value = "67";
  $('#biasRange').attr('class', 'slider diversedslider');
}
else if ((modularity_score < 0.4 && modularity_score > 0.2 && bc_entropy >= 0.5) || ((modularity_score > 0.4 && diversityindex >= 50)  && bc_entropy >= 0.5) || (modularity_score > 0.4 && diversityindex < 50 && bc_entropy > 0.5)) {
  diversity_score = 'Focused';
  document.getElementById("biasRange").value = "33";
  $('#biasRange').attr('class', 'slider focusedslider');
}
else {
  diversity_score = 'Biased';
  document.getElementById("biasRange").value = "1";
  $('#biasRange').attr('class', 'slider biasedslider');
}
// Set global parameter
polysingularity_score = diversity_score;


diversitytext +=  ' <br><div class="headline">Discourse structure: <i>' + diversity_score + '</i> &nbsp;&nbsp;[<a href="https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/" target="_blank">?</a>]</div><br>';
diversitytext += modularity_score.toFixed(2) + ' modularity, ';
diversitytext +=  diversityindex + '% of words in the top topic ';

diversitytext += '(total ' + all_communities.length + ' topics), ';

    if (addcontextcount > 0) {


      if (addcontext_nodes.length > 0) {
        var addcontext_text = '<div class="headline">In ' + addcontext + ' but not in ' + current_context + ':</div> ';
        if (addcontext_nodes.length > 4) {
          addcontext_nodes = addcontext_nodes.slice(0, 4);
        }
        for (var nnn = 0; nnn < addcontext_nodes.length; nnn++) {
          addcontext_text += '<a href="#" class="top_nodes">' + addcontext_nodes[nnn].label + '</a> - ';
        }
        addcontext_text = addcontext_text.slice(0, -3);
        addcontext_text += '<br><br>'
        diversitytext = addcontext_text + diversitytext;
      }
      var addindex = ((((totalnodescount - addcontextcount) / totalnodescount).toFixed(2))*100).toFixed(0);
      diversitytext += 'context ' + addcontext + ' uses ' + addindex + '% words from ' + current_context + ', ';
    }



diversitytext += num_nodes_component + '% in the main connected component '


diversitytext += '(' + top_components.length + ' in total), ';

diversitytext += 'influence dispersal ' + ((bc_entropy/2).toFixed(1)*100).toFixed(0) + '%';


$('#graphstats').html(diversitytext);

//sigma.instances(0).refresh;


//console.log(top_communities);
//console.log(sigma.instances(0).graph.nodes());
}





var commClicked = [];

  top_nodes_activate();

  $('#resetgraph').click(function(){
    sigma.instances(0).graph.nodes().forEach(function(n) {
            n.color = n.originalColor;
            n.label = n.originalLabel;
    });
    pinnedNodes = [];
    commClicked = [];

    $('.community_node').each(function(){
      $(this).removeAttr('style');
    });

    $('.top_nodes').each(function(){
      $(this).removeAttr('style');
    });

    filter_statements(pinnedNodes);
    sigma.instances(0).refresh();
  });




function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}



// communityDetect function ends here
}

function top_nodes_activate() {
      $('.top_nodes').click(function(){
        var nodeLabel = $(this).text();


        if (pinnedNodes.indexOf(nodeLabel) < 0) {
            pinnedNodes.push(nodeLabel);
            $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
        }
        else {
            var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
            if (pinnedIndex > -1) {
                pinnedNodes.splice(pinnedIndex,1);
                $(this).removeAttr('style');
                $('.entry').fadeIn(400);
            }

        }

        // console.log("node clicked, now will filter for nodes " + pinnedNodes);
        socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


        // Now show / hide statements that have the search field

        filter_statements(pinnedNodes);
        return false;

      });
      var commClicked = [];
      $('.community_node').click(function(){
            var communityClicked = $(this).attr('community').toString();

            var nodeLabel = $(this).text();

            if (pinnedNodes.indexOf(nodeLabel) < 0) {
                pinnedNodes.push(nodeLabel);
                $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
            }
            else {
                var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                if (pinnedIndex > -1) {
                    pinnedNodes.splice(pinnedIndex,1);
                    $(this).removeAttr('style');
                    $('.entry').fadeIn(400);
                }

            }




          //  socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});
            // console.log(pinnedNodes);
            filter_statements(pinnedNodes, 'community');



            if (commClicked.indexOf(communityClicked) == -1) {
                // console.log("the community clicked was not clicked before");


                // sigma.instances(0).graph.edges().forEach(function(e) {
                //
                //     if (e.statement_id == keepStatementID) {
                //         e.color = e.originalColor;
                //     }
                //     else {
                //         e.color = '#ddd';
                //     }
                //
                // });

                // Specify which community is clicked
                commClicked.push(communityClicked);


                // Make only those nodes visible that belong to the community selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    if (commClicked.indexOf(n.community.toString()) > -1)  {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                        if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                          n.color = '#0089e0';
                        }
                    }
                    else {
                      n.color = deselected_nodes_color;
                      n.label = '';
                    }

                });
            }

            else {
              // console.log("the community was clicked before");

                if (pinnedNodes.length == 0) {
                    // sigma.instances(0).graph.edges().forEach(function(e) {
                    //     e.color = e.originalColor;
                    // });

                    commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);

                    // Make only those nodes visible that belong to the statement selected
                    sigma.instances(0).graph.nodes().forEach(function(n) {
                      if (commClicked.indexOf(n.community.toString()) < 0) {
                              if (commClicked.length == 0) {
                                n.color = n.originalColor;
                                n.label = n.originalLabel;
                              }
                              else {
                                n.color = deselected_nodes_color;
                                n.label = '';
                              }
                      }
                    });


                  }
                else {
                    // We clicked on the community which is in the DB of clicked ones and We have some pinned nodes left

                      // Is the node clicked in the pinned nodes?
                      if (pinnedNodes.indexOf(nodeLabel) > -1) {
                        // console.log('in the pinned nodes')
                        sigma.instances(0).graph.nodes().forEach(function(n) {
                          if (commClicked.indexOf(n.community.toString()) > -1)  {
                              n.color = n.originalColor;
                              n.label = n.originalLabel;
                              if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                                n.color = '#0089e0';
                              }
                          }
                          else {
                            n.color = deselected_nodes_color;
                            n.label = '';
                          }
                      });
                    }
                    // It is not in the pinneed nodes
                    else {
                      // console.log('not in the pinneed nodes')
                      // console.log(commClicked)
                      // console.log(pinnedNodes);

                      // is the last node of the community?
                      var islastnode = 0;
                      for (key in topp_communities) {
                        if (communityClicked == topp_communities[key].id) {
                          for (kkey in topp_communities[key].nodes) {
                            // console.log(topp_communities[key].nodes[kkey].name);
                            // console.log(pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name));
                            if (pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name) > -1) {
                              islastnode = 1;
                            }

                          }
                        }
                      }
                      // console.log(islastnode);

                      if (!islastnode) {
                        commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);
                      }
                      //console.log(pinnedNodes);

                      sigma.instances(0).graph.nodes().forEach(function(n) {
                        if (commClicked.indexOf(n.community.toString()) < 0) {
                                if (commClicked.length == 0) {
                                  n.color = n.originalColor;
                                  n.label = n.originalLabel;
                                }
                                else {
                                  n.color = deselected_nodes_color;
                                  n.label = '';
                                }

                        }

                        if (pinnedNodes.indexOf(n.originalLabel) > -1) {
                          n.color = '#0089e0';
                          n.label = n.originalLabel;
                        }
                        if (pinnedNodes.indexOf(n.originalLabel) < 0 && islastnode && n.originalLabel == nodeLabel) {
                          n.color = n.originalColor;
                          n.label = n.originalLabel;
                        }


                      });

                    }
                }

            }

            sigma.instances(0).refresh();

      });

    }


function sigmaGraph() {
    return {
        adjustLayout: function() {
            if (sigma.instances(0).isForceAtlas2Running()) {
                    sigma.instances(0).stopForceAtlas2();
                    sigma.instances(0).killForceAtlas2();
                    $('#improve-layout').removeClass('layout-on');
                    forcedatlas_running = false;
            }
            else {
                  // sigma.configForceAtlas2({scalingRatio: 0.1});
                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  $('#improve-layout').addClass('layout-on');
                  forcedatlas_running = true;
            }
        },
        abstractLayout: function() {

            // What happens when we want to stop showing node labels and make the graph more Abstract
            console.log('abstractLayout')
             if (!$('#abstract-layout').hasClass('abstract-on')) {
                console.log('doesnt hav abstract layout');
                var url = window.location.href;
                url = removeParam("abstract", url);
                if (url.indexOf('?') > -1){
                    url += '&abstract=yes'
                }else{
                    url += '?abstract=yes'
                }
                window.location.href = url;

            }
            else {
                console.log(' hav abstract layout');
                var url = window.location.href;
                var alteredURL = removeParam("abstract", url);

                if (alteredURL.indexOf('?') > -1){
                    alteredURL += '&abstract=no'
                }else{
                    alteredURL += '?abstract=no'
                }
                window.location.href = alteredURL;
            }



        }
    }
}




</script>