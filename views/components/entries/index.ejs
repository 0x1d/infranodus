<script>


// Initialize Socket.IO for websockets (using them for collabs but also to listen to events within the app )
var socket = io();

var hide_always = getUrlVars()["hide_always"];

var hide_edit = getUrlVars()["hide_edit"];

var show_text = getUrlVars()["show_text"];

var show_analytics = getUrlVars()["analytics"];

var hide_when_small = getUrlVars()["hide_when_small"];

var language = getUrlVars()["language"];

var graphPalette = getUrlVars()["palette"];

var interpret = getUrlVars()["interpret"];


var urlPath = location.pathname;

var background = getUrlVars()["background"];

if (!background) {
    background = '<%= user.background %>';
}


var walkthrough = getUrlVars()["walkthrough"];


// Let's define some walkthrough tutorials, depending on the situation
var walkthroughtype = 'default';

<% if (perceivername) { %>
    walkthroughtype = 'external';
<% } %>

// Some settings from routes/entries.js

<% if (locals.user && !locals.vieweduser) { %>
var inlanguage = '<%= user.inlanguage %>';

    <% if (locals.user.label_threshold) { %>
    in_label_threshold = '<%= user.label_threshold %>';
    <% } %>

    <% if (locals.user.midi) { %>
    midi = '<%= user.midi %>';
    <% } %>

    if (!graphPalette) {
    graphPalette = '<%= user.palette %>';
    }

    <% if (locals.user.customization) { %>
    customization = '<%= user.customization %>';
    <% } %>

    <% if (locals.user.maxnodes) { %>
    maxnodes = '<%= user.maxnodes %>';
    <% } %>


<% } else { %>

  <% if (locals.vieweduser) { %>

    most_influential = '<%= vieweduser.topnodes %>';

    in_label_threshold = '<%= vieweduser.label_threshold %>';

    if (!graphPalette) {
        graphPalette = '<%= vieweduser.palette %>';
    }

    if (!background) {
        background = '<%= vieweduser.background %>';
    }

  <% } %>

<% } %>


// Socket.IO chat collaborate

// This matrix relates each URL path to each unique chat that can happen within that room

var collaborate_matrix = {};

var collaborate_room = urlPath + '/';

var collaborate_id = '';

var collaborate_content = '';

var collaborate_message = '';

var collaborate_html = '';

var collaborate_storage = JSON.parse(localStorage.getItem("collaborate"));


var color_context = '#666';

var forcedatlas_running = false;


// Create node ID - Name index for filtering
var nodeIDs = {};

var nodeIDs_rev = {};

// Initial graph model saved
var nodesDB = [];
var edgesDB = [];

// Create context-node index for filtering
var contextNodeID = [];

// Create statement-node index for filtering
var nodesOfStatement = [];


 // Collaboration features realized using Socket.IO
    // On connection to server get the id of the current chat "room", which is actually the folder/URL of the current user

    socket.on('connect', function(){
        console.log('connected');
        socket.emit('login', {user: current_user, context: current_context, id: collaborate_matrix[collaborate_room]});
    });

     // When we click reset button

 socket.on('graph reset', function(msg){
     

     pinnedNodes = [];
     splicedNodes = [];
     notfoundNodes = [];
     
     $('.entry').fadeIn(400);
     
     // Filter statements and select nodes on the graph
     filter_statements(pinnedNodes);
     
     });


// This is called when an entry is deleted

socket.on('delete message', function(msg){

    $('[data-uid="' + msg.entryuid + '"]').fadeOut();

    $("#statement").val('');

    // When searched for nodes in that statement, nothing will appear.

    nodesOfStatement[msg.entryuid] = [];

    // Let's set up which nodes we will keep
    var nodesToKeep = [];

    sigma.instances(0).graph.edges().forEach(function(e) {

            // If a node appears in at least one statement, we add him in ToKeep list
        for (let item of e.statement_id) {
            if (nodesOfStatement[item].indexOf(e.source) > -1) {
                nodesToKeep.push(e.source);
            }

            if (nodesOfStatement[item].indexOf(e.target) > -1) {
                nodesToKeep.push(e.target);
            }

            var statePosition = statementsOfContext[e.edge_context].indexOf(item);
            if (statePosition < 0) {
                statementsOfContext[e.edge_context].splice(statePosition, 1);
            }

            if (item == msg.entryuid) {
                sigma.instances(0).graph.dropEdge(e.id);
            }
            
        }

    });


    sigma.instances(0).graph.nodes().forEach(function(n) {
        if (nodesToKeep.indexOf(n.id) < 0) {
            sigma.instances(0).graph.dropNode(n.id);
        }

    });

 

    // Refresh the object and reload the layout

    sigma.instances(0).refresh();

    sigma.instances(0).startForceAtlas2(forceatlas_options);

    // Don't run it forever not to overheat :)

    setTimeout(function() {

        sigma.instances(0).stopForceAtlas2();
        sigma.instances(0).killForceAtlas2();

    }, 3000);

    //console.log(newnodes);
    // console.log(msg.graph.edges);
    // console.log(sigma.graph.edges());


});

// Autofill initialized only after Sigma above loaded and populated all the nodes

function autofill(nodeNames,contextNames) {

    // console.log(nodeNames);

    $('#statement').textcomplete([
        { // hashtags-concepts
            words: nodeNames,
            match: /\B#(\w*)$/,
            search: function (term, callback) {
                callback($.map(this.words, function (word) {
                    return word.indexOf(term) === 0 ? word : null;
                }));
            },
            index: 1,
            replace: function (word) {

                return '#' + word + ' ';

            }
        },
        { // html
            mentions: contextNames,
            match: /\B@(\w*)$/,
            search: function (term, callback) {
                callback($.map(this.mentions, function (mention) {
                    return mention.indexOf(term) === 0 ? mention : null;
                }));
            },
            index: 1,
            replace: function (mention) {
                return '@' + mention + ' ';
            }
        },
        { // hashtags-concepts
            words: nodeNames,
            match: /\b(\w{2,})$/,
            search: function (term, callback) {
                callback($.map(this.words, function (word) {
                    return word.indexOf(term) === 0 ? word : null;
                }));
            },
            index: 1,
            replace: function (word) {

                    return word + ' ';

            }
        }

    ]);





    $('#addcontext').textcomplete([
        { // html
            mentions: contextNames,
            match: /\b(\w{2,})$/,
            search: function (term, callback) {
                callback($.map(this.mentions, function (mention) {
                    return mention.indexOf(term) === 0 ? mention : null;
                }));
            },
            index: 1,
            replace: function (mention) {
                window.open("?addcontext=" + mention, "_self");
                return '@' + mention + '';
            }
        }
    ]);
}

function shannon(data) {

    // Create a dictionary of character frequencies and iterate over it.
    function process(s, evaluator) {
    var h = Object.create(null), k;
    s.split('').forEach(function(c) {
        h[c] && h[c]++ || (h[c] = 1); });
    if (evaluator) for (k in h) evaluator(k, h[k]);
    return h;
    };

    // Measure the entropy of a string in bits per symbol.

    // Measure the entropy of a string in total bits.
    function bits (s) {
    return entropy(s) * s.length;
    }


    var sum = 0,len = data.length;
    process(data, function(k, f) {
    var p = f/len;
    sum -= p * Math.log(p) / Math.log(2);
    });

    return sum;

}


    // Download PNG (the graph isn't modified)
    function downloadPNG() {
      var canvaspng = document.querySelector('.sigma-scene');

      document.querySelector('#downloadpng').href = canvaspng.toDataURL();
      document.querySelector('#downloadpng').download = current_user + '_' + current_context + '.png';

      document.querySelector('#downloadpng').addEventListener('click', function(ev) {
        document.querySelector('#downloadpng').href = canvaspng.toDataURL();
        document.querySelector('#downloadpng').download = current_user + '_' + current_context + '.png';
      }, false);

    }

</script>