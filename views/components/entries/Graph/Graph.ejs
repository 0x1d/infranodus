<script>

  var jsonpath = '';

  var maxnodes = '';

  // Get the setting from user DB how many max nodes we show
  <% if (maxnodes) { %>
    maxnodes = <%= maxnodes %>;
  <% } %>


  // Path to the JSON graph file (specific context or a general one)
  <% if (addcontext) { %>
      jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
      addcontext = "<%= addcontext %>";

  <% } else if (showcontexts) { %>
      jsonpath = '/api/user/nodes/<%= context %>?showcontexts=<%= showcontexts %>';
      addcontext = "";

  <% } else if (maxnodes) { %>
      jsonpath = '/api/user/nodes/<%= context %>?maxnodes=<%= maxnodes %>';
      maxnodes = '<%= maxnodes %>';
      addcontext = "";

  <% } else { %>
      jsonpath = '/api/user/nodes/<%= context %>';
      addcontext = "";
  <% }  %>

  // Is the user going to look at somebody else's graph?

  <% if (perceivername) { %>
      <% if (showcontexts && maxnodes) { %>
          jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>&maxnodes=<%= maxnodes %>';
      <% } else if (showcontexts) { %>
          jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>';
      <% } else if (maxnodes) { %>
          jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= maxnodes %>';
      <% } else  { %>
          <% if (locals.vieweduser && vieweduser.maxnodes) { %>
              maxnodes = '<%= vieweduser.maxnodes %>';
              jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= vieweduser.maxnodes %>';
          <% } else { %>
              jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>';
          <% } %>
  <% } %>
  <% } %>


  // Do we show abstract graph and no nodes?

  <% if (locals.user && locals.user.abstract != undefined) { %>
          abstract = '<%=locals.user.abstract%>';
  <% } %>

  if (getUrlVars()["abstract"]) {
        abstract = getUrlVars()["abstract"];
  }



  // default label threshold
  var in_label_threshold = 8;

  var default_label_color = '#000000';

  if (background == 'dark') {
    default_label_color = '#ffffff';
  }

  var minnodesize = 5;
  var maxnodesize = 16;

  if (abstract && abstract != 'no') {
      minnodesize = 1;
      maxnodesize = 1;
      in_label_threshold = 20;
  }



  // Sigma graph layout options
  var forceatlas_options = {worker: false, startingIterations: 100, scalingRatio: 0.1, slowDown: 100, strongGravityMode: true};




  // What are the concepts present in the graph?
  var statementsOfContext = [];

  // Cytoscape object

  var elesnodes = [];

  // Add Cytoscape Library - to calculate betweenness centrality for nodes and other stuff

  var cy = cytoscape({
      container: undefined,
      headless: true
  });

  var eles;
 

  var community_of_node = [];


  var sigma_dragged = 0;


  // Initialize JSON parser for SIGMA visualization

  var color_addcontext = '#666666'; // #cccccc

  var highlight_addcontext = '#0089e0';

  var highlight = getUrlVars()["highlight"];

  var missing = getUrlVars()["missing"];


  // These are the nodes clicked in the graph

  var global_totalnodes = 0;


  // This variable shows if there was a meaningful interaction with the graph yet

  var graphInteraction = null;


  // This may be a deprecated setting

  // Inactivity timeout
  var inactiveTimeout = null;


</script>

<%- include('GraphGenerate') %>
<%- include('GraphUpdate') %>
<%- include('GraphRank') %>
<%- include('GraphModularity') %>
<%- include('../Analytics/AnalyticsPaneLogic') %>

<script>


function graph() {
    return {
        deleteNodes: function(nodesToDelete, callback){
           
            // Delete the nodes from the Sigma graph (the edges will get deleted automatically)
            sigma.instances(0).graph.nodes().forEach(function(n) {
                if (nodesToDelete.indexOf(n.originalLabel) >= 0) {
                    sigma.instances(0).graph.dropNode(n.id);
                }               
            });
            
            callback();

        },
        addDeletedNodes: function(nodesToAdd, callback){
                   
            let nodeIDs = graphFactory.getNodeIDs();
            let nodeIDs_rev = graphFactory.getNodeIDsRev();
            
            let cyclefinished = 0;
            let edgeproc;

            let edgesDB = graphFactory.getEdges();

            let stoplistNodes = graphFactory.getStopNodes();
            
            // First, let's add nodes into the Sigma graph
      
            for (let node in nodesToAdd) {
              let n = {};
              n.label = nodesToAdd[node];
              n.id = graphFactory.getNodeID(nodesToAdd[node]);
              this.addNode(n);
            }

            // Now, let's see if this node already had any edges from that graph before
            
            for (let addingNodes in nodesToAdd) {

              for (var i = 0; i < edgesDB.length; i++ ) {
                  if (edgesDB[i].source == nodeIDs[nodesToAdd[addingNodes]] || edgesDB[i].target == nodeIDs[nodesToAdd[addingNodes]]) {
                      edgeproc = edgesDB[i];
                      // Do we have any stopwords?
                      if (stoplistNodes.length > 0) {
                          // Do connections only if target/source is not in the remaining stoplistNodes
                          if (stoplistNodes.indexOf(nodeIDs_rev[edgeproc.source]) < 0 && stoplistNodes.indexOf(nodeIDs_rev[edgeproc.target]) < 0) {
                                  this.addEdge(edgeproc);
                          }
                      }
                      else {
                        this.addEdge(edgeproc);
                      }

                    }
                }
                
              }

            sigma.instances(0).refresh();
            
            // After the nodes and edges are added, call the graphMetrics
            callback();

        },
        addNodesEdges: function(nodesToAdd, edgesToAdd, callback) {
          for (let node in nodesToAdd) {
              this.addNode(nodesToAdd[node]);
          }
          
          for (let edge in edgesToAdd) {

              let e = edgesToAdd[edge];

              this.addEdge(edgesToAdd[edge]);

              this.updateEdgeStats(e);

                  
          }

          callback();

        },
        initNodesEdges: function(callback) {
            
            let tot = 0;
            let color_context = '#666';
            let total_nodes = sigma.instances(0).graph.nodes().length;
            let maxnodesize = 0;


            // Now we get the context IDs from the graph - a little bit of a workaround
            let suspects = [];
            let nonsuspects = [];

            let nodeIDs_rev = graphFactory.getNodeIDsRev();

            let edgesList = [];

            sigma.instances(0).graph.edges().forEach(function(e) {

                // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                if (e.id.substr(0,7) == 'context') {
                        if (suspects.indexOf(e.source) < 0) {
                            suspects.push(e.source);
                        }

                        if (suspects.indexOf(e.target) < 0) {
                            suspects.push(e.target);
                        }

                }

                // If an edge doesn't have prefix context, for sure it has only nodes
                else {
                        if (nonsuspects.indexOf(e.source) < 0) {
                            nonsuspects.push(e.source);
                        }

                        if (nonsuspects.indexOf(e.target) < 0) {
                            nonsuspects.push(e.target);
                        }
                }

                e.sourcename = nodeIDs_rev[e.source];
                e.targetname = nodeIDs_rev[e.target];

                graph().updateEdgeStats(e);

              });


            // Find the difference between two arrays above, so we get contexts only
            let contextids = _.difference(suspects, nonsuspects);

            let contexts_length = contextids.length;


            // Now show those nodes that are contexts bigger and with a special label
              
            sigma.instances(0).graph.nodes().forEach(function(nodes) {
                var nodesize = 0;
                var angle = Math.PI * 2 * tot / total_nodes;
                nodes.x = Math.cos(angle);
                nodes.y = Math.sin(angle);
                nodes.size = sigma.instances(0).graph.degree(nodes.id);
                nodesize = nodes.size;
                if (maxnodesize < nodesize) maxnodesize = nodesize;
                nodes.color = color_context;
                
                // Save for backup
                nodes.originalColor = color_context;
                nodes.originalLabel = nodes.label;

                // Creating an index of node labels to IDs for filtering
                graphFactory.addNode(nodes.label, nodes.id, nodes);

                tot = tot + 1;
                
                if (contexts_length > 0) {
                  if (contextids.indexOf(nodes.id) > -1) {
                      nodes.size = maxnodesize;
                      nodes.originalLabel = 'context: ' + nodes.originalLabel;
                      nodes.label = 'context: ' + nodes.label;
                  }
                }
               
            });

            // Select previously selected nodes on the graph (from LocalStorage) or passed through parameters

            graphFactory.getSelections();

            // Launch the metrics calculation
            callback();   

        },
        updateEdgeStats: function(e) {

              // Make a new index of nodes to statement
              for (let item of e.statement_id) {
                    
                    if (graphFactory.existNodesOfStatement(item) == true) {
                        if (graphFactory.existNodeInStatement(item, e.source) == false)
                            graphFactory.addNodeToStatement(item, e.source);
                        if (graphFactory.existNodeInStatement(item, e.target) == false)
                            graphFactory.addNodeToStatement(item, e.target);
                    }
                    else {
                        graphFactory.addNodeToStatement(item, e.source);
                        // avoid duplicates
                        if (e.source != e.target) {
                          graphFactory.addNodeToStatement(item, e.target);
                        }
                        
                    }
              }
      
              // Which statements belong to which context / graph
              if (statementsOfContext[e.edge_context]) {
                    for (let item of e.statement_id) {
                      if (statementsOfContext[e.edge_context].indexOf(item) < 0) statementsOfContext[e.edge_context].push(item);
                    }
              }
              else {
                  statementsOfContext[e.edge_context] = [];
                  for (let item of e.statement_id) {
                    statementsOfContext[e.edge_context].push(item);
                  }
              }


              // Make an index of nodes to context
              if (contextNodeID[e.edge_context]) {
                  if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                      contextNodeID[e.edge_context].push(e.source);
                  if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                      contextNodeID[e.edge_context].push(e.target);
              }
              else {
                  contextNodeID[e.edge_context] = [];
                  contextNodeID[e.edge_context].push(e.source);
                  contextNodeID[e.edge_context].push(e.target);
              }


               // Add to EDGES db
               graphFactory.addEdge(e);

        },
        addNode: function(node) {
          sigma.instances(0).graph.addNode({
                id: node.id,
                label: node.label,
                originalLabel: node.label,
                originalColor: color_context,
                size: maxnodesize - 2,
                x: Math.random(),
                y: Math.random(),
                color: color_context
              }); 
        },
        addContextNode: function(context) {
            
            
            let x = Math.random();
            let y = Math.random();
        
          sigma.instances(0).graph.addNode({
                id: context.id,
                label: '',
                originalLabel: 'context: ' + context.label,
                originalColor: '#6689d0',
                size: maxnodesize + 2,
                x: x,
                y: y,
                type: 'square',
                color: '#6689d0',
                url: context.url
            });
            
        },
        removeContextNodes: function() {
            sigma.instances(0).graph.nodes().forEach(function(n) {
                if (n.url) {
                    sigma.instances(0).graph.dropNode(n.id);
                }
            });
            graph().refreshGraph();
        },
        addEdge: function(edgeproc) {
            sigma.instances(0).graph.addEdge({
                id: edgeproc.id,
                source: edgeproc.source,
                target: edgeproc.target,
                weight: edgeproc.weight,
                size: edgeproc.weight,
                statement_id: edgeproc.statement_id,
                edge_context: edgeproc.edge_context
            });
            sigma.instances(0).graph.refresh();
        },
        addContextEdge: function(id,source,target,edge_context) {

            sigma.instances(0).graph.addEdge({
                id: id,
                source: source,
                target: target,
                weight: 6,
                size: 6,
                statement_id: '',
                edge_context: edge_context
            });
        },
        updateNodes: function(nodes, callback){

            sigma.instances(0).graph.nodes().forEach(function(n) {
                if (!nodes[n.id]) {
                  sigma.instances(0).graph.dropNode(n.id);
                }               
            });

            sigma.instances(0).refresh();

        },
        updateMetrics: function() {
            
            // Cytoscape object renew
            let cyCollection = cy.elements();
            cy.remove(cyCollection);            
            let cyNodes = [];

            // Community detection graph object from Graphology
            let grgraph = new graphology.Graph({type: 'undirected'});

            let node_data = [];

            sigma.instances(0).graph.nodes().forEach(function(n) {
                
                // To avoid context: nodes
                if (!n.url) {

                     // Add nodes into the Louvain object
                    node_data.push(n.id);

                    // Add nodes into the Graphology object
                    grgraph.addNode(n.id);

                    // Add the nodes into a Cytoscape object
                    cyNodes.push({
                        group: "nodes",
                        data: { id: n.id, name: n.originalLabel}
                    });
                }
               

            });

            // jsnetworkx object creation
            let jsGraphEdges = [];
            let edge_data = [];
            let nodeIDs_rev = graphFactory.getNodeIDsRev();

            // Let's record all the unique edges we've got
            let edgesList = [];

            let totalUnEdgesCount = 0;
            let totalDiEdgesCount = 0;

            sigma.instances(0).graph.edges().forEach(function(e) {
                // To only include the nodes which are not :context
                if (e.edge_context) {
                
                    let unique_edge_id = '';

                    // Let's see if the edge source in alphabetical order is further than its target and change places

                    if (e.source > e.target) {
                        unique_edge_id = e.target + '-' + e.source;
                    }
                    else {
                        unique_edge_id = e.source + '-' + e.target;
                    }


                    // An edge linking these nodes already exists? Let's add their sizes (Sigma doesn't do this automatically)

                    if (edgesList[unique_edge_id]) {
                        edgesList[unique_edge_id] += edgesList[unique_edge_id];
                        e.size = e.weight + edgesList[unique_edge_id];
                    }
                    else {
                        // New edge? Just create the edge weight parameter and assign the size
                        edgesList[unique_edge_id] = e.weight;
                        e.size = e.weight;
                    }

                    cyNodes.push({
                        group: "edges",
                        data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                    });

                    // TODO remove that, this is just to check data consistentency
                    e.sourcename = nodeIDs_rev[e.source];
                    e.targetname = nodeIDs_rev[e.target];

                    var matche = 0;

                    // Do we already have any edges saved for jsX? Reiterate
                    for (var i = 0; i < edge_data.length; i++) {
                        // Found an edge that has the current edge's source/target combination?
                        // replace && with || for undirected graph
                        if ((edge_data[i].source == e.source && edge_data[i].target == e.target) || (edge_data[i].target == e.source && edge_data[i].source == e.target)) {
                            
                            // Do not add this age as new later
                            matche = 1;

                            // Add the weights together
                            edge_data[i].weight += parseInt(e.weight);

                            // Reiterate through each jsX object and if found similar source/target combo, update the weight.
                            for (var obj in jsGraphEdges) {
                                if ((jsGraphEdges[obj][0] == e.source && jsGraphEdges[obj][1] == e.target) || (jsGraphEdges[obj][1] == e.source && jsGraphEdges[obj][0] == e.target)) {
                                    jsGraphEdges[obj][2].weight += parseInt(e.weight); 
                                }
                            }
                        }
                    }

                    // This is the first time we see this edge
                    if (matche == 0) {

                        // Add it into the graph
                        edge_data.push({source: e.source, target: e.target, weight: parseInt(e.weight)});

                        // Add to jsnetworkx

                        let edge_params = {
                            weight: parseInt(e.weight),
                            sourcename: e.sourcename,
                            targetname: e.targetname                     
                        };

                        let edge_object = [e.source, e.target, edge_params];
                    
                        jsGraphEdges.push(edge_object);

                        // The number of unique undirected edges
                        if (e.source != e.target) {
                        totalUnEdgesCount = totalUnEdgesCount + 1;
                        }

                    }

                    // The number of unique directed edges
                    if (e.source != e.target) {
                        totalDiEdgesCount = totalDiEdgesCount + 1;
                    }

                }
                

            });

            // Save the number of edges into the stats object
            graphFactory.setStats('edgesUndirected',totalUnEdgesCount);
            graphFactory.setStats('edgesDirected', totalDiEdgesCount);
            
            // Add the edges into the Graphology object
            for (var i = 0; i < edge_data.length; i++) {
                grgraph.addEdge(edge_data[i].source, edge_data[i].target, {weight: edge_data[i].weight});
            }

            // Object for louvain community detection
            let lougraph = {node_data: node_data, edge_data: edge_data};

            // Add the array to the collection
            let cyElements = cy.add(cyNodes);

            // Create a new graph and add the new edges
            var jsG = new jsnx.Graph(); // DiGraph for directed

            // Fix edge weights (the BC algorithm considers a lower weight edge stronger)
            for (let obj in jsGraphEdges) {
                jsGraphEdges[obj][2].weight = 1 / jsGraphEdges[obj][2].weight;
            }
            // jsG = jsnx.convertToUndirected(jsG);
            jsG.addEdgesFrom(jsGraphEdges);

            // Launch betweenness centrality detection
            betweennessCentrality(cyElements, jsG);

            // Launch community detect algorithm
            communityDetect(lougraph, grgraph, graph().refreshGraph);


        },
        refreshGraph: function() {
            sigma.instances(0).refresh();
            sigmaGraph().adjustLayout(5000);
            
        },
        dragNodes: function () {

            var dragListener = sigma.plugins.dragNodes(sigma.instances(0), sigma.instances(0).renderers[0]);
           
            dragListener.bind('startdrag', function(event) {

            });

            dragListener.bind('drag', function(event) {

              sigma_dragged = 1;

            });

            dragListener.bind('drop', function(event) {

              // sigma.instances(0).refresh();

              var new_forceatlas_options = forceatlas_options;

              new_forceatlas_options.slowDown = 1000;
              new_forceatlas_options.startingIterations = 0;

              sigmaGraph().adjustLayout(5000);

            });
            
            dragListener.bind('dragend', function(event) {

            });

          }
    }
}



var timeOutVar = '';

function sigmaGraph() {
    return {
        startLayout: function(timeout, terminator) {
            if (terminator) {
                clearTimeout(timeOutVar);
            }
            else {
                timeOutVar = setTimeout(function() {
                            sigma.instances(0).stopForceAtlas2();
                            sigma.instances(0).killForceAtlas2();
                            $('#improve-layout').removeClass('layout-on');
                            console.log('stopped FA layout')
                },parseInt(timeout));
            }

        }, 
        adjustLayout: function(timeout) {

            if (sigma.instances(0).isForceAtlas2Running()) {
                    console.log('FA IS RUNNING')
                    sigmaGraph().startLayout(timeout, 'stop');
                    sigma.instances(0).stopForceAtlas2();
                    sigma.instances(0).killForceAtlas2();
                    $('#improve-layout').removeClass('layout-on');
                    if (timeout) {
                            setTimeout(function() {
                                sigma.instances(0).startForceAtlas2(forceatlas_options);
                                $('#improve-layout').addClass('layout-on');
                                forcedatlas_running = true;
                                sigmaGraph().startLayout(timeout);
                            },200);                         
                    }
                    forcedatlas_running = false;
            }
            else {
                  // sigma.configForceAtlas2({scalingRatio: 0.1});
                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  $('#improve-layout').addClass('layout-on');
                  forcedatlas_running = true;
                  if (timeout) {
                    sigmaGraph().startLayout(timeout);
                  }
            }
        },
        abstractLayout: function() {

            // What happens when we want to stop showing node labels and make the graph more Abstract
            console.log('abstractLayout')
             if (!$('#abstract-layout').hasClass('abstract-on')) {
                console.log('doesnt hav abstract layout');
                var url = window.location.href;
                url = removeParam("abstract", url);
                if (url.indexOf('?') > -1){
                    url += '&abstract=yes'
                }else{
                    url += '?abstract=yes'
                }
                window.location.href = url;

            }
            else {
                console.log(' hav abstract layout');
                var url = window.location.href;
                var alteredURL = removeParam("abstract", url);

                if (alteredURL.indexOf('?') > -1){
                    alteredURL += '&abstract=no'
                }else{
                    alteredURL += '?abstract=no'
                }
                window.location.href = alteredURL;
            }



        },
        clickNode: function() {
            
            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.instances(0).bind('clickNode', function(e) {
                
                if (!sigma_dragged) {
                  
                  // A node was clicked, so we assume there was a meaningful graph interaction
                  graphInteraction = 1;
  
                  var nodeLabel = e.data.node.originalLabel;
  
                  // TODO to check that
                  if (interpret) {
                    $('.entry').show();
                  }
  
                  // If we click on the context node, just bring us to that context
                  if (nodeLabel.substr(0,9) == 'context: ') {
                        let add_url = '';
                  
                        if (nodeLabel.indexOf(', by') == -1) {
                            add_url += '/edit';
                        }
                        let pinnedNodes = graphFactory.getPinnedNodes();
                        for (let pin in pinnedNodes) {
                            if (pin == 0) {
                                add_url += '?keywords=' + pinnedNodes[pin];
                            }
                            else {
                                add_url += "+" + pinnedNodes[pin];
                            }
                        }
                        if (e.data.node.url) {
                            window.open(e.data.node.url + add_url,"_self");
                        }
                        else {
                            window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + add_url,"_self");
                        }
                  }
                  else {
  
                      // Is the node pinned?
                      if (graphFactory.checkIfPinned(nodeLabel) == false) {
                          // Add to pinned and launch the whole filtering machinery
                          graphFactory.addToPinnedNodes(nodeLabel);
                      }
                      else {   
                          graphFactory.removeFromPinnedNodes(nodeLabel);                                    
                      }
  
                      // Let's send an event to all the collaborators in the chatroom
                      socket.emit('node click', {pinnedNodes: graphFactory.getPinnedNodes()});
                          
                      // If the window is wide enough to show the menu AND div with statements is not visible
                      if ($("#statements").is(":hidden") || $("#entries").css("visibility") === "hidden") {
                        // TODO blink the button
                        //   $('#livetext').show();
                        //   $('#livetext').html('<em>open the entries to see the excerpts...</em>' + ' <span></span>');
                      }
  
                  }
  
                }
  
                // This is just to reset node drag parameter
                sigma_dragged = 0;
  
  
              });
        },
        highlightNode: function() {

            // Show the node's label when we're over it
            sigma.instances(0).bind('overNode', function(e) {
                  e.data.node.label = e.data.node.originalLabel;
                  sigma.instances(0).refresh();
            });

            // Hide node's label when we're out of it
            sigma.instances(0).bind('outNode', function(e) {
                
                if ((e.data.node.color != e.data.node.originalColor && graphFactory.checkIfPinned(e.data.node.originalLabel) == false) || e.data.node.url) {
                    e.data.node.label = '';
                }
                sigma.instances(0).refresh();
            });
        }
    }
}

// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});





</script>