<script>

var jsonpath = '';


var maxnodes = '';

// Get the setting from user DB how many max nodes we show
<% if (maxnodes) { %>
  maxnodes = <%= maxnodes %>;
<% } %>


// Path to the JSON graph file (specific context or a general one)
<% if (addcontext) { %>
    jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
    addcontext = "<%= addcontext %>";

<% } else if (showcontexts) { %>
    jsonpath = '/api/user/nodes/<%= context %>?showcontexts=<%= showcontexts %>';
    addcontext = "";

<% } else if (maxnodes) { %>
    jsonpath = '/api/user/nodes/<%= context %>?maxnodes=<%= maxnodes %>';
    maxnodes = '<%= maxnodes %>';
    addcontext = "";

<% } else { %>
    jsonpath = '/api/user/nodes/<%= context %>';
    addcontext = "";
<% }  %>

// Is the user going to look at somebody else's graph?

<% if (perceivername) { %>
    <% if (showcontexts && maxnodes) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>&maxnodes=<%= maxnodes %>';
    <% } else if (showcontexts) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?showcontexts=<%= showcontexts %>';
    <% } else if (maxnodes) { %>
        jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= maxnodes %>';
    <% } else  { %>
        <% if (locals.vieweduser && vieweduser.maxnodes) { %>
            maxnodes = '<%= vieweduser.maxnodes %>';
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>?maxnodes=<%= vieweduser.maxnodes %>';
        <% } else { %>
            jsonpath = '/api/public/nodes/<%= perceivername %>/<%= context %>';
        <% } %>
<% } %>
<% } %>


// Do we show abstract graph and no nodes?

<% if (locals.user && locals.user.abstract != undefined) { %>
        abstract = '<%=locals.user.abstract%>';
<% } %>

if (getUrlVars()["abstract"]) {
      abstract = getUrlVars()["abstract"];
}



// default label threshold
var in_label_threshold = 8;

var default_label_color = '#000000';

if (background == 'dark') {
  default_label_color = '#ffffff';
}

var minnodesize = 5;
var maxnodesize = 16;

if (abstract && abstract != 'no') {
    minnodesize = 1;
    maxnodesize = 1;
    in_label_threshold = 20;
}



// Sigma graph layout options
var forceatlas_options = {worker: false, startingIterations: 100, scalingRatio: 0.1, slowDown: 100, strongGravityMode: true};




// What are the concepts present in the graph?
var statementsOfContext = [];

// Cytoscape object

var elesnodes = [];

// Add Cytoscape Library - to calculate betweenness centrality for nodes and other stuff

var cy = cytoscape({
    container: undefined,
    headless: true
});

var eles;

var topbc_nodes = [];

var top_components = [];

// Let's record all the unique edges we've got
var edgesList = [];

var community_of_node = [];


var sigma_dragged = 0;



// Initialize JSON parser for SIGMA visualization

var color_addcontext = '#666666'; // #cccccc

var highlight_addcontext = '#0089e0';

var highlight = getUrlVars()["highlight"];

var missing = getUrlVars()["missing"];


// These are the nodes clicked in the graph

var global_totalnodes = 0;


// This variable shows if there was a meaningful interaction with the graph yet

var graphInteraction = null;


// This may be a deprecated setting

// Inactivity timeout
var inactiveTimeout = null;


</script>

<%- include('GraphGenerate') %>

<script>


        // What happens when the user clicks on a node in the graph (this is caleld from sigma but processed here)

socket.on('node click', function(msg){

    pinnedNodes = msg.pinnedNodes;
    console.log("Pinned nodes:");
    console.log(pinnedNodes);
    splicedNodes = msg.splicedNodes;
    console.log("Spliced nodes:");
    console.log(splicedNodes);
    var pinnedIndex = msg.pinnedIndex;

    // Are we clicking the node that was clicked already? Then show all divs
    if (pinnedIndex > -1) {
          $('.entry').fadeIn(400);
    }


    // Filter statements and select nodes on the graph
    filter_statements(pinnedNodes);

});


 function dragNodes () {
      var dragListener = sigma.plugins.dragNodes(sigma.instances(0), sigma.instances(0).renderers[0]);
      dragListener.bind('startdrag', function(event) {

      });
      dragListener.bind('drag', function(event) {
        sigma_dragged = 1;
        if (sigma.instances(0).isForceAtlas2Running()) {

          sigma.instances(0).stopForceAtlas2();
          sigma.instances(0).killForceAtlas2();
        }


      });
      dragListener.bind('drop', function(event) {


        // sigma.instances(0).refresh();

        var new_forceatlas_options = forceatlas_options;

        new_forceatlas_options.slowDown = 1000;
        new_forceatlas_options.startingIterations = 0;

        sigma.instances(0).startForceAtlas2(new_forceatlas_options);

        // Don't run it forever not to overheat :)

        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 10000);

     });
      dragListener.bind('dragend', function(event) {

      });
    }



    // Calculate Betweenness Centrality

    var bc_nodes_map;

    function betweennessCentrality (eles, jsG) {

      var collection = cy.elements();
      // console.log(eles);
      // console.log(collection);

      var jsbc = jsnx.betweennessCentrality(jsG, {normalized: true, weight: 'weight'});
      var bc_jsx = jsbc._stringValues;
      
      

      var bc = eles.bc({
          weight: function(edges) {
              return edges.data('weight');
          },
          directed: true
      });

      var bcmin = 1;
      var bcmax = 0;

      var bcmap = [];

      topbc_nodes = [];

      if (!jsG) {
      for (var i = 0; i < cy.nodes().length; i++) {

          var nn = eles.getElementById(cy.nodes()[i].data('id'));

          var currentbc = bc.betweennessNormalized(nn);

          bcmap[cy.nodes()[i].data('id')] = currentbc;

          topbc_nodes.push({key: cy.nodes()[i].data('id'), label: cy.nodes()[i].data('name'), bc: currentbc});

          if (bcmin > currentbc && currentbc != 0) {
            bcmin = currentbc;
          }
          else {
            bcmin = 0.00001
          }

          if (bcmax < currentbc) {
            bcmax = currentbc;
          }

      }
    }
    else {
        for (key in bc_jsx) {
            var currentbc = bc_jsx[key];
            topbc_nodes.push({key: key, label: nodeIDs_rev[key], bc: bc_jsx[key]});
            bcmap[key] = bc_jsx[key];

            if (bcmin > currentbc && currentbc != 0) {
                bcmin = currentbc;
            }
            else {
                bcmin = 0.00001
            }

            if (bcmax < currentbc) {
                bcmax = currentbc;
            }
        }
    }
      bc_nodes_map = bcmap;

      topbc_nodes = _.sortBy(topbc_nodes, 'bc').reverse();

      console.log('Top betweenness centrality nodes:');
      console.log(topbc_nodes);

      topbc_nodes = topbc_nodes.slice(0,5);

      var nodes_shown = 0
      sigma.instances(0).graph.nodes().forEach(function(n) {
        if ((most_influential == 'bc' || most_influential == 'bc2') && topbc_nodes[0].bc > 0) {
          if (bcmap[n.id] == 0) { bcscore = bcmin } else { bcscore = bcmap[n.id] }
          n.size = Math.round(normalize(bcscore, bcmin, bcmax, 5, 35));
          n.bc = bcmap[n.id];
        }
        else {
          n.size = sigma.instances(0).graph.degree(n.id);
        }

        if (n.size > in_label_threshold) {
          console.log(n.label);
          nodes_shown++;
        }
      });
      console.log(nodes_shown);


      top_components = eles.components();

      //sigma.instances(0).refresh();


      //console.log(_.first(_.sortBy(bcmap,'degree').reverse(),3);
      // console.log(bcmin);
      // console.log(bcmax);


    }


        // Community Detect Function

        function communityDetect (coming_from, node_origin) {

// Construct a new Graphology graph object to calculate communities
const grgraph = new graphology.Graph({type: 'undirected'});

// Reiterate nodes
var node_data = [];
sigma.instances(0).graph.nodes().forEach(function(n) {
    node_data.push(n.id);

    // Add nodes into the Graphology object
    grgraph.addNode(n.id);
});

var edge_data = [];

var totaledgescount = 0;

// Reiterate edges
sigma.instances(0).graph.edges().forEach(function(e) {

    var matche = 0;

    for (var i = 0; i < edge_data.length; i++) {
        // replace && with || for undirected graph
      if ((edge_data[i].source == e.source && edge_data[i].target == e.target) || (edge_data[i].target == e.source && edge_data[i].source == e.target)) {
        matche = 1;
        edge_data[i].weight = edge_data[i].weight + parseInt(e.weight);
      }
    }
    if (matche == 0) {
      edge_data.push({source: e.source, target: e.target, weight: parseInt(e.weight)});

    }

    if (e.source != e.target) {
      totaledgescount = totaledgescount + 1;
    }


});

// Add edges into Graphology object
for (var i = 0; i < edge_data.length; i++) {
  grgraph.addEdge(edge_data[i].source, edge_data[i].target, {weight: edge_data[i].weight});
}
// console.log(sigma.instances(0).graph.edges());

// console.log(node_data);
// console.log(edge_data);
// console.log(grgraph);

if (node_data.length > 0 && edge_data.length > 0) {

var community = jLouvain().nodes(node_data).edges(edge_data);
var community_assignment_result = community();
var node_ids = Object.keys(community_assignment_result['communities']);
var com_ass = {};
for (var key in community_assignment_result['communities']) {
    com_ass[nodeIDs_rev[key]] = community_assignment_result['communities'][key];
}
// console.log('Resulting Community Data', community_assignment_result['communities']);
console.log('Resulting Louvain Community Data', com_ass);
console.log('Final Louvain Modularity', community_assignment_result['modularity']);

// Get the graph back from Graphology with community attribute for nodes
var newgraph = louvain_process(grgraph);

// Convert community codes into integers
var louvain_communities = {};
var graphology_communities = [];

grgraph.forEachNode((node, attributes) => {
  var tempo_comm = grgraph.getNodeAttribute(node,'community');
  if (graphology_communities.indexOf(tempo_comm) == -1) {
    graphology_communities.push(tempo_comm);
  }
  louvain_communities[node] = graphology_communities.indexOf(tempo_comm);
});

// Let's calculate modularity
var modularity_score = louvain_modularity(newgraph)

var com_ass2 = {};
for (var key in louvain_communities) {
    com_ass2[nodeIDs_rev[key]] = louvain_communities[key];
}
console.log('Resulting Graphology Community Data', com_ass2);
console.log('Graphology modularity score:', modularity_score);

var node_ids = Object.keys(louvain_communities);

var max_community_number = 0;

var top_communities = {};

// We now add the new community integer ID to all the nodes in the Sigma graph

sigma.instances(0).graph.nodes().forEach(function(n) {

  n.community = louvain_communities[n.id];

  var commune = n.community;
  if (!top_communities[commune]) {
    top_communities[commune] = []
  }

  top_communities[commune].push({id: n.id, name: n.originalLabel, degree: sigma.instances(0).graph.degree(n.id), bc: bc_nodes_map[n.id]});

  max_community_number = max_community_number < louvain_communities[n.id] ? louvain_communities[n.id]: max_community_number;

});

console.log('Total communities: ');
console.log(parseInt(max_community_number + 1));


   var topp_communities = {};

   var all_communities = {};

   for (var indd in top_communities) {
    if (!topp_communities[indd]) {
     topp_communities[indd] = {};
     all_communities[indd] = {};
     topp_communities[indd].id = indd;
     all_communities[indd].id = indd;
     topp_communities[indd].length = top_communities[indd].length;
     all_communities[indd].length = top_communities[indd].length;
     topp_communities[indd].nodes = top_communities[indd];
     all_communities[indd].nodes = top_communities[indd];
    }
   }

   topp_communities = _.sortBy(topp_communities,'length').reverse();
   all_communities = _.sortBy(all_communities,'length').reverse();


   var advice_iterations = 4;
   var recommender_iterations = 2;
   if (topp_communities.length < advice_iterations) {
     advice_iterations = topp_communities.length;
   }

   topp_communities = _.first(topp_communities,advice_iterations);

   var toppp_communities = [];

   // Slice first 3 off every topp community

   for (var j = 0; j < topp_communities.length; j++) {
     if (most_influential == 'bc2') {
       topp_communities[j].nodes = _.first(_.sortBy(topp_communities[j].nodes,'bc').reverse(),3);
     }
     else {
       topp_communities[j].nodes = _.first(_.sortBy(topp_communities[j].nodes,'degree').reverse(),3);
     }
   }

   //console.log(topp_communities);

   // Give it to the global
   most_inf_comm_nodes = topp_communities;

   // these are top nodes in each community
   var top_nodes = [];

   // TODO move parsing logic away from this function


   var recommender_start = 'next idea tip: what is the relation between "';
   var recommender = '';
   var analytics = "<div id='searchanalytics'>The following texts contain the nodes <div id='searchterms'></div><br><div class='headline'>" + current_user + "'s Texts:<br></div>";
   analytics += '<div id="similarlist">n/a</div><br>';
   analytics += "<div class='headline'>Others' Public Texts:<br></div>";
   analytics += '<div id="similaroutside">none found</div><br>&nbsp;';
   analytics += '</div>';

   analytics += "<div id='mininganalytics'><div class='headline'>Main Topics</div> (according to Latent Dirichlet Allocation):<br>";
   analytics += "<div id='topicsLDA'></div><br>";
   analytics += "<div class='headline'>Most Influential Words</div> (main topics and words according to LDA):<br>";
   analytics += "<div id='termsLDA'></div><br>";
   analytics += "LDA works only for English-language texts at the moment. More support is coming soon, subscribe  @noduslabs to be informed.<br><br>";
   analytics += "<button id='miningbutton' class='panelControlBtn' data-id='mining_analytics'>LDA Data</button> <button id='analbutton' class='panelControlBtn' data-id='analytics'>Graph Stats</button>";
   analytics += "</div>";


   analytics = analytics + "<div id='mainanalytics'><div class='headline'>Main Topics</div> (communities detected):<br>"
   analytics += "1: "
   for (var j = 0; j < topp_communities.length; j++) {

      for (var n = 0; n < topp_communities[j].nodes.length; n++) {
          if (recommender_iterations != 0) {
            recommender += "<a href='#' class='community_node' community='"+topp_communities[j].id+"'>" + topp_communities[j].nodes[n].name +'</a> - ';
          }
          analytics += "<a href='#' class='community_node' community='"+topp_communities[j].id+"'>" + topp_communities[j].nodes[n].name + "</a> <div class='inlinesquare "+(topp_communities[j].id)+"'></div> ";
          top_nodes.push(topp_communities[j].nodes[n].name);
      }
      if (recommender_iterations != 0) {
        recommender = recommender.slice(0, -3);
        if (j != recommender_iterations) {
        recommender += '"</div> and <br><div class="headline">"';
        }
        recommender_iterations = recommender_iterations - 1;
      }
    //  analytics = analytics.slice(0, -3);
      analytics += " <br>" + (j + 2) + ": ";
   }

   //recommender = recommender.slice(0, -10);
   recommender += ''
   analytics = analytics.slice(0, -7);



   // Get the nodes with the highest degree
   var degree_nodes = [];
   sigma.instances(0).graph.nodes().forEach(function(n)  {
      degree_nodes.push({id: n.id, label: n.label, degree: sigma.instances(0).graph.degree(n.id)});
   });

   //console.log(degree_nodes);
   degree_nodes = _.first(_.sortBy(degree_nodes,'degree').reverse(),9).slice(0,4);



  // console.log(top_nodes);
  //console.log(degree_nodes.slice(0,4));



  // TODO to move parsing logic away from this function

   analytics += "<br><br><div class='headline'>Most Influential Words";


   var toppbc_nodes = topbc_nodes.slice(0,4);

   console.log('Top betweenness centrality nodes:')
   console.log(toppbc_nodes);

   most_inf_nodes = toppbc_nodes;

   // TODO   if (most_influential == 'bc' && toppbc_nodes[0].bc > 0) {


   if ((most_influential == 'bc' || (most_influential == 'bc2') && toppbc_nodes[0].bc > 0)) {
     analytics += '</div> (highest betweenness centrality):<br>';
     for (var ind in toppbc_nodes) {
         if (toppbc_nodes[ind].bc > 0) {

           analytics += '<div class="inlinesquare '+toppbc_nodes[ind].key+'"></div> <a href="#" class="top_nodes">' + toppbc_nodes[ind].label + '</a> &nbsp;';

         }
     }
     analytics = analytics.slice(0, -7);


   }
   else {
     analytics += '</div> (highest degree):<br>';
     for (var ind in degree_nodes) {
         analytics += '<div class="inlinesquare '+degree_nodes[ind].id+'"></div> <a href="#" class="top_nodes">' + degree_nodes[ind].label + '</a> &nbsp;';
     }
     analytics = analytics.slice(0, -7);


   }

   analytics += "<br><br><div class='headline'>Question to Ask:</div> <br>What is the relation between <br><div class='headline'>\"" + recommender + "\"</div>?";

   analytics += "<br><br><div id='graphstats'></div>";

   analytics += "<br><br><button id='resetgraph' class='panelControlBtn'>Reset</button> &nbsp; <button id='miningbutton' class='panelControlBtn' data-id='mining_analytics'>LDA Data</button> &nbsp; <button id='requestbutton' class='panelControlBtn' data-id='request_analytics'>Custom Report</button>";

   analytics += "</div>";

   // Add control buttons

   analytics = '<div id="panelControllers"><ul><li><button id="analbutton" class="panelControlBtn" data-id="analytics">This Text</li><li><button id="searbutton" class="panelControlBtn" data-id="search_analytics">Related Texts</button></li></ul></div>' + analytics;

   var currentPanel = 'analytics';


    // Check analytics display

   if (!localStorage.getItem('analytics') || localStorage.getItem('analytics') == 1) {


      $('#analytics').html(analytics);
      $('#analytics').show();

      $("#analbutton").css('background','#ffffff');
      $("#searbutton").css('background','#ededed');
      $("#miningbutton").css('background','#ededed');
      $("#resetgraph").css('background','#ededed');


        $('.panelControlBtn').on("click", function() {
          var ID = $(this).attr('data-id');
          if (ID == 'search_analytics') {
            $("#mainanalytics").fadeOut('fast', function() {
            $("#mininganalytics").fadeOut('fast');
            $("#searchanalytics").fadeIn('fast');
            $("#analbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ededed');
            $("#searbutton").css('background','#ffffff');

            // Show similar texts following a search query on the Connections pane

            var squery = '';

            if (pinnedNodes.length > 0) {
              for (var i = 0; i < pinnedNodes.length; i++) {
                squery += pinnedNodes[i] + '+';
              }
            }
            else {

              if ((most_influential == 'bc' || most_influential == 'bc2') && toppbc_nodes[0].bc > 0) {
                for (var ind in toppbc_nodes) {
                    if (toppbc_nodes[ind].bc > 0) {
                      squery += toppbc_nodes[ind].label + '+';
                    }
                }
              }
              else {
                for (var ind in degree_nodes) {
                    squery += degree_nodes[ind].label + '+';
                }
              }
            }

            // Formed search query for JSON GET
            squery = squery.slice(0, -1);


            // Add search terms into the Statistics pane
            $("#searchterms").html('<em>' + squery.replace(/\+/g, ' ') + '</em>');

            // Request user's context graphs (texts) which contain either the top nodes or the selected ones
            console.log('<%=perceivername %>'); // public view
            console.log('<%=receivername %>'); // private view
            $.getJSON("/api/" + current_user + "/connectedcontexts/?keywords=" + squery + "&user=" + current_user, function( data ) {
              var items = [];
              $.each( data.slice(0,7), function( key, val ) {
                <% if (perceivername) { %>
                items.push("<a href='/<%= perceivername %>/" + val.name + "?keywords=" + squery + "'>" + val.name + "</a><br>");

                <% } else  { %>
                items.push("<a href='/<%= receivername %>/" + val.name + "/edit?keywords=" + squery + "'>" + val.name + "</a><br>");

                <% } %>
              });

              $("#similarlist").html(items.join(""));

            });

            // Request user's context graphs (texts) which contain either the top nodes or the selected ones
            $.getJSON("/api/connectedcontexts/?keywords=" + squery, function( data ) {
              var items = [];
              $.each( data.slice(0,7), function( key, val ) {
                items.push("<a href='/" + val[1] + "/" + val[0].name + "?keywords=" + squery + "'>" + val[0].name + "</a><br>");
              });

              $("#similaroutside").html(items.join(""));

            });

            });
            currentPanel = ID;
          }
          else if (ID == 'analytics') {
            $("#searchanalytics").fadeOut('fast', function() {
            $("#mininganalytics").fadeOut('fast');
            $("#mainanalytics").fadeIn('fast');
            $("#analbutton").css('background','#ffffff');
            $("#searbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ededed');
            });
            currentPanel = ID;
          }
          else if (ID == 'mining_analytics') {

            $("#searchanalytics").fadeOut('fast', function() {
            $("#mainanalytics").fadeOut('fast');
            $("#mininganalytics").fadeIn('fast');
            $("#analbutton").css('background','#ededed');
            $("#searbutton").css('background','#ededed');
            $("#miningbutton").css('background','#ffffff');

            var html = "n/a";

            $.getJSON("/api/" + current_user + "/lda/topics/" + current_context, function( data ) {
              var items = [];
              html = '';
              for (var i = 0; i < data.length; i++) {

                for (var j = 0; j < data[i].length; j++) {
                  //console.log(nodeIDs[data[i][j].term]);
                  items.push('<div class="inlinesquare ' + louvain_communities[nodeIDs[data[i][j].term]] + '"></div> <a href="#" class="top_nodes">' + data[i][j].term + '</a> &nbsp;');
                  if (j == (data[i].length - 1)) {
                    items.push('<br>')
                  }
                }


              }


              $("#topicsLDA").html(items.join(""));

              $.getJSON("/api/" + current_user + "/lda/terms/" + current_context, function( data ) {
                var items = [];
                html = '';
                for (var i = 0; i < data.length; i++) {

                  for (var j = 0; j < data[i].length; j++) {
                    //console.log(nodeIDs[data[i][j].term]);
                    items.push('<div class="inlinesquare ' + louvain_communities[nodeIDs[data[i][j].term]] + '"></div> <a href="#" class="top_nodes">' + data[i][j].term + '</a> &nbsp;');
                    if (j == (data[i].length - 1)) {
                      items.push('<br>')
                    }
                  }


                }


                $("#termsLDA").html(items.join(""));

                for (pall in palette) {
                      if (document.getElementsByClassName("inlinesquare " + pall)) {
                        for (var i = 0; i < document.getElementsByClassName("inlinesquare " + pall).length; i++) {

                          document.getElementsByClassName("inlinesquare " + pall)[i].style.backgroundColor=rgbToHex(palette[pall]._rgb[0],palette[pall]._rgb[1],palette[pall]._rgb[2]);
                        }
                      }
                }
                top_nodes_activate();




              });






            });



            });
            currentPanel = ID;
          }

          else if (ID == 'request_analytics'){
            window.open('https://noduslabs.com/services/connections/', '_blank');
          }


        });


      //localStorage.setItem('analytics', 1);
      $('#analyticsbutton').addClass('analytics-on');
      $('#analyticscaption').hide();
   }

   else {
     $('#analytics').html(analytics);
     $('#analytics').hide();
     $('#analyticsbutton').removeClass('analytics-on');
     $('#analyticscaption').show();
     $("#miningbutton").css('background','#ededed');

   }

   if ((hide_always || hide_edit || hide_when_small) && !show_analytics) {
     $('#analytics').hide();
     $('#analyticsbutton').removeClass('analytics-on');
     $('#analyticscaption').show();
   }

   //console.log(localStorage.getItem('analytics'));

   var recommender_tip = $(recommender).text();

   $("#statement").attr("placeholder", recommender_start + recommender_tip + "?").blur().focus();




// nice color palette
if (graphPalette == 'color') {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 60, lightMax: 75, chromaMin: 2, chromaMax: 15});
}
else if (graphPalette == 'mono') {
// subdued chromo
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 40, lightMax: 60, chromaMin: 2, chromaMax: 8});
//
}
else if (graphPalette == 'contrast') {
// subdued chromo
  if (background == 'dark') {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 75, lightMax: 95, chromaMin: 1, chromaMax: 8});
  }
  else {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 40, lightMax: 60, chromaMin: 1, chromaMax: 2});
  }
//
}
// good chromo
else {
  var palette = new DistinctColors({count: max_community_number + 1, lightMin: 70, chromaMin: 60, samples: 100});
}

var s_x = 0;
var s_y = 0;
var e_x = 0;
var e_y = 0;

//console.log(palette);
//  console.log(sigma.instances(0).graph.nodes()[54]);


for (pall in palette) {
    if (document.getElementsByClassName("inlinesquare " + pall)) {
      for (var i = 0; i < document.getElementsByClassName("inlinesquare " + pall).length; i++) {
        document.getElementsByClassName("inlinesquare " + pall)[i].style.backgroundColor=rgbToHex(palette[pall]._rgb[0],palette[pall]._rgb[1],palette[pall]._rgb[2]);
      }
    }
}

var totalnodescount = 0;
var addcontextcount = 0;
var nodesfirstcom = 0;
var nodessecondcom = 0;

var diversityindex = 0;

var diversity = '';

var addcontext_nodes = [];


sigma.instances(0).graph.nodes().forEach(function(n) {
  if (top_nodes.indexOf(n.originalLabel) != -1) {

  }

  community_of_node[n.originalLabel] = n.community;

  n.originalColor = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);

  if (pinnedNodes.indexOf(n.originalLabel) < 0) {

        if (selectedNodes.length > 0){
          if (selectedNodes.indexOf(n.originalLabel) > -1) {
            n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
          }
          else if (coming_from == 'node add' && n.originalLabel == node_origin) {
            n.color = deselected_nodes_color;
          }
          else if (!nodeIDs[n.originalLabel]) {
            n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
          }
        }
        else {
          n.color = rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
        }

  }

  if (!nodeIDs[n.originalLabel]) {
    nodeIDs[n.originalLabel] == n.id;
  }

  if (n.community == topp_communities[0].id) {
  //  console.log(n.originalLabel + ' ' + n.x);
  // TODO here we can calculate modularity
      s_x += n.x;
      s_y += n.y;
    //  console.log(s_x)
    nodesfirstcom = nodesfirstcom + 1;
  }
  if (topp_communities[1]) {
  if (n.community == topp_communities[1].id) {
    e_x += n.x;
    e_y += n.y;

    nodessecondcom = nodessecondcom + 1;
  }
  }

  totalnodescount = totalnodescount + 1;

  if (document.getElementsByClassName("inlinesquare " + n.id)[0] != undefined) {
        document.getElementsByClassName("inlinesquare " + n.id)[0].style.backgroundColor=rgbToHex(palette[n.community]._rgb[0],palette[n.community]._rgb[1],palette[n.community]._rgb[2]);
  }

  // Check if the node is in additional context and if yes, give it a different color

  if (contextNodeID[addcontext] && contextNodeID[current_context]) {
        if (interpret) {
          if (contextNodeID[current_context].indexOf(n.id) > -1) {

              if (!highlight) {
                n.originalColor = '#90909f';

                if (pinnedNodes.indexOf(n.label) == -1) {
                  if (selectedNodes.length > 0){
                    if (selectedNodes.indexOf(n.originalLabel) > -1) {
                    }
                  }
                  else {
                  n.color = '#90909f';
                  }
                }
              }
          }
          else {
            // This shows intersecting nodes
            if (highlight) {
              n.originalColor = highlight_addcontext;

              if (pinnedNodes.indexOf(n.label) == -1) {
                if (selectedNodes.length > 0){
                  if (selectedNodes.indexOf(n.originalLabel) > -1) {
                  }
                }
                else {
                n.color = highlight_addcontext;
                }
              }
            }
          }
          if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) == -1) {
              addcontextcount = addcontextcount + 1;
              addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});
          }
        }
        else {
          if (!missing) {
            if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) == -1) {
                if (highlight) {
                  n.originalColor = highlight_addcontext;
                  n.color = highlight_addcontext;
                }
                else {
                  n.originalColor = color_addcontext;
                  n.color = color_addcontext;
                }
                addcontextcount = addcontextcount + 1;
                addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});
            }
          }
          else {
            if (contextNodeID[addcontext].indexOf(n.id) == -1 && contextNodeID[current_context].indexOf(n.id) > -1) {
                if (highlight) {
                  n.originalColor = highlight_addcontext;
                  n.color = highlight_addcontext;
                }
                else {
                  n.originalColor = color_addcontext;
                  n.color = color_addcontext;
                }
                addcontextcount = addcontextcount + 1;
                addcontext_nodes.push({id: n.id, label: n.originalLabel, size: n.size, community: n.community});

            }
          }
        }

  }


});

// console.log(nodesfirstcom);
// console.log(nodessecondcom);
// console.log(totalnodescount);

global_totalnodes = totalnodescount;

console.log('Top communities:')
console.log(topp_communities);

addcontext_nodes = _.sortBy(addcontext_nodes, 'size').reverse();

diversityindex = ((((nodesfirstcom) / totalnodescount).toFixed(2))*100).toFixed(0);


var graph_density;
if ((totalnodescount - 1) == 0 || totalnodescount == 0) { graph_density = 0 } else {
graph_density  = ((totaledgescount) / ((totalnodescount)*(totalnodescount - 1))).toFixed(3);
}



var diversitytext = '<div class="headline">Stats:</div> total ' + totalnodescount + ' words, graph density ' + graph_density + ', ';

diversitytext += 'average degree: ' + (totaledgescount / totalnodescount).toFixed(2);

var diversity_score = 0;

// TODO add degree distribution to the indexOf maybe through entropy of degree by nodes

var bc_dist = [];

// For every top BC node
console.log("All the different communities in the graph:")
console.log(all_communities);


for (var bcid in toppbc_nodes) {
 if (toppbc_nodes[bcid].bc > 0) {

 for (var comid in all_communities) {
    // Open first community

        //  For every node in that community

            for (var ccnodes in all_communities[comid].nodes) {

                // If the node's ID equals to the current BC node, add the marker
                if (all_communities[comid].nodes[ccnodes].id == toppbc_nodes[bcid].key) {
                  bc_dist.push(all_communities[comid].id);
                }

            }
 }
 }

}

console.log('Distribution of top nodes across all the communities: ')
console.log(bc_dist);

var bc_dist_string = bc_dist.join('');

// Max entropy for a set of 4 elements is 2

var bc_entropy = shannon(bc_dist_string);

// TODO fix bug for two-digit communities

console.log('BC Entropy: ' + bc_entropy);

var most_num_comm = [];

top_components = _.sortBy(top_components, 'length').reverse();

var num_nodes_component = ((top_components[0].nodes().length / totalnodescount).toFixed(2)*100).toFixed(0);

if ((modularity_score > 0.65 && diversityindex < 50) && ((bc_entropy >= 1.5) || (bc_entropy == 0 && toppbc_nodes[0].bc == 0) || (bc_entropy == 0 && num_nodes_component < 40))) {
  diversity_score = 'Dispersed';
  document.getElementById("biasRange").value = "100";
  $('#biasRange').attr('class', 'slider dispersedslider');
}
else if ((modularity_score > 0.4 && diversityindex < 50) && ((bc_entropy >= 1.5) || (bc_entropy == 0 && toppbc_nodes[0].bc == 0) || (bc_entropy == 0 && num_nodes_component < 40))) {
  diversity_score = 'Diversified';
  document.getElementById("biasRange").value = "67";
  $('#biasRange').attr('class', 'slider diversedslider');
}
else if ((modularity_score < 0.4 && modularity_score > 0.2 && bc_entropy >= 0.5) || ((modularity_score > 0.4 && diversityindex >= 50)  && bc_entropy >= 0.5) || (modularity_score > 0.4 && diversityindex < 50 && bc_entropy > 0.5)) {
  diversity_score = 'Focused';
  document.getElementById("biasRange").value = "33";
  $('#biasRange').attr('class', 'slider focusedslider');
}
else {
  diversity_score = 'Biased';
  document.getElementById("biasRange").value = "1";
  $('#biasRange').attr('class', 'slider biasedslider');
}
// Set global parameter
polysingularity_score = diversity_score;


diversitytext +=  ' <br><div class="headline">Discourse structure: <i>' + diversity_score + '</i> &nbsp;&nbsp;[<a href="https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/" target="_blank">?</a>]</div><br>';
diversitytext += modularity_score.toFixed(2) + ' modularity, ';
diversitytext +=  diversityindex + '% of words in the top topic ';

diversitytext += '(total ' + all_communities.length + ' topics), ';

    if (addcontextcount > 0) {


      if (addcontext_nodes.length > 0) {
        var addcontext_text = '<div class="headline">In ' + addcontext + ' but not in ' + current_context + ':</div> ';
        if (addcontext_nodes.length > 4) {
          addcontext_nodes = addcontext_nodes.slice(0, 4);
        }
        for (var nnn = 0; nnn < addcontext_nodes.length; nnn++) {
          addcontext_text += '<a href="#" class="top_nodes">' + addcontext_nodes[nnn].label + '</a> - ';
        }
        addcontext_text = addcontext_text.slice(0, -3);
        addcontext_text += '<br><br>'
        diversitytext = addcontext_text + diversitytext;
      }
      var addindex = ((((totalnodescount - addcontextcount) / totalnodescount).toFixed(2))*100).toFixed(0);
      diversitytext += 'context ' + addcontext + ' uses ' + addindex + '% words from ' + current_context + ', ';
    }



diversitytext += num_nodes_component + '% in the main connected component '


diversitytext += '(' + top_components.length + ' in total), ';

diversitytext += 'influence dispersal ' + ((bc_entropy/2).toFixed(1)*100).toFixed(0) + '%';


$('#graphstats').html(diversitytext);

//sigma.instances(0).refresh;


//console.log(top_communities);
//console.log(sigma.instances(0).graph.nodes());
}





var commClicked = [];

  top_nodes_activate();

  $('#resetgraph').click(function(){
    sigma.instances(0).graph.nodes().forEach(function(n) {
            n.color = n.originalColor;
            n.label = n.originalLabel;
    });
    pinnedNodes = [];
    commClicked = [];

    $('.community_node').each(function(){
      $(this).removeAttr('style');
    });

    $('.top_nodes').each(function(){
      $(this).removeAttr('style');
    });

    filter_statements(pinnedNodes);
    sigma.instances(0).refresh();
  });




function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}



// communityDetect function ends here
}

function top_nodes_activate() {
      $('.top_nodes').click(function(){
        var nodeLabel = $(this).text();


        if (pinnedNodes.indexOf(nodeLabel) < 0) {
            pinnedNodes.push(nodeLabel);
            $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
        }
        else {
            var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
            if (pinnedIndex > -1) {
                pinnedNodes.splice(pinnedIndex,1);
                $(this).removeAttr('style');
                $('.entry').fadeIn(400);
            }

        }

        // console.log("node clicked, now will filter for nodes " + pinnedNodes);
        socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


        // Now show / hide statements that have the search field

        filter_statements(pinnedNodes);
        return false;

      });
      var commClicked = [];
      $('.community_node').click(function(){
            var communityClicked = $(this).attr('community').toString();

            var nodeLabel = $(this).text();

            if (pinnedNodes.indexOf(nodeLabel) < 0) {
                pinnedNodes.push(nodeLabel);
                $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
            }
            else {
                var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                if (pinnedIndex > -1) {
                    pinnedNodes.splice(pinnedIndex,1);
                    $(this).removeAttr('style');
                    $('.entry').fadeIn(400);
                }

            }




          //  socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});
            // console.log(pinnedNodes);
            filter_statements(pinnedNodes, 'community');



            if (commClicked.indexOf(communityClicked) == -1) {
                // console.log("the community clicked was not clicked before");


                // sigma.instances(0).graph.edges().forEach(function(e) {
                //
                //     if (e.statement_id == keepStatementID) {
                //         e.color = e.originalColor;
                //     }
                //     else {
                //         e.color = '#ddd';
                //     }
                //
                // });

                // Specify which community is clicked
                commClicked.push(communityClicked);


                // Make only those nodes visible that belong to the community selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    if (commClicked.indexOf(n.community.toString()) > -1)  {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                        if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                          n.color = '#0089e0';
                        }
                    }
                    else {
                      n.color = deselected_nodes_color;
                      n.label = '';
                    }

                });
            }

            else {
              // console.log("the community was clicked before");

                if (pinnedNodes.length == 0) {
                    // sigma.instances(0).graph.edges().forEach(function(e) {
                    //     e.color = e.originalColor;
                    // });

                    commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);

                    // Make only those nodes visible that belong to the statement selected
                    sigma.instances(0).graph.nodes().forEach(function(n) {
                      if (commClicked.indexOf(n.community.toString()) < 0) {
                              if (commClicked.length == 0) {
                                n.color = n.originalColor;
                                n.label = n.originalLabel;
                              }
                              else {
                                n.color = deselected_nodes_color;
                                n.label = '';
                              }
                      }
                    });


                  }
                else {
                    // We clicked on the community which is in the DB of clicked ones and We have some pinned nodes left

                      // Is the node clicked in the pinned nodes?
                      if (pinnedNodes.indexOf(nodeLabel) > -1) {
                        // console.log('in the pinned nodes')
                        sigma.instances(0).graph.nodes().forEach(function(n) {
                          if (commClicked.indexOf(n.community.toString()) > -1)  {
                              n.color = n.originalColor;
                              n.label = n.originalLabel;
                              if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                                n.color = '#0089e0';
                              }
                          }
                          else {
                            n.color = deselected_nodes_color;
                            n.label = '';
                          }
                      });
                    }
                    // It is not in the pinneed nodes
                    else {
                      // console.log('not in the pinneed nodes')
                      // console.log(commClicked)
                      // console.log(pinnedNodes);

                      // is the last node of the community?
                      var islastnode = 0;
                      for (key in topp_communities) {
                        if (communityClicked == topp_communities[key].id) {
                          for (kkey in topp_communities[key].nodes) {
                            // console.log(topp_communities[key].nodes[kkey].name);
                            // console.log(pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name));
                            if (pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name) > -1) {
                              islastnode = 1;
                            }

                          }
                        }
                      }
                      // console.log(islastnode);

                      if (!islastnode) {
                        commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);
                      }
                      //console.log(pinnedNodes);

                      sigma.instances(0).graph.nodes().forEach(function(n) {
                        if (commClicked.indexOf(n.community.toString()) < 0) {
                                if (commClicked.length == 0) {
                                  n.color = n.originalColor;
                                  n.label = n.originalLabel;
                                }
                                else {
                                  n.color = deselected_nodes_color;
                                  n.label = '';
                                }

                        }

                        if (pinnedNodes.indexOf(n.originalLabel) > -1) {
                          n.color = '#0089e0';
                          n.label = n.originalLabel;
                        }
                        if (pinnedNodes.indexOf(n.originalLabel) < 0 && islastnode && n.originalLabel == nodeLabel) {
                          n.color = n.originalColor;
                          n.label = n.originalLabel;
                        }


                      });

                    }
                }

            }

            sigma.instances(0).refresh();

      });

    }


function sigmaGraph() {
    return {
        adjustLayout: function() {
            if (sigma.instances(0).isForceAtlas2Running()) {
                    sigma.instances(0).stopForceAtlas2();
                    sigma.instances(0).killForceAtlas2();
                    $('#improve-layout').removeClass('layout-on');
                    forcedatlas_running = false;
            }
            else {
                  // sigma.configForceAtlas2({scalingRatio: 0.1});
                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  $('#improve-layout').addClass('layout-on');
                  forcedatlas_running = true;
            }
        },
        abstractLayout: function() {

            // What happens when we want to stop showing node labels and make the graph more Abstract
            console.log('abstractLayout')
             if (!$('#abstract-layout').hasClass('abstract-on')) {
                console.log('doesnt hav abstract layout');
                var url = window.location.href;
                url = removeParam("abstract", url);
                if (url.indexOf('?') > -1){
                    url += '&abstract=yes'
                }else{
                    url += '?abstract=yes'
                }
                window.location.href = url;

            }
            else {
                console.log(' hav abstract layout');
                var url = window.location.href;
                var alteredURL = removeParam("abstract", url);

                if (alteredURL.indexOf('?') > -1){
                    alteredURL += '&abstract=no'
                }else{
                    alteredURL += '?abstract=no'
                }
                window.location.href = alteredURL;
            }



        }
    }
}


function filter_graph(pins, origin){


var toKeep = [];

var toKeepPinned = [];

var toKeepMap = [];


// Debug: show which nodes are clicked
// console.log("Pinned nodes clicked:");
// console.log(pins);


// Are any nodes at all selected on the graph?

if (pins.length > 0) {

    // Reiterate for each pinned node

    for (var i = 0; i < pins.length; i ++) {

        // Now we reiterate through every node in the graph

        sigma.instances(0).graph.nodes().filter(function(n) {

            var pinSearch = '';

            // Lemmataze search query if we're coming from search box

            // SEARCHMOD
           /* if (origin == 'search') {

                var nodeLemma = window.jstemmer(n.originalLabel);


                if (nodeLemma.length > 0) {
                    pinSearch = nodeLemma;
                }
                else {
                    pinSearch = n.originalLabel;
                }
            }

            // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

            else {
                pinSearch = n.originalLabel;
            }*/

            pinSearch = n.originalLabel;

            // Is the current node of the graph one of the ones that was clicked before?

            if (pins[i] == pinSearch) {


                // The ID of the current node is...
                var nodeId = n.id;

                // Its neighbors are...
                var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                var nnodesArray = [];

                // We create an array from neighbors that looks like toKeep one

                for (var key in nnodes) {
                    nnodesArray.push(nnodes[key]);
                }


                // If that's not the first iteration, we only keep intersection of both

                if (i > 0) {
                    toKeep = _.intersection(toKeep, nnodesArray);
                }
                else {
                    toKeep = nnodesArray;
                }

                toKeepPinned.push(n);


            }

        });

    }

    // Make array of nodes to keep unique to avoid duplicates



    toKeep = _.uniq(toKeep);

    toKeep = _.union(toKeep,toKeepPinned);


    // console.log("Keeping the nodes:");
    // console.log(toKeep);

    console.log(toKeep.length + ' nodes selected out of ' + global_totalnodes + ' (' + (toKeep.length/global_totalnodes).toFixed(2)*100 + '%)')

    selectedNodes = [];
    for (var irr in toKeep) {
      selectedNodes.push(toKeep[irr].label);
    }


    // Now convert this to an array that will be understood by the functions below

    for (key in toKeep) {
        toKeepMap[toKeep[key].id] = toKeep[key];
    }


    // For each node in the graph

    sigma.instances(0).graph.nodes().forEach(function(n) {

        if (toKeepMap[n.id])  {

            var pinSearch = '';

            // Lemmataze search query if we're coming from search box
            // SEARCHMOD
           /* if (origin == 'search') {
                var nodeLemma = window.jstemmer(n.originalLabel);


                if (nodeLemma.length > 0) {
                    pinSearch = nodeLemma;
                }
                else {
                    pinSearch = n.originalLabel;
                }
            }

            // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

            else {
                pinSearch = n.originalLabel;
            }*/

            pinSearch = n.originalLabel;


            if (pins.indexOf(pinSearch) > -1) {
                    n.color = '#0089e0';

                    if (n.originalLabel == toKeepPinned[toKeepPinned.length-1].label) {
                        console.log('The node "' + n.originalLabel + '" has ' + n.size + ' edges (degree), betweenness centrality: ' + n.bc + ', belongs to ' + n.community + ' community.');
                    }

                }
                else {
                    n.color = n.originalColor;

                }
                n.label = n.originalLabel;

        }
            else  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

    });

    sigma.instances(0).graph.edges().forEach(function(e) {
            if (toKeepMap[e.source] && toKeepMap[e.target]) {
                e.color = e.originalColor;
            }
            else {
                e.color = deselected_nodes_color;
            }
    });



}

// No nodes are selected (or all are deselected) - show the whole graph

else {
    console.log('deselecting the graph');

    sigma.instances(0).graph.nodes().forEach(function(n) {


       n.color = n.originalColor;
       n.label = n.originalLabel;

       n.marked = 0;



    });

    sigma.instances(0).graph.edges().forEach(function(e) {

       e.color = e.originalColor;

    });

    // Remove all selections
    selectedNodes = [];


    // We show the whole graph above so scroll down to all the statements
    entries().scroll();


}

// Since the data has been modified, we need to
// call the refresh method to make the colors
// update effective.

sigma.instances(0).refresh();

<% if (locals.user) { %>
<% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


console.log('using MIDI data ' + midi);
console.log('playing MIDI device:');
console.log(output);

var timecode = 0;

var note_node = midi.substr(10,2);
if (note_node.substr(1,1) == '0') {
  note_node = note_node.substr(0,1) + '1';
}

var note_edge = midi.substr(12,2);
if (note_edge.substr(1,1) == '0') {
  note_edge = note_edge.substr(0,1) + '1';
}



for (var m = 0; m < pins.length; m++) {


    setTimeout(function () {
      output.playNote(note_node, parseInt(midi.substr(0,2)));
      output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
      console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
    }, timecode);
    timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
}

var timecodea = 0;

for (var ed = 0; ed < toKeep.length; ed++) {

    setTimeout(function () {
      output.playNote(note_edge, parseInt(midi.substr(2,2)));
      output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
      console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
    }, timecodea);
      timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

}

<% } %>
<% } %>


}







</script>