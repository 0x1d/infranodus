<div id="graphTags">
    <div id="pinnedlist"><a href="javascript:" id="undo" class="tooltip" title="remove selected nodes and reset graph" ></a><a href="javascript:" id="deletenodes" class="tooltip" title="remove selected nodes from the graph"></a><div id="pinnednodeslist"></div><div id="stopnodeslist"></div><a href="javascript:" id="stopsave" class="tooltip" title="save to permanent stopwords"></a></div>
</div>

<script>


undoButton().onClick(resetGraph);

function undoButton() {
    return {
        onClick: function(onClick){
            $('#undo').on('click', onClick)
        }
    }
}

function resetGraph() {
    socket.emit('graph reset');
}




function addTagTriggers() {


    $(".tags").on('click', function(e) {

        e.preventDefault();

        var remove_node = e.target.innerText;

        // Is the clicked node in the pinnedNodes list
        var pinnedIndex = pinnedNodes.indexOf(remove_node);

        // Yes, it is, remove it and push it into the notfoundNodes list

        if (pinnedIndex > -1) {

                pinnedNodes.splice(pinnedIndex,1);

            //  notfoundNodes.push(remove_node);

        }


        // TODO this is very fuzzy logic here bad bad

        // Is there any nodes that were clicked before but not displayed on the graph?
        // Yes, more than 1
        if (splicedNodes.length > 1) {
            // Add them into the pinned
            pinnedNodes = [];
            for (var p = 0; p < splicedNodes.length; p++ ){
                pinnedNodes[p] = splicedNodes[p];
            }
        }


        // Only one
        else if (splicedNodes.length == 1) {
            pinnedNodes = [];
            pinnedNodes[0] = splicedNodes[0];
            splicedNodes = [];
        }


        if (deletedNodes.indexOf(remove_node) > -1) {
            socket.emit('node add', {addingNodes: remove_node, stoplistNodes: deletedNodes});
        }
        else {

        // console.log("node clicked, now will filter for nodes " + pinnedNodes);

            $('.entry').fadeIn(400);

            filter_statements(pinnedNodes);


        }





    });

}

        // What happens when we click a button to delete a selected node
        $("#deletenodes").on('click', function(e) {
          e.preventDefault;
          socket.emit('node delete', {pinnedNodes: pinnedNodes});
        });

     

        // What happens if we want to pass the list of keywords we selected to the settings

        $("#stopsave").on('click', function(e) {
          e.preventDefault;
          window.location.href = "/settings?stopwords=" + encodeURIComponent(deletedNodes.join(' ')) + "&returncontext=" + current_context;
        });

// What happens when we delete a node

socket.on('node delete', function(msg){

    var nodesToDelete = msg.pinnedNodes;
    var delete_from = msg.delete_from;
    var collectiond = cy.elements();
    var elesss;

    cy.remove(collectiond);

    elesnodes = [];

    // jsnetworkx
    var jsGraphEdges = [];
    nodeIDs_rev = _.invert(nodeIDs);

    // Reiterate nodes and delete all the pinned nodes

    sigma.instances(0).graph.nodes().forEach(function(n) {

        if (nodesToDelete.indexOf(n.originalLabel) >= 0) {
        sigma.instances(0).graph.dropNode(n.id);
        if (deletedNodes.indexOf(n.originalLabel) == -1) {
            deletedNodes.push(n.originalLabel);
        }
        }
        else {
        // Add the remaining ones to Cytoscape
        n.color = n.originalColor;
        n.label = n.originalLabel;
        elesnodes.push({
            group: "nodes",
            data: { id: n.id, name: n.label}
        });


        }
    //n.size = sigma.graph.degree(n.id);

    });

    // Reiterate all the remaining edges and add them to Cytascape
    // TODO this code duplicates from above - move into a function
    sigma.instances(0).graph.edges().forEach(function(e) {

        var unique_edge_id = '';

        // Let's see if the edge source in alphabetical order is further than its target and change places

        if (e.source > e.target) {
            unique_edge_id = e.target + '-' + e.source;
        }
        else {
            unique_edge_id = e.source + '-' + e.target;
        }

        elesnodes.push({
            group: "edges",
            data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
        });

             // TODO remove that, this is just to check data consistentency
             e.sourcename = nodeIDs_rev[e.source];
        e.targetname = nodeIDs_rev[e.target];


         // Add to jsnetworkx

         var edge_params = {
                     weight: 1/e.weight,
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
        };

        var edge_object = [e.source, e.target, edge_params];
                 
        jsGraphEdges.push(edge_object);

    });


    // Betweenness Centrality Calculation using Cytoscape
    elesss = cy.add(elesnodes);

    var jsG = new jsnx.DiGraph();
    // jsG = jsnx.convertToUndirected(jsG);
           
    jsG.addEdgesFrom(jsGraphEdges);


    betweennessCentrality(elesss, jsG);

    // Community detect algorithm

    communityDetect();

    // No more pinned nodes

    if (!delete_from) {
    pinnedNodes = [];
    }
    commClicked = [];

    $('.community_node').each(function(){
    $(this).removeAttr('style');
    });

    $('.top_nodes').each(function(){
    $(this).removeAttr('style');
    });

    if (sigma.instances(0).isForceAtlas2Running()) {
        sigma.instances(0).stopForceAtlas2();
        sigma.instances(0).killForceAtlas2();
        setTimeout(function() {
        sigma.instances(0).startForceAtlas2(forceatlas_options);
        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 5000);
    }, 1000);
    }
    else {

        sigma.instances(0).startForceAtlas2(forceatlas_options);
        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 5000);

    }


    // Unfliter the nodes
    filter_statements(pinnedNodes, "nodedelete");


    sigma.instances(0).refresh();



});

// What happens when we add a node ?

socket.on('node add', function(msg){
var addingNodes = msg.addingNodes;
var stoplistNodes = msg.stoplistNodes;

// Remove the clicked node from the stoplist

stoplistNodes.splice(stoplistNodes.indexOf(addingNodes), 1);


sigma.instances(0).graph.addNode({
    id: nodeIDs[addingNodes],
    label: addingNodes,
    originalLabel: addingNodes,
    size: 16,
    x: Math.random(),
    y: Math.random()
});

var cyclefinished = 0;
var edgeproc;

var nodeIDs_rev = _.invert(nodeIDs);



for (var i = 0; i < edgesDB.length; i++ ) {
  if (edgesDB[i].source == nodeIDs[addingNodes] || edgesDB[i].target == nodeIDs[addingNodes]) {

    edgeproc = edgesDB[i];

    if (stoplistNodes.length > 0) {

        // Do connections only if target/source is not in the remaining stoplistNodes
          if (stoplistNodes.indexOf(nodeIDs_rev[edgeproc.source]) < 0 && stoplistNodes.indexOf(nodeIDs_rev[edgeproc.target]) < 0) {

                sigma.instances(0).graph.addEdge({
                       id: edgeproc.id,
                       source: edgeproc.source,
                       target: edgeproc.target,
                       weight: edgeproc.weight,
                       size: edgeproc.weight,
                       statement_id: edgeproc.statement_id,
                       edge_context: edgeproc.edge_context
                });

            }




    }
    else {
      sigma.instances(0).graph.addEdge({
             id: edgeproc.id,
             source: edgeproc.source,
             target: edgeproc.target,
             weight: edgeproc.weight,
             size: edgeproc.weight,
             statement_id: edgeproc.statement_id,
             edge_context: edgeproc.edge_context
      });

    }
  }
  cyclefinished = cyclefinished + 1;
}



if (cyclefinished == edgesDB.length) {
  sigma.instances(0).refresh();
  var collectiond = cy.elements();
  var elessss;

  cy.remove(collectiond);

  elesnodes = [];


  sigma.instances(0).graph.nodes().forEach(function(n) {
                      elesnodes.push({
                          group: "nodes",
                          data: { id: n.id, name: n.label}
                      });

                      // Adding a node to the nodeIDs
                      var key = n.label;
                      if (!nodeIDs[key]) {
                          nodeIDs[key] = n.id;
                      }
                      if (nodeNames.indexOf(key) == -1) {
                          nodeNames.push(key);
                      }

  });

  // jsnetworkx
  var jsGraphEdges = [];
    nodeIDs_rev = _.invert(nodeIDs);

  sigma.instances(0).graph.edges().forEach(function(e) {

      var unique_edge_id = '';

      // Let's see if the edge source in alphabetical order is further than its target and change places

      if (e.source > e.target) {
          unique_edge_id = e.target + '-' + e.source;
      }
      else {
          unique_edge_id = e.source + '-' + e.target;
      }

        elesnodes.push({
            group: "edges",
            data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
        });

             // TODO remove that, this is just to check data consistentency
             e.sourcename = nodeIDs_rev[e.source];
        e.targetname = nodeIDs_rev[e.target];

        // Add to jsnetworkx

        var edge_params = {
                     weight: 1/e.weight,
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
        };

        var edge_object = [e.source, e.target, edge_params];
                 
        jsGraphEdges.push(edge_object);


  });


  // Betweenness Centrality Calculation using Cytoscape
  elessss = cy.add(elesnodes);

  var jsG = new jsnx.DiGraph();
    // jsG = jsnx.convertToUndirected(jsG);
           
    jsG.addEdgesFrom(jsGraphEdges);


  betweennessCentrality(elessss, jsG);

  // Community detect algorithm

  communityDetect("node add", addingNodes);

  sigma.instances(0).refresh();

    sigma.instances(0).startForceAtlas2(forceatlas_options);
    // Don't run it forever not to overheat :)

    setTimeout(function() {

        sigma.instances(0).stopForceAtlas2();
        sigma.instances(0).killForceAtlas2();

    }, 5000);


  filter_statements(stoplistNodes, 'stopwords');


}






});


</script>