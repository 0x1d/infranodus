<script>

function GraphFactory(){
                
        // Variables that contain the nodes (for easier search)
        let nodeNames = [];
        let nodeIDs = {}; // maps names (key) to IDs (values)
        let nodeIDs_rev = {}; // maps IDs (key) to names (values)

        // These are the nodes that are selected
        let pinnedNodes = [];

        // These are the nodes that were selected but not found (so gray pinnedNodes)
        let notFoundNodes = [];


        this.addNode = function(name, id) {
            nodeIDs[name] = id;
            nodeIDs_rev[id] = name;
            nodeNames.push(name);
            return true;
        }
        this.getNodeIDs = function() {
            return nodeIDs;
        }

        this.getNodeIDsRev = function() {
            return nodeIDs_rev;
        }

        this.getNodeNames = function() {
            return nodeNames;
        }
  

        this.initPinnedNodes = function(nodes) {
            if (nodes) {
                pinnedNodes = nodes;
            }
            else {
                pinnedNodes = [];
            }
            
            // Select the pinned nodes on the graph and the adjacent ones 
            filter_graph(pinnedNodes);

            // Add tags to the graph
            graphTags().update();

            // Perform filter statements function on the nodes selected
            entries().filter();

            // Add search terms into the top graph search form
            nodeInputField().update(pinnedNodes.concat(notFoundNodes));

            // Add search terms into the bottom entry add field
            addEntryForm().update(pinnedNodes.concat(notFoundNodes));       

        }

        // TODO write initiatilization for the delete nodes

        this.checkIfPinned = function(node) {
            if (pinnedNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        this.addToPinnedNodes = function(name) {
            pinnedNodes.push(name);
            this.initPinnedNodes(pinnedNodes);
            return true;
        }
        this.removeFromPinnedNodes = function(name) {
            pinnedNodes.splice(pinnedNodes.indexOf(name),1);
            this.initPinnedNodes(pinnedNodes);
            return true;
        }
        this.getPinnedNodes = function() {
            return pinnedNodes;
        }
        this.getPinnedNode = function(position) {
            return pinnedNodes[position];
        }
        this.getLastPinnedNode = function() {
            return pinnedNodes[pinnedNodes.length];
        }
        this.getPreviousPinnedNode = function() {
            return pinnedNodes[pinnedNodes.length - 1];
        }
        this.existPinnedNodes = function() {
            if (pinnedNodes && pinnedNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.updateNotFoundNodes = function(nodes) {
            if (!nodes) {
                notFoundNodes = [];
            }
            else {
                notFoundNodes = nodes;
            }
            return true;
        }
        this.addToNotFoundNodes = function(name) {
            notFoundNodes.push(name);
            return true;
        }
        this.getNotFoundNodes = function() {
            return notFoundNodes;
        }
        this.existNotFoundNodes = function() {
            if (notFoundNodes && notFoundNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

}

let graphFactory = new GraphFactory();


sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: minnodesize,
                maxNodeSize: maxnodesize,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: in_label_threshold,
                defaultLabelColor: default_label_color
            }
        },
        function(sigma) {
            var i,
                    timeout = 4000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#cccccc',
                    maxnodesize = 0;
                    

            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
            // We also make the initial graph layout circular, so that ForceAtlas always looks the same

            for (let i = 0; i < nodes.length; i++) {
                var nodesize = 0;
                var angle = Math.PI * 2 * i / nodes.length;
                nodes[i].x = Math.cos(angle);
                nodes[i].y = Math.sin(angle);
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodesize = nodes[i].size;
                if (maxnodesize < nodesize) maxnodesize = nodesize;
                nodes[i].color = color_context;
                
                // Save for backup
                nodes[i].originalColor = color_context;
                nodes[i].originalLabel = nodes[i].label;

                // Creating an index of node labels to IDs for filtering
                graphFactory.addNode(nodes[i].label, nodes[i].id);

                // Add to Cytoscape
                elesnodes.push({
                    group: "nodes",
                    data: { id: nodes[i].id, name: nodes[i].label}
                });
               
            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

            //  console.log(e.source + ' ' + e.target + ' ' + e.weight);

                var unique_edge_id = '';

                // Let's see if the edge source in alphabetical order is further than its target and change places

                if (e.source > e.target) {
                    unique_edge_id = e.target + '-' + e.source;
                }
                else {
                    unique_edge_id = e.source + '-' + e.target;
                }


                // Let's make a unique list of edges to count how many there are of the same kind

                if (edgesList[unique_edge_id]) {
                    ++edgesList[unique_edge_id];

                    // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                    e.size = e.weight + edgesList[unique_edge_id];
                }
                else {
                    edgesList[unique_edge_id] = 1;
                    e.size = e.weight;
                }


                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement

                // For each statement that contains this edge
                for (let item of e.statement_id) {
                           
                  if (nodesOfStatement[item]) {
                      if (nodesOfStatement[item].indexOf(e.source) < 0)
                          nodesOfStatement[item].push(e.source);
                      if (nodesOfStatement[item].indexOf(e.target) < 0)
                          nodesOfStatement[item].push(e.target);
                  }
                  else {
                      nodesOfStatement[item] = [];
                      nodesOfStatement[item].push(e.source);
                      // avoid duplicates
                      if (e.source != e.target) {
                        nodesOfStatement[item].push(e.target);
                      }
                      
                  }
                }

                if (statementsOfContext[e.edge_context]) {
                    for (let item of e.statement_id) {
                      if (statementsOfContext[e.edge_context].indexOf(item) < 0) statementsOfContext[e.edge_context].push(item);
                    }
                }
                else {
                    statementsOfContext[e.edge_context] = [];
                    for (let item of e.statement_id) {
                      statementsOfContext[e.edge_context].push(item);
                    }
                }

                // Add to Cytoscape
                elesnodes.push({
                    group: "edges",
                    data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                });

               

                // Add to EDGES db
                edgesDB.push(e);

            });


            // Get the context names - all the contexts that exist in the graph we just loaded
            // This IF statement is for the case when the contextlist parameter is not passed on

            // NOTE this function can be activated if you want to get the list of contexts from the visible graph only
            // contextNames = _.keys(contextNodeID);

            // populateContextMenu(contextNames);

            // Now we get the context IDs from the graph - a little bit of a workaround
            var suspects = [];
            var nonsuspects = [];

            var jsGraphEdges = [];

            var edge_data = [];

            sigma.graph.edges().forEach(function(e) {

                // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                if (e.id.substr(0,7) == 'context') {
                        if (suspects.indexOf(e.source) < 0) {
                            suspects.push(e.source);
                        }

                        if (suspects.indexOf(e.target) < 0) {
                            suspects.push(e.target);
                        }

                }

                // If an edge doesn't have prefix context, for sure it has only nodes
                else {
                        if (nonsuspects.indexOf(e.source) < 0) {
                            nonsuspects.push(e.source);
                        }

                        if (nonsuspects.indexOf(e.target) < 0) {
                            nonsuspects.push(e.target);
                        }
                }

                 // TODO remove that, this is just to check data consistentency
                e.sourcename = nodeIDs_rev[e.source];
                e.targetname = nodeIDs_rev[e.target];


                var matche = 0;

                for (var i = 0; i < edge_data.length; i++) {
                    // replace && with || for undirected graph
                    if ((edge_data[i].source == e.source && edge_data[i].target == e.target) || (edge_data[i].target == e.source && edge_data[i].source == e.target)) {
                        matche = 1;
                        edge_data[i].weight = edge_data[i].weight + parseInt(e.weight);
                        for (var obj in jsGraphEdges) {
                            if ((jsGraphEdges[obj][0] == e.source && jsGraphEdges[obj][1] == e.target) || (jsGraphEdges[obj][1] == e.source && jsGraphEdges[obj][0] == e.target)) {
                                jsGraphEdges[obj][2].weight += parseInt(e.weight); 
                            }
                        }
                    }
                }

                if (matche == 0) {
                    edge_data.push({source: e.source, target: e.target, weight: parseInt(e.weight)});

                    // Add to jsnetworkx

                    var edge_params = {
                        weight: parseInt(e.weight),
                        sourcename: e.sourcename,
                        targetname: e.targetname                     
                     };

                    var edge_object = [e.source, e.target, edge_params];
                 
                    jsGraphEdges.push(edge_object);

                }
     
                 
            });

            for (var obj in jsGraphEdges) {
                jsGraphEdges[obj][2].weight = 1 /  jsGraphEdges[obj][2].weight;
            }

            var jsG = new jsnx.Graph();
            // jsG = jsnx.convertToUndirected(jsG); // this is if we instantiated with DiGraph and fixed the logic above
           
           
            jsG.addEdgesFrom(jsGraphEdges);

            // console.log(jsG.edges(true));

    
            // Find the difference between two arrays above, so we get contexts only
            var contextids = _.difference(suspects, nonsuspects);


            // Now show those nodes that are contexts bigger and with a special label

            for (i = 0; i < nodes.length; i++) {

                if (contextids.indexOf(nodes[i].id) > -1) {
                    nodes[i].size = maxnodesize;
                    nodes[i].originalLabel = 'context: ' + nodes[i].originalLabel;
                    nodes[i].label = 'context: ' + nodes[i].label;
                }


            }


            // Initialize autofill for hashtags and contexts
            autofill(graphFactory.getNodeNames(),contextNames);


            if (document.getElementById('context').value) {
                current_context_field = [document.getElementById('context').value];
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:last").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                    current_context_field = ['private'];
                    $("#addedContexts").val('private');
                }

                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            if (background == 'dark') { $('#tagInputBox').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'}); }
            // Do ForceAtlasLayout

            if (sigma.isForceAtlas2Running()) {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
            }
            else {
              sigma.startForceAtlas2(forceatlas_options);
            }


            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
                downloadPNG();

            },timeout);


            // Drag nodes function initiated, so we can drag nodes

            dragNodes();

            // Betweenness Centrality Calculation using Cytoscape

            // console.log(elesnodes);
            eles = cy.add(elesnodes);


            //console.log(eles.nodes().length);

            betweennessCentrality(eles, jsG);

            // Community detect algorithm

            communityDetect();


            // TODO make it possible for collaboration also

            if (addcontext && interpret) {

              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

              // $('.entry').each(function() {
              //   if ($(this).is(':hidden')) {
              //     $(this).remove();
              //   }
              // });



            }


            // What happens when we click analytics pane

            $('#analyticsbutton').click(function(){
                      // Process logic and remember settings
                     $('#analytics').toggle('slide', function(){
                       if ($('#analytics').is(":visible")) {
                         localStorage.setItem('analytics', 1);
                         $('#analyticsbutton').addClass('analytics-on');
                         $('#analyticscaption').hide();

                       }
                       else {
                         localStorage.setItem('analytics', 0);
                         $('#analyticsbutton').removeClass('analytics-on')
                         $('#analyticscaption').show();
                       }
                     });



            });

            $('#analytics').on('swipedown',function(){$('#analyticsbutton').trigger('click');});

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {
                
              if (!sigma_dragged) {
                
                // A node was clicked, so we assume there was a meaningful graph interaction
                graphInteraction = 1;

                var nodeLabel = e.data.node.originalLabel;

                if (interpret) {
                  $('.entry').show();
                }


                if (nodeLabel.substr(0,9) == 'context: ') {
                    window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>',"_self");
                }
                else {


                    // Was the node clicked already? No? Add it to array of clicked nodes.
                    // Highlight the clicked node in the text.


                    if (splicedNodes.length > 1) {
                         pinnedNodes = [];
                         for (var p = 0; p < splicedNodes.length; p++ ){
                             pinnedNodes[p] = splicedNodes[p];
                         }
                    }
                    else if (splicedNodes.length == 1) {
                        pinnedNodes = [];
                        pinnedNodes[0] = splicedNodes[0];
                        splicedNodes = [];
                    }


                    if (graphFactory.checkIfPinned(nodeLabel) == false) {
                        graphFactory.addToPinnedNodes(nodeLabel);
                    }
                    else {   
                        graphFactory.removeFromPinnedNodes(nodeLabel);
                                              
                    }

                    // Let's send an event to all the collaborators in the chatroom
                    socket.emit('node click', {pinnedNodes: graphFactory.getPinnedNodes(), splicedNodes: splicedNodes, nodeLabel: nodeLabel});
           

                    // Now show / hide statements that have the search field
                    // filter_statements(graphFactory.getPinnedNodes());

                    // If the window is wide enough to show the menu AND div with statements is not visible

                    var isHidden = $("#statements").is(":hidden");

                    // if (isHidden) {
                    //
                    //     var delayShow = 6000;
                    //
                    //     clearTimeout(inactiveTimeout);
                    //     inactiveTimeout = setTimeout(showStatements, delayShow);
                    //
                    //     $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                    //     $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function(){
                    //         if (graphInteraction) {
                    //             clearTimeout(inactiveTimeout);
                    //             inactiveTimeout = setTimeout(showStatements, delayShow);
                    //         }
                    //     });
                    //
                    //
                    // }

                }

              }

              // This is just to reset node drag parameter
              sigma_dragged = 0;


            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && graphFactory.checkIfPinned(e.data.node.originalLabel) == false) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });



            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });

    

            

            // Forward from the graph function


            // Select previously selected nodes on the graph (from LocalStorage) or passed through parameters
            selectNodes();




        }
);



// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});


// TODO if the nodes are deleted, we call community detection twice. Fix that.

function selectNodes() {
    var selected_keywords = getUrlVars()["keywords"];
    if (localStorage.getItem("selections")) {

            var saved_selections = JSON.parse(localStorage.getItem("selections"));

            if (saved_selections[window.location.href]) {
                
                deletedNodes = saved_selections[window.location.href].stopnodes;
                graphFactory.initPinnedNodes(saved_selections[window.location.href].pinnednodes);
                
                if (deletedNodes.length > 0) {
                    socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                    if (graphFactory.getPinnedNodes().length > 0) {
                        filter_statements(graphFactory.getPinnedNodes());
                    }
                }

            }
            else if (interpret) {
                console.log(saved_selections);
                for (var boom in saved_selections) {
                    if (boom.indexOf('/'+addcontext+'/') > -1) {
                    deletedNodes = saved_selections[boom].stopnodes;
                    pinnedNodes = saved_selections[boom].pinnednodes;
                    console.log(deletedNodes);
                    console.log(pinnedNodes);
                    if (deletedNodes.length > 0) {
                        socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                    }
                    else {
                        if (pinnedNodes.length > 0) {
                        filter_statements(pinnedNodes);
                        }
                    }
                    }
                }
            }
            else if (selected_keywords && selected_keywords.length > 0) {
                
                pinnedNodes = selected_keywords.split("+");


                if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                }


            }

            }
            // TODO clear that
            else if (selected_keywords && selected_keywords.length > 0) {
               
                pinnedNodes = selected_keywords.split("+");

                if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                }


            }
}


function filter_graph(pins){


    var toKeep = [];

    var toKeepPinned = [];

    var toKeepMap = [];


    // What are the nodes that we want to filter?

    if (pins.length > 0) {

        // Reiterate for each pinned node

        for (var i = 0; i < pins.length; i ++) {

            // Now we reiterate through every node in the graph

            sigma.instances(0).graph.nodes().filter(function(n) {

                // Is the current node of the graph one of the ones that was clicked before?

                if (pins[i] == n.originalLabel) {

                    // The ID of the current node is...
                    var nodeId = n.id;

                    // Its neighbors are...
                    var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                    var nnodesArray = [];

                    // We create an array from neighbors that looks like toKeep one

                    for (var key in nnodes) {
                        nnodesArray.push(nnodes[key]);
                    }

                    // If that's not the first iteration, we only keep intersection of both

                    if (i > 0) {
                        toKeep = _.intersection(toKeep, nnodesArray);
                    }
                    else {
                        toKeep = nnodesArray;
                    }

                    toKeepPinned.push(n);


                }

            });

        }

        // Make array of nodes to keep unique to avoid duplicates

        toKeep = _.uniq(toKeep);

        toKeep = _.union(toKeep,toKeepPinned);

        console.log(toKeep.length + ' nodes selected out of ' + global_totalnodes + ' (' + (toKeep.length/global_totalnodes).toFixed(2)*100 + '%)')

        // Save which nodes are selected on the graph for community detection

        selectedNodes = [];

        for (var irr in toKeep) {
            selectedNodes.push(toKeep[irr].label);
        }

        // Now convert this to an array that will be understood by the functions below

        for (var key in toKeep) {
            toKeepMap[toKeep[key].id] = toKeep[key];
        }

        // Let's now color the nodes in the graph accordingly

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is the current node iterated in the list to be shown?

            if (toKeepMap[n.id])  {

                if (pins.indexOf(n.originalLabel) > -1) {

                    n.color = '#0089e0';

                    // Display info on the last node selected
                    if (n.originalLabel == toKeepPinned[toKeepPinned.length-1].label) {
                        console.log('The node "' + n.originalLabel + '" has ' + n.size + ' edges (degree), betweenness centrality: ' + n.bc + ', belongs to ' + n.community + ' community.');
                    }

                }
                else {

                    n.color = n.originalColor;

                }

                n.label = n.originalLabel;

            }
            else  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

        });

        // Do the same for the edges

        sigma.instances(0).graph.edges().forEach(function(e) {
                if (toKeepMap[e.source] && toKeepMap[e.target]) {
                    e.color = e.originalColor;
                }
                else {
                    e.color = deselected_nodes_color;
                }
        });



    }

    // No nodes are selected (or all are deselected) - show the whole graph

    else {

        console.log('deselecting the graph');

        sigma.instances(0).graph.nodes().forEach(function(n) {

            n.color = n.originalColor;
            n.label = n.originalLabel;

            n.marked = 0;

        });

        sigma.instances(0).graph.edges().forEach(function(e) {

            e.color = e.originalColor;

        });

        // Remove all selections
        selectedNodes = [];

        // No communities clicked
        commClicked = [];

    }

    // Since the data has been modified, we need to
    // call the refresh method to make the colors
    // update effective.

    sigma.instances(0).refresh();

    // Let's play the graph MIDI sounds on selection

    <% if (locals.user) { %>
    <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


    console.log('using MIDI data ' + midi);
    console.log('playing MIDI device:');
    console.log(output);

    var timecode = 0;

    var note_node = midi.substr(10,2);
    if (note_node.substr(1,1) == '0') {
    note_node = note_node.substr(0,1) + '1';
    }

    var note_edge = midi.substr(12,2);
    if (note_edge.substr(1,1) == '0') {
    note_edge = note_edge.substr(0,1) + '1';
    }



    for (var m = 0; m < pins.length; m++) {


        setTimeout(function () {
        output.playNote(note_node, parseInt(midi.substr(0,2)));
        output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
        console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
        }, timecode);
        timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
    }

    var timecodea = 0;

    for (var ed = 0; ed < toKeep.length; ed++) {

        setTimeout(function () {
        output.playNote(note_edge, parseInt(midi.substr(2,2)));
        output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
        console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
        }, timecodea);
        timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

    }

    <% } %>
    <% } %>


}

function resetGraph() {
    socket.emit('graph reset');
}


</script>