<script>
sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: minnodesize,
                maxNodeSize: maxnodesize,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: in_label_threshold,
                defaultLabelColor: default_label_color
            }
        },
        function(sigma) {
            var i,
                    timeout = 4000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#cccccc',
                    len = nodes.length;

            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
            // We also make the initial graph layout circular, so that ForceAtlas always looks the same

            var maxnodesize = 0;

            for (i = 0; i < len; i++) {
                var nodesize = 0;
                var angle = Math.PI * 2 * i / len;
                nodes[i].x = Math.cos(angle);
                nodes[i].y = Math.sin(angle);
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodesize = nodes[i].size;
                if (maxnodesize < nodesize) maxnodesize = nodesize;
                nodes[i].color = color_context;

                // Add to Cytoscape
                elesnodes.push({
                    group: "nodes",
                    data: { id: nodes[i].id, name: nodes[i].label}
                });
               

            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

            //  console.log(e.source + ' ' + e.target + ' ' + e.weight);

                var unique_edge_id = '';

                // Let's see if the edge source in alphabetical order is further than its target and change places

                if (e.source > e.target) {
                    unique_edge_id = e.target + '-' + e.source;
                }
                else {
                    unique_edge_id = e.source + '-' + e.target;
                }


                // Let's make a unique list of edges to count how many there are of the same kind

                if (edgesList[unique_edge_id]) {
                    ++edgesList[unique_edge_id];

                    // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                    e.size = e.weight + edgesList[unique_edge_id];
                }
                else {
                    edgesList[unique_edge_id] = 1;
                    e.size = e.weight;
                }


                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement
                for (let item of e.statement_id) {
                  if (nodesOfStatement[item]) {
                      if (nodesOfStatement[item].indexOf(e.source) < 0)
                          nodesOfStatement[item].push(e.source);
                      if (nodesOfStatement[item].indexOf(e.target) < 0)
                          nodesOfStatement[item].push(e.target);
                  }
                  else {
                      nodesOfStatement[item] = [];
                      nodesOfStatement[item].push(e.source);
                      nodesOfStatement[item].push(e.target);
                  }
                }

                if (statementsOfContext[e.edge_context]) {
                    for (let item of e.statement_id) {
                      if (statementsOfContext[e.edge_context].indexOf(item) < 0) statementsOfContext[e.edge_context].push(item);
                    }
                }
                else {
                    statementsOfContext[e.edge_context] = [];
                    for (let item of e.statement_id) {
                      statementsOfContext[e.edge_context].push(item);
                    }
                }

                // Add to Cytoscape
                elesnodes.push({
                    group: "edges",
                    data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                });

               

                // Add to EDGES db
                edgesDB.push(e);

            });




            sigma.graph.nodes().forEach(function(n) {

                // Save node's default color, for hide and show later
                n.originalColor = n.color;
                n.originalLabel = n.label;

                // Creating an index of node labels to IDs for filtering
                var key = n.label;
                nodeIDs[key] = n.id;

            });


           //sigma.refresh();





            // for (var j = 0; j < cy.nodes().length; j++) {
            //    console.log(cy.edges()[j].data());
            // }

            //  console.log(eles.getElementById('d5167020-d3ac-11e3-a954-ab35be27f3fc'));


            // Make a list of all the node labels displayed in the graph (for Autofill)

            graphFactory.initNames(_.keys(nodeIDs));



            // Get the context names - all the contexts that exist in the graph we just loaded
            // This IF statement is for the case when the contextlist parameter is not passed on

            // NOTE this function can be activated if you want to get the list of contexts from the visible graph only
            // contextNames = _.keys(contextNodeID);

            // populateContextMenu(contextNames);

            // Now we get the context IDs from the graph - a little bit of a workaround
            var suspects = [];
            var nonsuspects = [];

            nodeIDs_rev = _.invert(nodeIDs);

            var jsGraphEdges = [];


            var edge_data = [];

            sigma.graph.edges().forEach(function(e) {

                // If an edge has a context prefix, one of its nodes is a context, but we don't know which yet

                if (e.id.substr(0,7) == 'context') {
                        if (suspects.indexOf(e.source) < 0) {
                            suspects.push(e.source);
                        }

                        if (suspects.indexOf(e.target) < 0) {
                            suspects.push(e.target);
                        }

                }

                // If an edge doesn't have prefix context, for sure it has only nodes
                else {
                        if (nonsuspects.indexOf(e.source) < 0) {
                            nonsuspects.push(e.source);
                        }

                        if (nonsuspects.indexOf(e.target) < 0) {
                            nonsuspects.push(e.target);
                        }
                }

                 // TODO remove that, this is just to check data consistentency
                 e.sourcename = nodeIDs_rev[e.source];
                e.targetname = nodeIDs_rev[e.target];


    var matche = 0;

for (var i = 0; i < edge_data.length; i++) {
    // replace && with || for undirected graph
  if ((edge_data[i].source == e.source && edge_data[i].target == e.target) || (edge_data[i].target == e.source && edge_data[i].source == e.target)) {
    matche = 1;
    edge_data[i].weight = edge_data[i].weight + parseInt(e.weight);
    for (var obj in jsGraphEdges) {
        if ((jsGraphEdges[obj][0] == e.source && jsGraphEdges[obj][1] == e.target) || (jsGraphEdges[obj][1] == e.source && jsGraphEdges[obj][0] == e.target)) {
            jsGraphEdges[obj][2].weight += parseInt(e.weight); 
        }
    }
  }
}
if (matche == 0) {
  edge_data.push({source: e.source, target: e.target, weight: parseInt(e.weight)});

      // Add to jsnetworkx

      var edge_params = {
                     weight: parseInt(e.weight),
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
                 };

                 var edge_object = [e.source, e.target, edge_params];
                 
                 jsGraphEdges.push(edge_object);

}

               

             
                 
                 
            });

            for (var obj in jsGraphEdges) {
                jsGraphEdges[obj][2].weight = 1 /  jsGraphEdges[obj][2].weight;
            }

            var jsG = new jsnx.Graph();
            // jsG = jsnx.convertToUndirected(jsG);
            console.log('jsG');
            console.log(jsG);
           
            jsG.addEdgesFrom(jsGraphEdges);

            // console.log(jsG.edges(true));

    
            // Find the difference between two arrays above, so we get contexts only
            var contextids = _.difference(suspects, nonsuspects);


            // Now show those nodes that are contexts bigger and with a special label

            for (i = 0; i < len; i++) {

                if (contextids.indexOf(nodes[i].id) > -1) {
                    nodes[i].size = maxnodesize;
                    nodes[i].originalLabel = 'context: ' + nodes[i].originalLabel;
                    nodes[i].label = 'context: ' + nodes[i].label;
                }


            }




            // Initialize autofill for hashtags and contexts
            autofill(graphFactory.getNodeNames(),contextNames);


            if (document.getElementById('context').value) {
                current_context_field = [document.getElementById('context').value];
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:last").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                    current_context_field = ['private'];
                    $("#addedContexts").val('private');
                }

                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            if (background == 'dark') { $('#tagInputBox').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'}); }
            // Do ForceAtlasLayout

            if (sigma.isForceAtlas2Running()) {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
            }
            else {
              sigma.startForceAtlas2(forceatlas_options);
            }


            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
                sigma.killForceAtlas2();
                downloadPNG();

            },timeout);


            // Drag nodes function initiated, so we can drag nodes

            dragNodes();

            // Betweenness Centrality Calculation using Cytoscape

            // console.log(elesnodes);
            eles = cy.add(elesnodes);


            //console.log(eles.nodes().length);

            betweennessCentrality(eles, jsG);

            // Community detect algorithm

            communityDetect();


            // TODO make it possible for collaboration also

            if (addcontext && interpret) {

              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

              // $('.entry').each(function() {
              //   if ($(this).is(':hidden')) {
              //     $(this).remove();
              //   }
              // });



            }


            // What happens when we click analytics pane

            $('#analyticsbutton').click(function(){
                      // Process logic and remember settings
                     $('#analytics').toggle('slide', function(){
                       if ($('#analytics').is(":visible")) {
                         localStorage.setItem('analytics', 1);
                         $('#analyticsbutton').addClass('analytics-on');
                         $('#analyticscaption').hide();

                       }
                       else {
                         localStorage.setItem('analytics', 0);
                         $('#analyticsbutton').removeClass('analytics-on')
                         $('#analyticscaption').show();
                       }
                     });



            });

            $('#analytics').on('swipedown',function(){$('#analyticsbutton').trigger('click');});

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {
              if (!sigma_dragged) {
                // A node was clicked, so we assume there was a meaningful graph interaction
                graphInteraction = 1;

                var nodeLabel = e.data.node.originalLabel;

                if (interpret) {
                  $('.entry').show();
                }


                if (nodeLabel.substr(0,9) == 'context: ') {
                    window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>',"_self");
                }
                else {

                    // Was the node clicked already? No? Add it to array of clicked nodes.
                    // Highlight the clicked node in the text.


                    if (splicedNodes.length > 1) {
                         pinnedNodes = [];
                         for (var p = 0; p < splicedNodes.length; p++ ){
                             pinnedNodes[p] = splicedNodes[p];
                         }
                    }
                    else if (splicedNodes.length == 1) {
                        pinnedNodes = [];
                        pinnedNodes[0] = splicedNodes[0];
                        splicedNodes = [];
                    }

                    if (pinnedNodes.indexOf(nodeLabel) < 0) {
                        pinnedNodes.push(nodeLabel);
                    }
                    else {
                        var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                        if (pinnedIndex > -1) {
                            pinnedNodes.splice(pinnedIndex,1);
                            $('.entry').fadeIn(400);
                        }

                    }

                    // console.log("Pinned nodes: " + pinnedNodes);
                    // console.log("Spliced nodes: " + splicedNodes);
                    socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


                    // Now show / hide statements that have the search field

                    filter_statements(pinnedNodes);




                    // If the window is wide enough to show the menu AND div with statements is not visible

                    var isHidden = $("#statements").is(":hidden");

                    // if (isHidden) {
                    //
                    //     var delayShow = 6000;
                    //
                    //     clearTimeout(inactiveTimeout);
                    //     inactiveTimeout = setTimeout(showStatements, delayShow);
                    //
                    //     $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                    //     $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function(){
                    //         if (graphInteraction) {
                    //             clearTimeout(inactiveTimeout);
                    //             inactiveTimeout = setTimeout(showStatements, delayShow);
                    //         }
                    //     });
                    //
                    //
                    // }

                }

              }

              // This is just to reset node drag parameter
              sigma_dragged = 0;


            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && pinnedNodes.indexOf(e.data.node.originalLabel) < 0) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });



            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });

    

            

            // Forward from the graph function


            // Select previously selected nodes on the graph (from LocalStorage) or passed through parameters
            selectNodes();




        }
);



// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});


// TODO if the nodes are deleted, we call community detection twice. Fix that.

function selectNodes() {
    var selected_keywords = getUrlVars()["keywords"];
    if (localStorage.getItem("selections")) {

            var saved_selections = JSON.parse(localStorage.getItem("selections"));

            if (saved_selections[window.location.href]) {
                
                deletedNodes = saved_selections[window.location.href].stopnodes;
                pinnedNodes = saved_selections[window.location.href].pinnednodes;

                if (deletedNodes.length > 0) {
                    socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                    if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                    }
                }

            }
            else if (interpret) {
                console.log(saved_selections);
                for (var boom in saved_selections) {
                    if (boom.indexOf('/'+addcontext+'/') > -1) {
                    deletedNodes = saved_selections[boom].stopnodes;
                    pinnedNodes = saved_selections[boom].pinnednodes;
                    console.log(deletedNodes);
                    console.log(pinnedNodes);
                    if (deletedNodes.length > 0) {
                        socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                    }
                    else {
                        if (pinnedNodes.length > 0) {
                        filter_statements(pinnedNodes);
                        }
                    }
                    }
                }
            }
            else if (selected_keywords && selected_keywords.length > 0) {
                
                pinnedNodes = selected_keywords.split("+");


                if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                }


            }

            }
            // TODO clear that
            else if (selected_keywords && selected_keywords.length > 0) {
               
                pinnedNodes = selected_keywords.split("+");

                if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                }


            }
}


</script>