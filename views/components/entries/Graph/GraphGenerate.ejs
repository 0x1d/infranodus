<script>

function GraphFactory(){
                
        // Variables that contain all the current nodes (for easier search)
        let nodeNames = [];
        let nodeIDs = {}; // maps names (key) to IDs (values)
        let nodeIDs_rev = {}; // maps IDs (key) to names (values)
    
        // Variables that contain only the original set
        let origNodeIDs = {};
        let origNodeIDs_rev = {};

        // Variabls that contain the edges
        let edgesDB = [];
        let nodesDB = [];

        // These are the nodes that are selected
        let pinnedNodes = [];

        // These are the nodes that were selected but not found (so gray pinnedNodes)
        let notFoundNodes = [];

        // These are selected nodes for community detection (so that they're not colored)
        let selectedNodes = [];

        // These are the nodes that are currently in the stoplist
        let stopNodes = [];

        // Create statement-node index for filtering
        let nodesOfStatement = {};

        // How many nodes and edges added per iteration
        let nodesAdded = [];
        let edgesAdded = [];

        this.addNode = function(name, id, n) {
            nodeIDs[name] = id;
            nodeIDs_rev[id] = name;
            nodeNames.push(name);
            if (n) {
                nodesDB.push(n);
                origNodeIDs[n.originalLabel] = n.id;
                origNodeIDs_rev[n.id] = n.originalLabel;
            }
            return true;
        }
        this.existNode = function(name) {
            if (nodeIDs[name]) {
                return true;
            }
            else {
                return false;
            }
        }
        this.addEdge = function(e) {
            edgesDB.push(e);
            return true;
        }
        this.removeNode = function(name) {
            let nodeID = nodeIDs[name];
            delete nodeIDs[name];
            delete nodeIDs_rev[nodeID];
            nodeNames.splice(nodeNames.indexOf(name),1);
            return true;
        }
        this.deleteNodes = function(nodes) {
            for (let i in nodes) {
                this.addToStopNodes(nodes[i]);
                this.removeNode(nodes[i]);
                this.removeFromNotFoundNodes(nodes[i]);
                this.removeFromSelectedNodes(nodes[i]);
            }
            // If we are deleting the nodes, we transform all the pinned ones, so they can be removed too
            this.initPinnedNodes([]);
            // this.updateGraphNodes(nodeIDs_rev);
            this.deleteGraphNodes(this.getStopNodes());
            return true;
        }
        this.addDeletedNode = function(node) {
            this.removeFromStopNodes(node);
            this.addNode(node, origNodeIDs[node]);
            this.initPinnedNodes(pinnedNodes);
            let nodesToAdd = [];
            nodesToAdd.push(node);
            this.addDeletedGraphNodes(nodesToAdd);
            return true;

        }
        this.addNewNodes = function(nodes, edges, statement) {
            console.log('addnewnodes')
            console.log(statement)
            
            let nodesToAdd = [];
            let edgesToAdd = [];
            for (let node in nodes) {
                if (this.existNode(nodes[node].label) == false) {
                    this.addNode(nodes[node].label, nodes[node].id, nodes[node]);
                    nodesToAdd.push(nodes[node]);
                    nodesAdded.push(nodes[node]);
                }
            }
            if (statement) {
                for (let edge in edges) {
                    if (edges[edge].statement_id == statement) {
                        edgesToAdd.push(edges[edge]);
                        edgesAdded.push(edges[edge]);
                    }
                }
            }
            console.log(edgesToAdd);
            this.addGraphNodesEdges(nodesToAdd, edgesToAdd);
            return true;
        }
        this.getNodeIDs = function() {
            return nodeIDs;
        }
        this.getOrigNodes = function() {
            return nodesDB;
        }
        this.getOrigNodeIDs = function() {
            return origNodeIDs;
        }
        this.getOrigNodeIDsRev = function() {
            return origNodeIDs_rev;
        }
        this.getNodeID = function(name) {
            return nodeIDs[name];
        }
        this.getNodeIDsRev = function() {
            return nodeIDs_rev;
        }

        this.getNodeNames = function() {
            return nodeNames;
        }

        this.getEdges = function() {
            return edgesDB;
        }


        this.deleteGraphNodes = function(nodesToDelete) {
             
             // Update the graph nodes (delete or add)
             graph().deleteNodes(nodesToDelete);
             graph().updateMetrics();
       
         }

         this.addDeletedGraphNodes = function(nodesToAdd) {
             // Update the graph nodes (delete or add)
             graph().addDeletedNodes(nodesToAdd, graph().updateMetrics);
       
         }

         this.addGraphNodesEdges = function(nodesToAdd, edgesToAdd) {
             
             // Adding the new nodes
             graph().addNodesEdges(nodesToAdd, edgesToAdd, graph().updateMetrics);
       
         }
  

        this.initPinnedNodes = function(nodes) {
            if (nodes) {
                pinnedNodes = nodes;
            }
            else {
                pinnedNodes = [];
            }
            
            // Select the pinned nodes on the graph and the adjacent ones 
            filter_graph(pinnedNodes);

            // Add tags to the graph
            graphTags().update();

            // Perform filter statements function on the nodes selected
            entries().filter();

            // Add search terms into the top graph search form
            nodeInputField().update(pinnedNodes.concat(notFoundNodes));

            // Add search terms into the bottom entry add field
            addEntryForm().update(pinnedNodes.concat(notFoundNodes));       

        }

        // TODO write initiatilization for the delete nodes

        this.checkIfPinned = function(node) {
            if (pinnedNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        this.addToPinnedNodes = function(name) {
            pinnedNodes.push(name);
            this.initPinnedNodes(pinnedNodes);
            return true;
        }
        this.removeFromPinnedNodes = function(name) {
            pinnedNodes.splice(pinnedNodes.indexOf(name),1);
            this.initPinnedNodes(pinnedNodes);
            return true;
        }
        this.getPinnedNodes = function() {
            return pinnedNodes;
        }
        this.getPinnedNode = function(position) {
            return pinnedNodes[position];
        }
        this.getLastPinnedNode = function() {
            return pinnedNodes[pinnedNodes.length - 1];
        }
        this.existPinnedNodes = function() {
            if (pinnedNodes && pinnedNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.updateNotFoundNodes = function(nodes) {
            if (!nodes) {
                notFoundNodes = [];
            }
            else {
                notFoundNodes = nodes;
                graphTags().update();
            }
            // Add tags to the graph
            return true;
        }
        this.addToNotFoundNodes = function(name) {
            notFoundNodes.push(name);
            return true;
        }
        this.removeFromNotFoundNodes = function(name) {
            notFoundNodes.splice(notFoundNodes.indexOf(name),1);
            return true;
        }
        this.getNotFoundNodes = function() {
            return notFoundNodes;
        }
        this.existNotFoundNodes = function() {
            if (notFoundNodes && notFoundNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.addToSelectedNodes = function(name) {
            selectedNodes.push(name);
            return true;
        }
        this.removeFromSelectedNodes = function(name) {
            selectedNodes.splice(selectedNodes.indexOf(name),1);
            return true;
        }
        this.getSelectedNodes = function() {
            return selectedNodes;
        }
        this.updateSelectedNodes = function(nodes) {
            selectedNodes = nodes;
            return true;
        }
        this.checkIfSelected = function(node) {
            if (selectedNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }

        this.addToStopNodes = function(name) {
            stopNodes.push(name);
            return true;
        }
        this.removeFromStopNodes = function(name) {
            stopNodes.splice(stopNodes.indexOf(name),1);
            return true;
        }
        this.getStopNodes = function() {
            return stopNodes;
        }
        this.checkIfStopNode = function(node) {
            if (stopNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        this.existStopNodes = function() {
            if (stopNodes && stopNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.addNodeToStatement = function(statement, node) {
            if (!nodesOfStatement[statement]) {
                nodesOfStatement[statement] = [];
            }
            nodesOfStatement[statement].push(node);
            return true;
        }
        this.getNodesOfStatement = function(statement) {
            if (statement) {
                return nodesOfStatement[statement];
            }
        }
        this.existNodesOfStatement = function(statement) {
            if (nodesOfStatement[statement]) {
                return true;
            }
            else {
                return false;
            }
        }
        this.existNodeInStatement = function(statement, node) {
            if (nodesOfStatement[statement].indexOf(node) >= 0) {
                return true;
            }
            else {
                return false;
            }
            
        }
        this.removeNodesFromStatement = function(statement) {
            if (nodesOfStatement[statement]) {
                nodesOfStatement[statement] = []
                return true;
            }
            else {
                return false;
            }
        }
    

}

let graphFactory = new GraphFactory();


sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: minnodesize,
                maxNodeSize: maxnodesize,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: in_label_threshold,
                defaultLabelColor: default_label_color
            }
        },
        function(sigma) {                
            
            graph().initNodesEdges(graph().updateMetrics);
  

            // Initialize autofill for hashtags and contexts
            autofill(graphFactory.getNodeNames(),contextNames);


            if (document.getElementById('context').value) {
                current_context_field = [document.getElementById('context').value];
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:last").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help' || !lastcontexts[0]) {
                    current_context_field = ['private'];
                    $("#addedContexts").val('private');
                }

                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            if (background == 'dark') { $('#tagInputBox').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'}); }
            // Do ForceAtlasLayout

           
            // Drag nodes function initiated, so we can drag nodes

            dragNodes();

      


          

            // TODO make it possible for collaboration also

            if (addcontext && interpret) {

              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

              // $('.entry').each(function() {
              //   if ($(this).is(':hidden')) {
              //     $(this).remove();
              //   }
              // });



            }


            // What happens when we click analytics pane

            $('#analyticsbutton').click(function(){
                      // Process logic and remember settings
                     $('#analytics').toggle('slide', function(){
                       if ($('#analytics').is(":visible")) {
                         localStorage.setItem('analytics', 1);
                         $('#analyticsbutton').addClass('analytics-on');
                         $('#analyticscaption').hide();

                       }
                       else {
                         localStorage.setItem('analytics', 0);
                         $('#analyticsbutton').removeClass('analytics-on')
                         $('#analyticscaption').show();
                       }
                     });

            });
            

            $('#analytics').on('swipedown',function(){$('#analyticsbutton').trigger('click');});

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {
                
              if (!sigma_dragged) {
                
                // A node was clicked, so we assume there was a meaningful graph interaction
                graphInteraction = 1;

                var nodeLabel = e.data.node.originalLabel;

                // TODO to check that
                if (interpret) {
                  $('.entry').show();
                }

                // If we click on the context node, just bring us to that context
                if (nodeLabel.substr(0,9) == 'context: ') {
                    window.open('/' + current_user + '/' + nodeLabel.substr(9,nodeLabel.length) + '<% if (!perceivername) { %>/edit<% } %>',"_self");
                }
                else {

                    // Is the node pinned?
                    if (graphFactory.checkIfPinned(nodeLabel) == false) {
                        // Add to pinned and launch the whole filtering machinery
                        graphFactory.addToPinnedNodes(nodeLabel);
                    }
                    else {   
                        graphFactory.removeFromPinnedNodes(nodeLabel);
                                              
                    }

                    // Let's send an event to all the collaborators in the chatroom
                   // socket.emit('node click', {pinnedNodes: graphFactory.getPinnedNodes(), splicedNodes: splicedNodes, nodeLabel: nodeLabel});
           

                    // If the window is wide enough to show the menu AND div with statements is not visible

                    var isHidden = $("#statements").is(":hidden");

                    // if (isHidden) {
                    //
                    //     var delayShow = 6000;
                    //
                    //     clearTimeout(inactiveTimeout);
                    //     inactiveTimeout = setTimeout(showStatements, delayShow);
                    //
                    //     $('#graph-container').unbind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop');
                    //     $('#graph-container').bind('mousemove orientationchange scroll swipe tap swipeleft swiperight scrolltop', function(){
                    //         if (graphInteraction) {
                    //             clearTimeout(inactiveTimeout);
                    //             inactiveTimeout = setTimeout(showStatements, delayShow);
                    //         }
                    //     });
                    //
                    //
                    // }

                }

              }

              // This is just to reset node drag parameter
              sigma_dragged = 0;


            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && graphFactory.checkIfPinned(e.data.node.originalLabel) == false) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });



            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });

    

            

            // Forward from the graph function


            // Select previously selected nodes on the graph (from LocalStorage) or passed through parameters
            selectNodes();




        }
);



// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});


// TODO if the nodes are deleted, we call community detection twice. Fix that.

function selectNodes() {
    var selected_keywords = getUrlVars()["keywords"];
    if (localStorage.getItem("selections")) {

            var saved_selections = JSON.parse(localStorage.getItem("selections"));

            if (saved_selections[window.location.href]) {
                
                deletedNodes = saved_selections[window.location.href].stopnodes;
                graphFactory.initPinnedNodes(saved_selections[window.location.href].pinnednodes);
                
                if (deletedNodes.length > 0) {
                    socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                    if (graphFactory.getPinnedNodes().length > 0) {
                        filter_statements(graphFactory.getPinnedNodes());
                    }
                }

            }
            else if (interpret) {
                console.log(saved_selections);
                for (var boom in saved_selections) {
                    if (boom.indexOf('/'+addcontext+'/') > -1) {
                    deletedNodes = saved_selections[boom].stopnodes;
                    pinnedNodes = saved_selections[boom].pinnednodes;
                    console.log(deletedNodes);
                    console.log(pinnedNodes);
                    if (deletedNodes.length > 0) {
                        socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                    }
                    else {
                        if (pinnedNodes.length > 0) {
                        filter_statements(pinnedNodes);
                        }
                    }
                    }
                }
            }
            else if (selected_keywords && selected_keywords.length > 0) {
                
                pinnedNodes = selected_keywords.split("+");


                if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                }


            }

            }
            // TODO clear that
            else if (selected_keywords && selected_keywords.length > 0) {
               
                pinnedNodes = selected_keywords.split("+");

                if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                }


            }
}






</script>