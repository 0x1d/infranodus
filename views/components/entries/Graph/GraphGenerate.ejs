<script>

function GraphFactory(){
                
        // Variables that contain all the current nodes (for easier search)
        let nodeNames = [];
        let nodeIDs = {}; // maps names (key) to IDs (values)
        let nodeIDs_rev = {}; // maps IDs (key) to names (values)
    
        // Variables that contain only the original set
        let origNodeIDs = {};
        let origNodeIDs_rev = {};

        // Variabls that contain the edges
        let edgesDB = [];
        let nodesDB = [];

        // These are the nodes that are selected
        let pinnedNodes = [];

        // These are the nodes that were selected but not found (so gray pinnedNodes)
        let notFoundNodes = [];

        // These are selected nodes for community detection (so that they're not colored)
        let selectedNodes = [];

        // These are the nodes that are currently in the stoplist
        let stopNodes = [];

        // Create statement-node index for filtering
        let nodesOfStatement = {};

        // How many nodes and edges added per iteration
        let nodesAdded = [];
        let edgesAdded = [];

        this.addNode = function(name, id, n) {
            nodeIDs[name] = id;
            nodeIDs_rev[id] = name;
            nodeNames.push(name);
            if (n) {
                nodesDB.push(n);
                origNodeIDs[n.originalLabel] = n.id;
                origNodeIDs_rev[n.id] = n.originalLabel;
            }
            return true;
        }
        this.existNode = function(name) {
            if (nodeIDs[name]) {
                return true;
            }
            else {
                return false;
            }
        }
        this.addEdge = function(e) {
            edgesDB.push(e);
            return true;
        }
        this.removeNode = function(name) {
            let nodeID = nodeIDs[name];
            delete nodeIDs[name];
            delete nodeIDs_rev[nodeID];
            nodeNames.splice(nodeNames.indexOf(name),1);
            return true;
        }
        this.deleteNodes = function(nodes) {
            for (let i in nodes) {
                this.addToStopNodes(nodes[i]);
                this.removeNode(nodes[i]);
                this.removeFromNotFoundNodes(nodes[i]);
                this.removeFromSelectedNodes(nodes[i]);
            }
            // If we are deleting the nodes, we transform all the pinned ones, so they can be removed too
            this.initPinnedNodes([]);
            // this.updateGraphNodes(nodeIDs_rev);
            this.deleteGraphNodes(this.getStopNodes());
            return true;
        }
        this.addDeletedNode = function(node) {
            this.removeFromStopNodes(node);
            this.addNode(node, origNodeIDs[node]);
            this.initPinnedNodes(pinnedNodes);
            let nodesToAdd = [];
            nodesToAdd.push(node);
            this.addDeletedGraphNodes(nodesToAdd);
            return true;

        }
        this.addNewNodes = function(nodes, edges, statement) {
            
            let nodesToAdd = [];
            let edgesToAdd = [];
            for (let node in nodes) {
                if (this.existNode(nodes[node].label) == false) {
                    this.addNode(nodes[node].label, nodes[node].id, nodes[node]);
                    nodesToAdd.push(nodes[node]);
                    nodesAdded.push(nodes[node]);
                }
            }
            if (statement) {
                for (let edge in edges) {
                    if (edges[edge].statement_id == statement) {
                        edgesToAdd.push(edges[edge]);
                        edgesAdded.push(edges[edge]);
                    }
                }
            }
            this.addGraphNodesEdges(nodesToAdd, edgesToAdd);
            return true;
        }
        this.getNodeIDs = function() {
            return nodeIDs;
        }
        this.getOrigNodes = function() {
            return nodesDB;
        }
        this.getOrigNodeIDs = function() {
            return origNodeIDs;
        }
        this.getOrigNodeIDsRev = function() {
            return origNodeIDs_rev;
        }
        this.getNodeID = function(name) {
            return nodeIDs[name];
        }
        this.getNodeIDsRev = function() {
            return nodeIDs_rev;
        }

        this.getNodeNames = function() {
            return nodeNames;
        }

        this.getEdges = function() {
            return edgesDB;
        }


        this.deleteGraphNodes = function(nodesToDelete) {
             
             // Update the graph nodes (delete or add)
             graph().deleteNodes(nodesToDelete, graph().updateMetrics);
       
         }

         this.addDeletedGraphNodes = function(nodesToAdd) {
             // Update the graph nodes (delete or add)
             graph().addDeletedNodes(nodesToAdd, graph().updateMetrics);
       
         }

         this.addGraphNodesEdges = function(nodesToAdd, edgesToAdd) {
             
             // Adding the new nodes
             graph().addNodesEdges(nodesToAdd, edgesToAdd, graph().updateMetrics);
       
         }
  

        this.initPinnedNodes = function(nodes) {
            if (nodes) {
                pinnedNodes = nodes;
            }
            else {
                pinnedNodes = [];
            }
            
            // Select the pinned nodes on the graph and the adjacent ones 
            filter_graph(pinnedNodes);

            // Add tags to the graph
            graphTags().update();

            // Perform filter statements function on the nodes selected
            entries().filter();

            // Save to local storage
            this.saveSelections();

            // Add search terms into the top graph search form
            nodeInputField().update(pinnedNodes.concat(notFoundNodes));

            // Add search terms into the bottom entry add field
            addEntryForm().update(pinnedNodes.concat(notFoundNodes));       

        }

        // TODO write initiatilization for the delete nodes

        this.checkIfPinned = function(node) {
            if (pinnedNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        this.addToPinnedNodes = function(name) {
            pinnedNodes.push(name);
            this.initPinnedNodes(pinnedNodes);
            return true;
        }
        this.removeFromPinnedNodes = function(name) {
            pinnedNodes.splice(pinnedNodes.indexOf(name),1);
            this.initPinnedNodes(pinnedNodes);
            return true;
        }
        this.getPinnedNodes = function() {
            return pinnedNodes;
        }
        this.getPinnedNode = function(position) {
            return pinnedNodes[position];
        }
        this.getLastPinnedNode = function() {
            return pinnedNodes[pinnedNodes.length - 1];
        }
        this.existPinnedNodes = function() {
            if (pinnedNodes && pinnedNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.updateNotFoundNodes = function(nodes) {
            if (!nodes) {
                notFoundNodes = [];
            }
            else {
                notFoundNodes = nodes;
                graphTags().update();
            }
            // Add tags to the graph
            return true;
        }
        this.addToNotFoundNodes = function(name) {
            notFoundNodes.push(name);
            return true;
        }
        this.removeFromNotFoundNodes = function(name) {
            notFoundNodes.splice(notFoundNodes.indexOf(name),1);
            return true;
        }
        this.getNotFoundNodes = function() {
            return notFoundNodes;
        }
        this.existNotFoundNodes = function() {
            if (notFoundNodes && notFoundNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.addToSelectedNodes = function(name) {
            selectedNodes.push(name);
            return true;
        }
        this.removeFromSelectedNodes = function(name) {
            selectedNodes.splice(selectedNodes.indexOf(name),1);
            return true;
        }
        this.getSelectedNodes = function() {
            return selectedNodes;
        }
        this.updateSelectedNodes = function(nodes) {
            selectedNodes = nodes;
            return true;
        }
        this.checkIfSelected = function(node) {
            if (selectedNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }

        this.addToStopNodes = function(name) {
            stopNodes.push(name);
            return true;
        }
        this.removeFromStopNodes = function(name) {
            stopNodes.splice(stopNodes.indexOf(name),1);
            return true;
        }
        this.getStopNodes = function() {
            return stopNodes;
        }
        this.checkIfStopNode = function(node) {
            if (stopNodes.indexOf(node) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        this.existStopNodes = function() {
            if (stopNodes && stopNodes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        }

        this.addNodeToStatement = function(statement, node) {
            if (!nodesOfStatement[statement]) {
                nodesOfStatement[statement] = [];
            }
            nodesOfStatement[statement].push(node);
            return true;
        }
        this.getNodesOfStatement = function(statement) {
            if (statement) {
                return nodesOfStatement[statement];
            }
        }
        this.getAllNodesOfStatement = function() {
           
            return nodesOfStatement
           
        }
        this.existNodesOfStatement = function(statement) {
            if (nodesOfStatement[statement]) {
                return true;
            }
            else {
                return false;
            }
        }
        this.existNodeInStatement = function(statement, node) {
            if (nodesOfStatement[statement].indexOf(node) >= 0) {
                return true;
            }
            else {
                return false;
            }
            
        }
        this.removeNodesFromStatement = function(statement) {
            if (nodesOfStatement[statement]) {
                nodesOfStatement[statement] = []
                return true;
            }
            else {
                return false;
            }
        }

        this.saveSelections = function() {

            // Save all the selected nodes into the localStorage
            if (localStorage.getItem("selections")) {
                var localstore = JSON.parse(localStorage.getItem("selections"));
            }
            else {
                var localstore = {};
            }

            var localstore_cell = {};

            localstore_cell.stopnodes = this.getStopNodes();
            localstore_cell.pinnednodes = this.getPinnedNodes();

            if (this.existStopNodes == false && this.existPinnedNodes == false) {
                delete localstore[window.location.href]
            }
            else {
                localstore[window.location.href] = localstore_cell;
            }

            localStorage.setItem("selections",JSON.stringify(localstore));

        }

        this.getSelections = function() {

            let selected_keywords = getUrlVars()["keywords"];

            if (localStorage.getItem("selections")) {

                let saved_selections = JSON.parse(localStorage.getItem("selections"));

                let deletedNodes = saved_selections[window.location.href].stopnodes;
                let pinnedNodes = saved_selections[window.location.href].pinnednodes;

                // Do we have any saved selections stopNodes or pinnedNodes for this URL?
                if (saved_selections[window.location.href]) {
                                       
                    this.deleteNodes(deletedNodes);
                    this.initPinnedNodes(pinnedNodes);

                }
                else if (interpret) {
                    
                    // In case we're on the interpret or add context field, we might still want to load the original selections
                    
                    for (var url in saved_selections) {
                        if (url.indexOf('/'+addcontext+'/') > -1) {
                            let deletedNodes = saved_selections[url].stopnodes;
                            let pinnedNodes = saved_selections[url].pinnednodes;
                            if (deletedNodes.length > 0) {
                                this.deleteNodes(deletedNodes);
                            }
                            else {
                                if (pinnedNodes.length > 0) {
                                    this.initPinnedNodes(pinnedNodes);
                                }
                            }
                        }
                    }
                }
                else if (selected_keywords && selected_keywords.length > 0) {
                    
                    let pinnedNodes = selected_keywords.split("+");


                    if (pinnedNodes.length > 0) {
                        this.initPinnedNodes(pinnedNodes);
                    }


                }

            }
            // TODO clear that
            else if (selected_keywords && selected_keywords.length > 0) {
            
                let pinnedNodes = selected_keywords.split("+");

                if (pinnedNodes.length > 0) {
                    this.initPinnedNodes(pinnedNodes);
                }


            }
    }
    

}

let graphFactory = new GraphFactory();


sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: minnodesize,
                maxNodeSize: maxnodesize,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: in_label_threshold,
                defaultLabelColor: default_label_color
            }
        },
        function(sigma) {                
 
            // Add some stats for each node and edge and launch BC and community detection analytics algorithms
            graph().initNodesEdges(graph().updateMetrics);           
  
            // Initialize autofill for hashtags and contexts - only after the graph is loaded
            autofill(graphFactory.getNodeNames(),contextNames);
           
            // Drag nodes function initiated, so we can drag nodes
            graph().dragNodes();

            // Remove the entries that belong to the addcontext parameter (we need a graph for that data, that's why it's here)
            entries().removeAddContext();

            // Select the neighbor nodes when a node is clicked
            sigmaGraph().clickNode();

            // Select the node's label when we're over it and deselect when we're not
            sigmaGraph().highlightNode();
           

        }
);









</script>