<script>

      // Community Detection Function

      function communityDetect (lougraph, grgraph, callback) {
 
                let node_data = lougraph.node_data;
                let edge_data = lougraph.edge_data;

                let nodeIDs_rev = graphFactory.getNodeIDsRev();
                let nodeIDs = graphFactory.getNodeIDs();

                let totaledgescount = graphFactory.getStats('edgesUndirected');

                if (node_data.length > 0 && edge_data.length > 0) {

                    // Calculate Louvain community and modularity

                    let community = jLouvain().nodes(node_data).edges(edge_data);
                    let community_assignment_result = community();
                    let node_ids = Object.keys(community_assignment_result['communities']);
                    let com_ass = {};

                    for (let key in community_assignment_result['communities']) {
                        com_ass[nodeIDs_rev[key]] = community_assignment_result['communities'][key];
                    }
                    
                    console.log('Resulting Louvain Community Data', com_ass);
                    console.log('Final Louvain Modularity', community_assignment_result['modularity']);

                    // Get the graph back from Graphology with community attribute for nodes
                    let newgraph = louvain_process(grgraph);

                    // Assign community number to every node
                    let louvain_communities = {};
                    let graphology_communities = [];

                    grgraph.forEachNode((node, attributes) => {
                        let tempo_comm = grgraph.getNodeAttribute(node,'community');
                        if (graphology_communities.indexOf(tempo_comm) == -1) {
                            graphology_communities.push(tempo_comm);
                        }
                        louvain_communities[node] = graphology_communities.indexOf(tempo_comm);
                    });

                    // Let's calculate modularity for Graphology
                    let modularity_score = louvain_modularity(newgraph);

                    let com_ass2 = {};
                    for (var key in louvain_communities) {
                        com_ass2[nodeIDs_rev[key]] = louvain_communities[key];
                    }
                    console.log('Resulting Graphology Community Data', com_ass2);
                    console.log('Graphology modularity score:', modularity_score);

                    node_ids = Object.keys(louvain_communities);

                    let max_community_number = 0;

                    let top_communities = [];

                    let all_communities = [];

                    let totalnodescount = 0

                    // We now add the new community integer ID to all the nodes in the Sigma graph

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                        if (!n.url) {
                            n.community = louvain_communities[n.id];

                            graphFactory.saveCommunityOfNode(n);

                            var commune = n.community;
                            if (!top_communities[commune]) {
                                top_communities[commune] = [];
                                all_communities[commune] = {id: commune, length: 0, nodes: []};
                            }
                            

                            top_communities[commune].push({id: n.id, name: n.originalLabel, degree: sigma.instances(0).graph.degree(n.id), bc: bc_nodes_map[n.id]});
                            all_communities[commune].nodes.push({id: n.id, name: n.originalLabel, degree: sigma.instances(0).graph.degree(n.id), bc: bc_nodes_map[n.id]});
                            all_communities[commune].length += 1;

                            // number of communities
                            max_community_number = max_community_number < louvain_communities[n.id] ? louvain_communities[n.id]: max_community_number;

                            // number of nodes
                            totalnodescount += 1;
                        }

                    });

                    console.log('Total communities: ');
                    console.log(parseInt(max_community_number + 1));
                    
                    // Sort (and converts to array)
                   all_communities = _.sortBy(all_communities,'length').reverse();

                    // Sort all the nodes in every community by BC or degree influence

                    for (let j = 0; j < all_communities.length; j++) {
                        if (most_influential == 'bc2') {
                           all_communities[j].nodes = _.sortBy(all_communities[j].nodes,'bc').reverse();
                        }
                        else {
                           all_communities[j].nodes = _.sortBy(all_communities[j].nodes,'degree').reverse();
                        }
                    }


                    // Save into the global parameter, to be extracted later
                    graphFactory.saveAllCommunities(all_communities);

                    // How many communities will we show to the user
                    let coms_to_show = 4;                    
                    if (all_communities.length < coms_to_show) {
                        coms_to_show = all_communities.length;
                    }

                    // Cut out the first N nodes from every community and get the top N communities
                    let nodes_to_cut = 3;

                    let topN_communities = graphFactory.getAllCommunities(coms_to_show, nodes_to_cut);

                    // TODO might need to delete the topp_communities and most_inf_comm_nodes
                    let topp_communities = topN_communities;

                    // Give it to the global
                    most_inf_comm_nodes = topp_communities;
                    
                    // Populate Analytics Panel with community information
                    analyticsPanel.populateCommunities(topN_communities);

                    // Create insight clusters from the community nodes
                    graphFactory.createInsightClusters(topN_communities);

                    // Populate Analytics Panel with insight recommendation

                    let insightClusters = graphFactory.getInsightClusters();

                    analyticsPanel.populateRecommendation(insightClusters);

                    // Populate entries field
                    addEntryForm().populateRecommendation(insightClusters);

                    // Get the top BC nodes
                    // TODO implement Jenks-Breaks to calculate the optimal number of nodes shown
                    let topInfluenceNodes = graphFactory.getTopBCNodes(4);

                    console.log('Top betweenness centrality nnodes:')
                    console.log(topInfluenceNodes);

                    most_inf_nodes = topInfluenceNodes;

                    analyticsPanel.populateInfluential(topInfluenceNodes);

                    // Send the default search setting to the Global Search
                    // TODO take into account the polysingularity index
                    globalSearch.populateGlobalSearch(topInfluenceNodes);

                    // Generate a nice fixed patterns for the communities
                    let palette = generatePalette(graphPalette, max_community_number, background);

                    // Color the topic boxes in the Analytics panel
                    analyticsPanel.colorTopics(palette);

                    // Color the nodes in the graph
                    graph().colorNodesCommunities(palette);
                    

                    // Set the number of nodes in the first and second communities
                    graphFactory.setStats('FirstComNodes',all_communities[0].length);
                    let nodesfirstcom = graphFactory.getStats('FirstComNodes');
                    
                    if (all_communities[1]) {
                        graphFactory.setStats('SecondComNodes',all_communities[1].length);
                        let nodessecondcom = graphFactory.getStats('SecondComNodes');
                    }

                    // Save total nodes number
                    graphFactory.setStats('TotalNodes', totalnodescount);

                    global_totalnodes = totalnodescount;


                    // Color the nodes in the graph to communities colors
                    // TODO this function also counts addcontext nodes, should be taken out
                    graph().colorNodesCommunities(palette);


                    // Number of nodes in the top topic

                    var nodesintoptopic = 0;

                    nodesintoptopic = ((((nodesfirstcom) / totalnodescount).toFixed(2))*100).toFixed(0);

                    nodesintoptopic = parseInt(nodesintoptopic);

                    graphFactory.setStats('NodesInTopTopic', nodesintoptopic);


                    // Graph density (not weighed)

                    let graph_density;

                    if ((totalnodescount - 1) == 0 || totalnodescount == 0) { graph_density = 0 } else {
                        graph_density  = ((totaledgescount) / ((totalnodescount)*(totalnodescount - 1))).toFixed(3);
                    }

                    graph_density = parseFloat(graph_density);

                    graphFactory.setStats('GraphDensity', graph_density);


                    // Average graph degree

                    let average_degree = (totaledgescount / totalnodescount).toFixed(2);

                    average_degree = parseFloat(average_degree);

                    graphFactory.setStats('AverageDegree', average_degree);


                    // Percentage of nodes in the top connected component of the graph (giant component)

                    top_components = _.sortBy(top_components, 'length').reverse();

                    var num_nodes_component = ((top_components[0].nodes().length / totalnodescount).toFixed(2)*100).toFixed(0);

                    num_nodes_component = parseFloat(num_nodes_component);

                    graphFactory.setStats('NodesInTopComponent', num_nodes_component);
   

                    // Let's calculate the graph diversity (polysingulairty) score
                    var diversity_score = 0;
             
                    // TODO add degree distribution to the indexOf maybe through entropy of degree by nodes

                    var bc_dist = [];

                    // For every top BC node
                    console.log("All the different communities in the graph:")
                    console.log(all_communities);


                    for (var bcid in topInfluenceNodes) {

                        if (topInfluenceNodes[bcid].bc > 0) {

                            for (var comid in all_communities) {
                                // Open first community

                                    //  For every node in that community

                                        for (var ccnodes in all_communities[comid].nodes) {

                                            // If the node's ID equals to the current BC node, add the marker
                                            if (all_communities[comid].nodes[ccnodes].id == topInfluenceNodes[bcid].key) {
                                                bc_dist.push(all_communities[comid].id);
                                            }

                                        }
                            }
                        }

                    }

                    console.log('Distribution of top nodes across all the communities: ')
                    console.log(bc_dist);

                    var bc_dist_string = bc_dist.join('');

                    // Max entropy for a set of 4 elements is 2

                    var bc_entropy = shannon(bc_dist_string);

                    bc_entropy = parseFloat(bc_entropy);

                    graphFactory.setStats('BCEntropy', bc_entropy);

                    // TODO fix bug for two-digit communities

                    console.log('BC Entropy: ' + bc_entropy);



                    // Calculate polysingularity score
                    diversity_score = polysingularity().calculateScore(modularity_score, nodesintoptopic, bc_entropy, topInfluenceNodes, num_nodes_component);
                    
                    // Set global parameter
                    polysingularity_score = diversity_score;

                    graphFactory.setStats('PolysingularityScore', diversity_score);

                    

                    // How influential nodes are dispersed among the communities
                    let influence_dispersal = ((bc_entropy/2).toFixed(1)*100).toFixed(0);

                    influence_dispersal = parseFloat(influence_dispersal);

                    graphFactory.setStats('InfluenceDispersal', influence_dispersal);


                    // How many communities are there
                    let communities_number = all_communities.length;

                    graphFactory.setStats('NumberOfCommunities', communities_number);


                    // How many connected components are there in the graph?
                    let top_components_length = top_components.length;

                    graphFactory.setStats('NumberOfComponents', top_components_length);


                    // Modularity of the graph 
                    modularity_score = modularity_score.toFixed(2);

                    modularity_score = parseFloat(modularity_score);

                    graphFactory.setStats('ModularityScore', modularity_score);

                    
                    // Populate Analytics Panel data

                    analyticsPanel.populateStats(totalnodescount, graph_density, average_degree, diversity_score, modularity_score, nodesintoptopic, communities_number, num_nodes_component, top_components_length, influence_dispersal);


                    // TODO addcontext move
                    // if (addcontextcount > 0) {

                    //     if (addcontext_nodes.length > 0) {
                    //         var addcontext_text = '<div class="headline">In ' + addcontext + ' but not in ' + current_context + ':</div> ';
                    //         if (addcontext_nodes.length > 4) {
                    //             addcontext_nodes = addcontext_nodes.slice(0, 4);
                    //         }
                    //         for (var nnn = 0; nnn < addcontext_nodes.length; nnn++) {
                    //             addcontext_text += '<a href="#" class="top_nodes">' + addcontext_nodes[nnn].label + '</a> - ';
                    //         }
                    //         addcontext_text = addcontext_text.slice(0, -3);
                    //         addcontext_text += '<br><br>'
                    //         diversitytext = addcontext_text + diversitytext;
                    //     }

                    //     var addindex = ((((totalnodescount - addcontextcount) / totalnodescount).toFixed(2))*100).toFixed(0);
                    //     diversitytext += 'context ' + addcontext + ' uses ' + addindex + '% words from ' + current_context + ', ';

                    // }


                    // end nonempty community if clause

                    console.log(graphFactory.getAllStats());
                    
                }





                    var commClicked = [];

                    top_nodes_activate();





                    resetGraphButton().onClick(resetGraph);



                    callback();

                // communityDetect function ends here
    }




    function analyticsPanel() {
        return {
            removeSelections: function() {
            
            $('.community_node').each(function(){
                $(this).removeAttr('style');
            });

            console.log('removing');

            $('.top_nodes').each(function(){
                $(this).removeAttr('style');
            });
            
            }
        }
    }


    function resetGraphButton() {
        return {
            onClick: function(onClick){
                $('#resetgraph').on('click', onClick);
            }
        }
    }

    function top_nodes_activate() {
        $('.top_nodes').click(function(){
            var nodeLabel = $(this).text();


            if (pinnedNodes.indexOf(nodeLabel) < 0) {
                pinnedNodes.push(nodeLabel);
                $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
            }
            else {
                var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                if (pinnedIndex > -1) {
                    pinnedNodes.splice(pinnedIndex,1);
                    $(this).removeAttr('style');
                    $('.entry').fadeIn(400);
                }

            }

            // console.log("node clicked, now will filter for nodes " + pinnedNodes);
            socket.emit('node click', {pinnedNodes: pinnedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});


            // Now show / hide statements that have the search field

            filter_statements(pinnedNodes);
            return false;

        });

        var commClicked = [];

        $('.community_node').click(function(){

                var communityClicked = $(this).attr('community').toString();

                var nodeLabel = $(this).text();

                if (graphFactory.checkIfPinned(nodeLabel) == false) {
                    graphFactory.addToPinnedNodes(nodeLabel);
                    $(this).attr('style','color: #0089e0 !important; text-decoration: underline !important;');
                }
                else {
                    graphFactory.removeFromPinnedNodes(nodeLabel);
                    $(this).removeAttr('style');
                }




            //  socket.emit('node click', {pinnedNodes: pinnedNodes, splicedNodes: splicedNodes, nodeLabel: nodeLabel, pinnedIndex: pinnedIndex});
                // console.log(pinnedNodes);
                filter_statements(pinnedNodes, 'community');



                if (commClicked.indexOf(communityClicked) == -1) {
                    // console.log("the community clicked was not clicked before");


                    // sigma.instances(0).graph.edges().forEach(function(e) {
                    //
                    //     if (e.statement_id == keepStatementID) {
                    //         e.color = e.originalColor;
                    //     }
                    //     else {
                    //         e.color = '#ddd';
                    //     }
                    //
                    // });

                    // Specify which community is clicked
                    commClicked.push(communityClicked);


                    // Make only those nodes visible that belong to the community selected

                    sigma.instances(0).graph.nodes().forEach(function(n) {

                        if (commClicked.indexOf(n.community.toString()) > -1)  {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                            if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                            n.color = '#0089e0';
                            }
                        }
                        else {
                        n.color = deselected_nodes_color;
                        n.label = '';
                        }

                    });
                }

                else {
                // console.log("the community was clicked before");

                    if (pinnedNodes.length == 0) {
                        // sigma.instances(0).graph.edges().forEach(function(e) {
                        //     e.color = e.originalColor;
                        // });

                        commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);

                        // Make only those nodes visible that belong to the statement selected
                        sigma.instances(0).graph.nodes().forEach(function(n) {
                        if (commClicked.indexOf(n.community.toString()) < 0) {
                                if (commClicked.length == 0) {
                                    n.color = n.originalColor;
                                    n.label = n.originalLabel;
                                }
                                else {
                                    n.color = deselected_nodes_color;
                                    n.label = '';
                                }
                        }
                        });


                    }
                    else {
                        // We clicked on the community which is in the DB of clicked ones and We have some pinned nodes left

                        // Is the node clicked in the pinned nodes?
                        if (pinnedNodes.indexOf(nodeLabel) > -1) {
                            // console.log('in the pinned nodes')
                            sigma.instances(0).graph.nodes().forEach(function(n) {
                            if (commClicked.indexOf(n.community.toString()) > -1)  {
                                n.color = n.originalColor;
                                n.label = n.originalLabel;
                                if (n.originalLabel == nodeLabel && pinnedNodes.indexOf(n.originalLabel) > -1) {
                                    n.color = '#0089e0';
                                }
                            }
                            else {
                                n.color = deselected_nodes_color;
                                n.label = '';
                            }
                        });
                        }
                        // It is not in the pinneed nodes
                        else {
                        // console.log('not in the pinneed nodes')
                        // console.log(commClicked)
                        // console.log(pinnedNodes);

                        // is the last node of the community?
                        var islastnode = 0;
                        for (key in topp_communities) {
                            if (communityClicked == topp_communities[key].id) {
                            for (kkey in topp_communities[key].nodes) {
                                // console.log(topp_communities[key].nodes[kkey].name);
                                // console.log(pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name));
                                if (pinnedNodes.indexOf(topp_communities[key].nodes[kkey].name) > -1) {
                                islastnode = 1;
                                }

                            }
                            }
                        }
                        // console.log(islastnode);

                        if (!islastnode) {
                            commClicked.splice(commClicked.indexOf(communityClicked.toString()),1);
                        }
                        //console.log(pinnedNodes);

                        sigma.instances(0).graph.nodes().forEach(function(n) {
                            if (commClicked.indexOf(n.community.toString()) < 0) {
                                    if (commClicked.length == 0) {
                                    n.color = n.originalColor;
                                    n.label = n.originalLabel;
                                    }
                                    else {
                                    n.color = deselected_nodes_color;
                                    n.label = '';
                                    }

                            }

                            if (graphFactory.checkIfPinned(n.originalLabel) == true) {
                            n.color = '#0089e0';
                            n.label = n.originalLabel;
                            }
                            if (graphFactory.checkIfPinned(n.originalLabel) == false && islastnode && n.originalLabel == nodeLabel) {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                            }


                        });

                        }
                    }

                }

                sigma.instances(0).refresh();

        });

    }
</script>