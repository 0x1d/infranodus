<script>


undoButton().onClick(resetGraph);

function undoButton() {
    return {
        onClick: function(onClick){
            $('#undo').on('click', onClick)
        }
    }
}

function graphTags() {
    return {
        // TODO maybe add pinnedNodes, notFoundNodes, stopNodes into the function arguments and perform the logic accordingly
        update: function() {
                 
            // Add a delete button next to those nodes
            if (graphFactory.existPinnedNodes() == true) {
                $('#deletenodes').addClass('deletenodes-on');
                $('#undo').addClass('undo-on');
            }
            else {
                $('#deletenodes').removeClass('deletenodes-on');
                $('#undo').removeClass('undo-on');
            }

            // Show tags that are currently used in search
            var htmlNodes =  '<ul class="tags">';

            // If no pinned nodes, reset not found nodes
            if (graphFactory.existPinnedNodes() == false) { graphFactory.updateNotFoundNodes(); }

            // Add not found nodes as tags (gray)
            for (let x = 0; x < graphFactory.getNotFoundNodes().length; x++) {
                htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + graphFactory.getNotFoundNodes()[x] + '</a></li>';
            }

            // Add pinned nodes as tags (blue)
            for (let q = 0; q < graphFactory.getPinnedNodes().length; q++) {
                htmlNodes = htmlNodes + '<li><a href="#">' + graphFactory.getPinnedNodes()[q] + '</a></li>';
            }

            htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

            $('#pinnednodeslist').html(htmlNodes);

            // Add triggers to newly shown Tags elements

            addTagTriggers();
            
        }
    }
}



function addTagTriggers() {


    $(".tags").on('click', function(e) {

        e.preventDefault();

        let remove_node = e.target.innerText;

        // If the clicked node is in the pinnedNodes list, remove it and push it into the notfoundNodes list

        if (graphFactory.checkIfPinned(remove_node) == true) {

                graphFactory.removeFromPinnedNodes(remove_node);

        }


        if (deletedNodes.indexOf(remove_node) > -1) {
            socket.emit('node add', {addingNodes: remove_node, stoplistNodes: deletedNodes});
        }
        else {

        // console.log("node clicked, now will filter for nodes " + pinnedNodes);

        
         //   filter_statements(pinnedNodes);


        }


    });

}

// What happens when we click a button to delete a selected node

$("#deletenodes").on('click', function(e) {
    e.preventDefault;
    socket.emit('node delete', {pinnedNodes: pinnedNodes});
});


// What happens if we want to pass the list of keywords we selected to the settings

$("#stopsave").on('click', function(e) {
    e.preventDefault;
    window.location.href = "/settings?stopwords=" + encodeURIComponent(deletedNodes.join(' ')) + "&returncontext=" + current_context;
});

// What happens when we delete a node

socket.on('node delete', function(msg){

    var nodesToDelete = msg.pinnedNodes;
    var delete_from = msg.delete_from;
    var collectiond = cy.elements();
    var elesss;

    cy.remove(collectiond);

    elesnodes = [];

    // jsnetworkx
    var jsGraphEdges = [];
    nodeIDs_rev = _.invert(nodeIDs);

    // Reiterate nodes and delete all the pinned nodes

    sigma.instances(0).graph.nodes().forEach(function(n) {

        if (nodesToDelete.indexOf(n.originalLabel) >= 0) {
        sigma.instances(0).graph.dropNode(n.id);
        if (deletedNodes.indexOf(n.originalLabel) == -1) {
            deletedNodes.push(n.originalLabel);
        }
        }
        else {
        // Add the remaining ones to Cytoscape
        n.color = n.originalColor;
        n.label = n.originalLabel;
        elesnodes.push({
            group: "nodes",
            data: { id: n.id, name: n.label}
        });


        }
    //n.size = sigma.graph.degree(n.id);

    });

    // Reiterate all the remaining edges and add them to Cytascape
    // TODO this code duplicates from above - move into a function
    sigma.instances(0).graph.edges().forEach(function(e) {

        var unique_edge_id = '';

        // Let's see if the edge source in alphabetical order is further than its target and change places

        if (e.source > e.target) {
            unique_edge_id = e.target + '-' + e.source;
        }
        else {
            unique_edge_id = e.source + '-' + e.target;
        }

        elesnodes.push({
            group: "edges",
            data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
        });

             // TODO remove that, this is just to check data consistentency
             e.sourcename = nodeIDs_rev[e.source];
        e.targetname = nodeIDs_rev[e.target];


         // Add to jsnetworkx

         var edge_params = {
                     weight: 1/e.weight,
                     sourcename: e.sourcename,
                     targetname: e.targetname                     
        };

        var edge_object = [e.source, e.target, edge_params];
                 
        jsGraphEdges.push(edge_object);

    });


    // Betweenness Centrality Calculation using Cytoscape
    elesss = cy.add(elesnodes);

    var jsG = new jsnx.DiGraph();
    // jsG = jsnx.convertToUndirected(jsG);
           
    jsG.addEdgesFrom(jsGraphEdges);


    betweennessCentrality(elesss, jsG);

    // Community detect algorithm

    communityDetect();

    // No more pinned nodes

    if (!delete_from) {
    pinnedNodes = [];
    }
    commClicked = [];

    $('.community_node').each(function(){
    $(this).removeAttr('style');
    });

    $('.top_nodes').each(function(){
    $(this).removeAttr('style');
    });

    if (sigma.instances(0).isForceAtlas2Running()) {
        sigma.instances(0).stopForceAtlas2();
        sigma.instances(0).killForceAtlas2();
        setTimeout(function() {
        sigma.instances(0).startForceAtlas2(forceatlas_options);
        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 5000);
    }, 1000);
    }
    else {

        sigma.instances(0).startForceAtlas2(forceatlas_options);
        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 5000);

    }


    // Unfliter the nodes
    filter_statements(pinnedNodes, "nodedelete");


    sigma.instances(0).refresh();



});

// What happens when we add a node ?

socket.on('node add', function(msg){

    var addingNodes = msg.addingNodes;
    var stoplistNodes = msg.stoplistNodes;

    // Remove the clicked node from the stoplist

    stoplistNodes.splice(stoplistNodes.indexOf(addingNodes), 1);


    sigma.instances(0).graph.addNode({
        id: nodeIDs[addingNodes],
        label: addingNodes,
        originalLabel: addingNodes,
        size: 16,
        x: Math.random(),
        y: Math.random()
    });

    var cyclefinished = 0;
    var edgeproc;

    var nodeIDs_rev = _.invert(nodeIDs);

    for (var i = 0; i < edgesDB.length; i++ ) {

        if (edgesDB[i].source == nodeIDs[addingNodes] || edgesDB[i].target == nodeIDs[addingNodes]) {

            edgeproc = edgesDB[i];

            if (stoplistNodes.length > 0) {

                // Do connections only if target/source is not in the remaining stoplistNodes
                if (stoplistNodes.indexOf(nodeIDs_rev[edgeproc.source]) < 0 && stoplistNodes.indexOf(nodeIDs_rev[edgeproc.target]) < 0) {

                        sigma.instances(0).graph.addEdge({
                            id: edgeproc.id,
                            source: edgeproc.source,
                            target: edgeproc.target,
                            weight: edgeproc.weight,
                            size: edgeproc.weight,
                            statement_id: edgeproc.statement_id,
                            edge_context: edgeproc.edge_context
                        });

                    }




            }
            else {
            sigma.instances(0).graph.addEdge({
                    id: edgeproc.id,
                    source: edgeproc.source,
                    target: edgeproc.target,
                    weight: edgeproc.weight,
                    size: edgeproc.weight,
                    statement_id: edgeproc.statement_id,
                    edge_context: edgeproc.edge_context
            });

            }
        }

        cyclefinished = cyclefinished + 1;
    }



    if (cyclefinished == edgesDB.length) {
        sigma.instances(0).refresh();
        var collectiond = cy.elements();
        var elessss;

        cy.remove(collectiond);

        elesnodes = [];


        sigma.instances(0).graph.nodes().forEach(function(n) {
                            elesnodes.push({
                                group: "nodes",
                                data: { id: n.id, name: n.label}
                            });

                            // Adding a node to the nodeIDs
                            graphFactory.addNode(n.label, n.id);

        });

        // jsnetworkx
        var jsGraphEdges = [];
        nodeIDs_rev = _.invert(nodeIDs);

        sigma.instances(0).graph.edges().forEach(function(e) {

            var unique_edge_id = '';

            // Let's see if the edge source in alphabetical order is further than its target and change places

            if (e.source > e.target) {
                unique_edge_id = e.target + '-' + e.source;
            }
            else {
                unique_edge_id = e.source + '-' + e.target;
            }

                elesnodes.push({
                    group: "edges",
                    data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                });

                    // TODO remove that, this is just to check data consistentency
                    e.sourcename = nodeIDs_rev[e.source];
                e.targetname = nodeIDs_rev[e.target];

                // Add to jsnetworkx

                var edge_params = {
                            weight: 1/e.weight,
                            sourcename: e.sourcename,
                            targetname: e.targetname                     
                };

                var edge_object = [e.source, e.target, edge_params];
                        
                jsGraphEdges.push(edge_object);


        });


        // Betweenness Centrality Calculation using Cytoscape
        elessss = cy.add(elesnodes);

        var jsG = new jsnx.DiGraph();
        // jsG = jsnx.convertToUndirected(jsG);
            
        jsG.addEdgesFrom(jsGraphEdges);


        betweennessCentrality(elessss, jsG);

        // Community detect algorithm

        communityDetect("node add", addingNodes);

        sigma.instances(0).refresh();

        sigma.instances(0).startForceAtlas2(forceatlas_options);
        // Don't run it forever not to overheat :)

        setTimeout(function() {

            sigma.instances(0).stopForceAtlas2();
            sigma.instances(0).killForceAtlas2();

        }, 5000);


        filter_statements(stoplistNodes, 'stopwords');


    }




});


</script>