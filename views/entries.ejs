<!DOCTYPE html>
<html>
<%- include('components/entries/header') %>
<%- include('dependencies/entries') %>
<%- include('components/common/index') %>
<%- include('components/entries/index') %>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link editorpane">
    <!-- Hamburger icon -->
    <span></span>
    </a>
     <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/apps"><%= user.name %></a>
            <% } %>
                <br>
                <ul id="contexts" class="contexts">

                </ul>
            &nbsp;<br><br>

        <% } else { %>
            <%- include('components/common/menu', {contextlist:contextlist}); %>

        <% } %>
        </div>
   </div>
     <div id='content'>

          <%- include('components/entries/StatementMenu'); %>
           
          <%- include('components/entries/StatementSidePanel/index',
                {entries, perceivername, addcontext, user, context, contextpublic, url, urltitle}); %>


        <div id="graph-container"></div>

        <div id="biasindex" class="tooltip" title="shows how diversified the discourse network structure is: biased > focused > diverse > dispersed"><div class="slidercaption">network diversity level: </div>
        <div class="slidercontainer">
        <input type="range" min="1" max="100" value="50" class="slider" disabled id="biasRange">
        </div></div>

        <div id="livetext"></div>

      

          

         <div id="analytics"></div>


            <a href="javascript:" class="tooltip editorpane" title="graph analytics" id="analyticsbutton"><div id="analyticscaption"></div></a>
      </div>





    </div>





</div>

<%- include('components/entries/ContextMenu') %>
<%- include('components/entries/Graph/Graph') %>
<%- include('components/entries/Graph/GraphEdit') %>
<%- include('components/entries/Graph/GraphTags') %>
<%- include('components/entries/Graph/GraphMenu') %>
<%- include('components/entries/Graph/Walkthrough') %>




             <script>
;(function(){

  


    // Get URL variables in the form of an array
    // TODO can be moved out

 



    // First we query URL parameters

    /* {

     Which queries to add to search keywords from the graph:
     "go_next_add": "keyword",
     Which website to refer people to with the keywords (include search string with URL)
     "go_next_url" : "http://soundcloud.com/search?q="
     }

     */

 

    var link_hashtags = getUrlVars()["link_hashtags"];

    var convert_hashtags = getUrlVars()["convert_hashtags"];



    var mute = getUrlVars()["mute"];

    var speech = getUrlVars()["speech"];



    var customization = ' ';



    var highlight = getUrlVars()["highlight"];

    var missing = getUrlVars()["missing"];

    var add_statement = getUrlVars()["statement"];

    var selected_keywords = getUrlVars()["keywords"];

    var voice_continues = getUrlVars()["voice_continues"];

    // Getting the details parsed from routes/entries.js to see how to show the graph

    <% if (locals.user && locals.user.voice_continues != undefined && locals.user.voice_continues != '00') { %>
        voice_continues = '<%=locals.user.voice_continues%>';
    <% } %>

    




    
    // For collaboration - Socket.IO chat
    var collaborate_invite = getUrlVars()["collaborate"];



// MAIN SETTINGS START


var current_context_field = [];


// These are the nodes clicked in the graph

var global_totalnodes = 0;

// These are for Summary / Insight functionality

var most_inf_nodes = [];

var most_inf_comm_nodes = {};

var polysingularity_score = 0;

// Whats the clicked nodes in the graph
var clickedNodes = [];

// What are the shown nodes on the graph;
var shownNodes = [];

// Inactivity timeout
var inactiveTimeout = null;

// This variable shows if there was a meaningful interaction with the graph yet
var graphInteraction = null;

// Loaded with graph only?
var graphOnly = null;


// Who posted the message?
var selfPosted = null;










// This is for the option to emit and receive MIDI signals for the graph

var midi = '';

// TODO for desktop browses that support webwork (not iphone): webworker: true, slowdown: 300








var forcedatlas_running = false;

var adding_entry = false;

// This is a very stupid way to change the interface color to dark if the setting is on (through URL or user settings)

if (background == 'dark') {
  $('#graph-container').addClass('graph-dark');
  $('#analyticsbutton').addClass('analyticsbutton-dark');
  $('.entry').addClass('entry-dark');
  $('.entry-text').addClass('entry-text-dark');
  $('#analytics').addClass('analytics-dark');
  $('#entryform').addClass('entryform-dark');
  $('#addnodeinput').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('#statement').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('body').css('color', '#aaaab5');
  // $('li.pure-menu-selected-top a').css('backgroundColor', '#888888');
  $('.menu-link').css('background', 'rgba(250, 250, 250, 0.4)');
  $('#graph-link').addClass('graph-link-dark');
  $('#chat-link').addClass('chat-dark');
  $('#addnode').addClass('addnode-dark');
  $('#go_next').addClass('go_next-dark');
  $('#reloadbutton').addClass('reloadbutton-dark');
  $('#improve-layout').addClass('improve-layout-dark');
  $('#abstract-layout').addClass('abstract-layout-dark');
  $('#walkthrough').addClass('walkthrough-dark');
  $('#zoom-in').addClass('zoom-in-dark');
  $('#zoom-out').addClass('zoom-out-dark');
  $('#microphone-link').css({'background-image': "url('/images/microphone-white.png')", "opacity": "0.6"});
  $('#addcontext-link').css({'background-image': "url('/images/compare-white.png')", "opacity": "0.6"});
  $('#deletecontextbutton').addClass('deletecontextbutton-dark');
  $('#collaborate-link').addClass('collaborate-link-dark');
  $('#import-link').addClass('import-link-dark');
  $('#windowdown-link').addClass('windowdown-link-dark');
  $('#statements-link').addClass('statements-link-dark');
  $('#timer-link').addClass('timer-link-dark');
  $('#watch-link').addClass('watch-link-dark');
  if (graphPalette == 'contrast') {
      deselected_nodes_color = '#555';
  }
  else {
      deselected_nodes_color = '#444';
  }
}

$('#analyticscaption').html(customization);


// locals.user basically checks the user settings

<% if (locals.user) { %>
<% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>

var output;
var input;

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

WebMidi.enable(function (err) {

  if (err) {
    console.log("WebMidi could not be enabled.", err);
  } else {


    console.log("WebMidi enabled!");
    console.log(WebMidi.inputs);
    console.log(WebMidi.outputs);
    console.log(WebMidi.time);

    output = WebMidi.outputs[0];
    console.log('midi substr ' + midi.substr(4,2));

    if (midi.substr(4,2) != '00') {
      output = WebMidi.outputs[parseInt(midi.substr(4,2))];
    }

    if (output) {
      console.log('MIDI device connected');
    }
    else {
      console.log('MIDI out device not connected');
    }

    input = WebMidi.inputs[0];

    if (input) {

      // Listen for a 'note on' message on all channels
      input.addListener('noteon', "all",
        function (e) {
          console.log("Received 'noteon' message (" + e.note.name + e.note.octave + ").");
          console.log(e);

          if (midi.substr(14,2) != '' && midi.substr(14,2) != undefined && midi.substr(14,2) != 'no') {
            $('#statement').val($('#statement').val() + '#' + e.note.name.replace(/#/g,'') + e.note.number + ' ');
          }

        }
      );
    }
    else {
      console.log('MIDI input device not connected');
    }

  }



});

<% } %>
<% } %>


// If the user opened a URL with collaborate=xxxxxx then they join the room that's the "url_path/xxxxxx"
if (collaborate_invite) {
    collaborate_id = collaborate_invite;
}
// Otherwise they join a room which is "url_path/randomnumber"
else {
    collaborate_id = Math.round((Math.random() * 1000000));
}

collaborate_matrix[collaborate_room] = collaborate_room + collaborate_id;

// console.log('room id');
// console.log(collaborate_matrix[collaborate_room]);

if (!collaborate_invite) {
    if (collaborate_storage) {

        if (collaborate_storage[collaborate_room]) {
            if (collaborate_storage[collaborate_room].length > 0) {
                collaborate_matrix[collaborate_room] = collaborate_storage[collaborate_room];
                collaborate_id = collaborate_matrix[collaborate_room].split("/").pop();
            }
        }
    }

    // Now in case the original user reloads the page by error, they'll get the new collaborate ID, so we avoid that by storing their data
    localStorage.setItem("collaborate", JSON.stringify(collaborate_matrix));
}

   


    socket.on('startChat', function(data){
        console.log('chat started');
        if(data.boolean && data.id == collaborate_matrix[collaborate_room]) {
            console.log('in chat room ' + data.id);
            var collab_content = $('#collaborate-link').tooltipster('content');
            $('#collaborate-link').tooltipster('content', 'Collaboration is ON');
            $('#collaborate-link').addClass('is-collab');
            $('#collaborate-link').tooltipster('show');
            setTimeout(function() {
                $('#collaborate-link').tooltipster('hide');
                setTimeout(function() {
                    $('#collaborate-link').tooltipster('content', collab_content);
                }, 1000);

            }, 2000);
        }
    });

    socket.on('leave', function(msg){
        console.log('partner left');
        console.log(msg.people);
        if (msg.people < 2) {
          $('#collaborate-link').removeClass('is-collab');
          var collab_content = $('#collaborate-link').tooltipster('content');
          $('#collaborate-link').tooltipster('content', 'Collaboration is OFF');
          $('#collaborate-link').tooltipster('show');
          setTimeout(function() {
              $('#collaborate-link').tooltipster('hide');
              setTimeout(function() {
                  $('#collaborate-link').tooltipster('content', collab_content);
              }, 1000);
          }, 2000);
        }
    });

    socket.on('tooMany', function(data){

        console.log('one too many');
        alert('There are already 2 users working on this context and this is our max so far. If you think it is a mistake, please, check if any of your extra browser tabs are opened.');
        window.location.href = 'http://' + hostsite + '/' + 'home' + '/edit';

    });






    // Dynamic graph functionality

    // It basically makes only the nodes / edges of the graph visible that the user is currently seeing in the statements div

    var dynamic_graph = 0;

    var dynamic_watch = 0;

    $("#timer-link").click(function(e) {
      if (dynamic_graph == 0) {
        //localStorage.setItem('timer',1);
        dynamic_graph = 1;
        $('#timer-link').addClass('timer-link-on');
        $('#entries').scrollTop($('#entries').scrollTop() + 1);
      }
      else {
        dynamic_graph = 0;
        //localStorage.setItem('timer',0);
        $('#timer-link').removeClass('timer-link-on');
        entryScroll('',true);
        if (dynamic_watch == 1) {
          $("#watch-link").trigger('click');
        }

      }

    });



    // When scroll happens if the dynamic graph is on, show which uids are visible

    var scroll_signal;

    $("#entries").scroll(function() { //.box is the class of the div

          if (dynamic_graph == 1) {

            var ventries = [];


              $('#entries').children(".entry").each(function(){
                  var vresult;
                  vresult = checkInView(this,true);
                  if (vresult == true) {
                      if (ventries.indexOf($(this).attr('data-uid')) == -1) {
                          ventries.push($(this).attr('data-uid'));
                      }
                  }

                //  result2 += " " +  checkInView($(e),true);
               });

              entryScroll(ventries);



              if (!$(this).is(':animated')) {

                var current_scroll = ($(this).scrollTop());
                var max_scroll = $(this)[0].scrollHeight - $(this).height();

                if (current_scroll == max_scroll && scroll_signal != 'bottom') {
                  $(this).scrollTop(0);
                  scroll_signal = 'top';
                }
                else if (current_scroll == 0 && scroll_signal != 'top') {
                  $(this).scrollTop($(this)[0].scrollHeight);
                  scroll_signal = 'bottom';
                }

              }


          }

    });


    // Dynamically watch the graph unfold

    $("#watch-link").click(function(e) {

      if (dynamic_watch == 0) {
          var speed_scroll = 1000;
          dynamic_watch = 1;

          $('#watch-link').addClass('watch-link-on');

          if (dynamic_graph == 0) {
            $("#timer-link").trigger('click');
          }

          var max_scroll = $('#entries')[0].scrollHeight - $('#entries').height();

          function autoScrollUp(){
            var current_scroll = ($('#entries').scrollTop());
            var scroll_to = max_scroll;
            var num_entries =  $('.entry').length;

            if (current_scroll == max_scroll) {
              $('#entries').scrollTop(0);
              current_scroll = $('#entries').scrollTop();
            }
            var play_time = Math.round(((max_scroll - current_scroll)/max_scroll) * num_entries * speed_scroll);

            $("#entries").animate({scrollTop: scroll_to},play_time,"linear", autoScrollUp); // and animate
          }
          autoScrollUp();

      }
      else  {
        dynamic_watch = 0;
        $('#watch-link').removeClass('watch-link-on');
        $("#entries").stop();

      }
    });

    // TODO move this general function out — this is just to check which elements inside (#entries) are visible for the dynamic graph feature above

    function checkInView(elem,partial)
      {
          var container = $("#entries");
          var contHeight = container.height();
          var contTop = container.scrollTop();
          var contBottom = contTop + contHeight ;

          var elemTop = $(elem).offset().top - container.offset().top;
          var elemBottom = elemTop + $(elem).height();

          var isTotal = (elemTop >= 0 && elemBottom <=contHeight);
          var isPart = ((elemTop < 0 && elemBottom > 0 ) || (elemTop > 0 && elemTop <= container.height())) && partial ;

          return  isTotal  || isPart ;
      }



    // When the document loaded, add some hooks to the submit form

    document.addEventListener("DOMContentLoaded", function(event) {


        submitFormProcess();


    });


// What do do when the form is submitted and a new entry (text) is added?

function submitFormProcess() {

    document.querySelector('#submitform').addEventListener('submit', function(e) {

        e.preventDefault();

        $('#statement').addClass('loading');

        $('#submitbutton').attr('disabled', 'disabled');

        if ($('#livetext').html().length > 0 && voice_continues) {
          $('#livetext').html($('#statement').val() + '<br><em>saving into the graph...</em><span></span>');
          setTimeout(function(){
              $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
          }, 3000);
        }

        // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var postedby = '';

        <% if (receivername) { %>
           postedby = '<%= receivername %>';
        <% } %>
        // TODO make it possible that those statements get submitted in both graphs

        // is urlvars mute off? then post as usual
        if (!mute) {
        $.post('/post', $("#submitform").serialize())
                .done(function(res) {
                    //3. Receive the server response, no need to emit an event
                    if (res.entryuid) {
                        //4. Show the updated text
                        selfPosted = '1';
                        $("#statement").val('');
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');

                        // This below if a few statements were posted
                        // TODO as we can now get all the s.uid back as an array this could be rewritten so no need for the condition after
                        if (res.entryuid == 'multiple') {
                            socket.emit('chat message', {postedby: postedby, entryuid: 'multiplesocket', entrytext: res.entrycontent, graph: res.graph});
                            if (res.successmsg) {
                              $("#warnings").append('<p class="warning">Please, reload the page after a few seconds to see the graph.</p>');
                              $("#warnings").slideDown('slow');
                            }
                            setTimeout(function() {
                                location.reload();
                            },3000);
                        }
                        else {
                            // Only one statement added? Initiate processing that will show it both to the user and the collaborator (if exists)
                            socket.emit('chat message', {postedby: postedby, entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                        }

                    }
                    else if (res.errormsg) {
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        alert(res.errormsg);
                    }
                    else {
                        alert('Something went wrong, please, try again...');
                    }
                })
                .fail(function(res) {
                    alert("Server Error: " + res.status + " " + res.statusText);
                });

        }
        // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
        // This was made before to introduce a chat feature — so the software can "talk" to the user without adding stuff into the graph
        else {
            selfPosted = '1';
            $('#statement').removeClass('loading');
            $('#submitbutton').removeAttr('disabled');
            $("#statement").val('');
            socket.emit('chat message', {mute: 1, postedby: postedby, entryuid: '', entrytext: $('#statement').val(), graph: ''});
        }

        return false;
    });


    $('#statement').keypress(function(e){

        // Submit the form on enter

        if(e.which == 13 && !e.shiftKey) {
            e.preventDefault();
            $('#submitbutton').trigger('click');
        }

    });

}

// A function to hide / Show Statements and edit pane DIVs

// Has to be called with every update of the edit pane #entryform

function toggle_statements() {

    /*$('#graph-link').toggleClass('graph-chat');
    $('#entries').toggleClass("hide-entries");
    $('#statements').toggleClass("hide-statements");

    if ($('#graph-link').hasClass('graph-chat')) {
        //$('#switcher-panel').toggleClass("hide-menu");
        $('#finds').trigger('click');
        $('#switcher-selector').toggleClass("hide-menu");
    }
    else {
        // $('#switcher-panel').toggleClass("hide-menu");
        $('#switcher-selector').toggleClass("hide-menu");
        if (pinnedNodes.length == 0) {
            $('#adds').trigger('click');
        }
    }*/

   $("#statements").fadeToggle();


    if (!$("#chat-link").hasClass('chat-highlight')) {
        localStorage.setItem('graph', 1);
    }
    else {
        localStorage.setItem('graph', 0);
    }
    $("#chat-link").toggleClass('chat-highlight');

    if (!localStorage.getItem('analytics')) {
    $('#analytics').toggle('slide', function(){
      if ($('#analytics').is(":visible")) {
            $('#analyticsbutton').addClass('analytics-on');
            $('#analyticscaption').hide();
            //localStorage.setItem('analytics', 1);
      }
      else {
            $('#analyticsbutton').removeClass('analytics-on');
            $('#analyticscaption').show();
            //localStorage.setItem('analytics', 0);
          }
    });
    }






}

function showStatements () {
        var isHidden_ = $("#statements").is(":hidden");
        if (isHidden_) {
            $('#statements').fadeIn();
            $("#chat-link").toggleClass('chat-highlight');
        }
}

function showEntries () {
        var isHidden_ = $("#entries").is(":hidden");
        if (isHidden_) {
            $('#entries').fadeIn();
        }
}





// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});

// Initialize JSON parser for SIGMA visualization

var color_addcontext = '#666666'; // #cccccc

var highlight_addcontext = '#0089e0';








// TODO: 1. Add search function by #hashtag; 2. Attach that same function to hashtag doubleclick;

// Auto-resize to fill content;

    // This launches only when all other stuff from above have loaded
    $(document).ready(function(){




      // Get the context names - all the contexts that exist in the graph we just loaded
      // This IF statement is for the case when the contextlist parameter is not passed on
      <% if (contextlist.length > 0) { %>
      <% contextlist.forEach(function(contextlabel) { %>
        contextNames.push("<%= contextlabel[0] %>");
      <% }); %>
      <% } %>

      // Memorize which interface option the user had on last time
      if (localStorage.getItem('defaultbehavior') == 'add') {
        $('#addnode').addClass('addnode-on');
      }
      else {
        $('#searchnode').addClass('searchnode-on');
      }

      // Put the contexts into the menu
      populateContextMenu(contextNames);

        $('.tooltip').tooltipster({
            theme: 'tooltipster-noir',
            position: 'left',
            maxWidth: 200,
            delay: 1000
        });

        // Some more settings from the URL or user settings passed from routes/entries.js and defined above in global parameters

        var privacyform = '';

        var graph_share_url = hostsite + '/' + current_user;

        if (current_context) {
            graph_share_url = graph_share_url + "/" + current_context + "?";
        }

        if (background) {
            graph_share_url += 'background=' + background + '&';
        }

        if (most_influential) {
            graph_share_url += '&most_influential=' + most_influential + '&';
        }

        if (maxnodes) {
            graph_share_url += '&maxnodes=' + maxnodes + '&';
        }

        if (abstract == 'yes') {
            graph_share_url += '&abstract=yes&hide_always=1&';
        }


        var privacy_iframe = "<iframe width='100%' height='500' style='height: 500px' src='https://" + graph_share_url + "hide_always=1&link_hashtags=1&background=" + background + "&maxnodes=" + maxnodes + "' frameborder='0' allowfullscreen></iframe>";

        <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This context can be viewed on:<br><input type="text" id="embedurl" size="25" maxlength="80" class="pure-input" value="https://' + graph_share_url + '"><br><br>Embed code for websites:<br><input type="text" id="embedcode" size="25" maxlength="100" class="pure-input" value="' + privacy_iframe + '"><br><br><input type="submit" id="privacybutton" name="privacy" value="make private"></form></span>')

        <% } else if (!perceivername && context && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This context is currently private and cannot be seen by the public.<br><br><input type="submit" id="privacybutton" name="privacy" value="make public"></form></span>')
        <% }  %>

        $('#privacy-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: privacyform,
            functionReady: function() {
                $('#embedurl').focus(function(event) {
                    setTimeout(function() {$('#embedurl').select();}, 0);
                });
                $('#embedcode').focus(function(event) {
                    setTimeout(function() {$('#embedcode').select();}, 0);
                });

            }
        });


        collaborate_message = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=https://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Invite us</a> or other people for a real-time constellaversation – just share the link below:<br>';

        collaborate_html = '<span><form class="pure-form">' + collaborate_message + '<input type="text" id="collaburl" size="22" maxlength="80" class="pure-input" value="http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '"></form></span>';

        collaborate_content = $(collaborate_html);

        $('#collaborate-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: collaborate_content,
            functionReady: function() {
                $('#collaburl').focus(function(event) {
                    this.setSelectionRange(0, 9999);
                });
            }
        });





        // So the perceiver is the one who is viewing the graph
        // receiver is the one who created it
        // We use it to basically identify if the user is logged in as perceiver is only passed in this case if the user who's viewing the graph is not logged in

        <% if (!perceivername) { %>

            // Advertise graph collaboration module
            if (!collaborate_invite) {
                var collab_content = $('#collaborate-link').tooltipster('content');

                var graph_share_url = hostsite + '/' + current_user;

                if (current_context) {
                    graph_share_url = graph_share_url + "/" + current_context;
                }


            }

        // START Speech Recognition Module only for Chrome

        if ('webkitSpeechRecognition' in window) {

            var recognition = new webkitSpeechRecognition();

            $('#microphone-link').fadeIn();

            if (localStorage.getItem('microphone') == 1) {
                $('#microphone-link').toggleClass('microphone-on', 'add');
                activateVoiceInput();
            }

            if (speech) {
              $('#microphone-link').toggleClass('microphone-on', 'add');

              activateVoiceInput();

              if (walkthrough == "mic") {
              // Instance the walkthrough tour
                var tour = new Tour({
                  storage: false,
                  steps: [
                  {
                    element: "#microphone-link",
                    placement: "left",
                    title: "Turn on Your Microphone",
                    content: "When it's blue, it's on. Make sure you also have the sound and microphone turned on in your computer.",
                    onNext: function (tour) {
                      setTimeout(function() {
                        var player = new talkify.Html5Player(); //or new talkify.Html5Player()
                        player.playText('Please speak into your microphone and every word you say, will be visualized in a network.');
                      },1000);
                    }
                  },
                  {
                    element: "#entryform",
                    title: "Continue Talking...",
                    content: "As you speak, the words will appear here. Please, speak clearly and make breaks between sentences."
                  },
                  {
                    element: ".entry",
                    title: "Edit the Statements",
                    content: "You will see visualization on the right. To delete a statement, double-click it."
                  },
                  {
                    element: "#statement",
                    title: "Delete Statements",
                    content: "If you double-clicked the statement, it appears here. Then simply click the Delete icon below the statement and it will be removed."
                  }
                ]});

                // Initialize the tour
                tour.init();

                // Start the tour
                tour.start();
              }

            }

            $("#microphone-link").click(function(e) {

                e.preventDefault();

                if (localStorage.getItem('microphone')  == 1) {
                    localStorage.setItem('microphone', 0);
                    $('#microphone-link').toggleClass('microphone-on', 'remove');
                    recognition.abort();
                    $('#livetext').html('');
                }
                else {
                    localStorage.setItem('microphone', 1);
                    activateVoiceInput();
                    $('#microphone-link').toggleClass('microphone-on', 'add');
                }

            });



        }


            function activateVoiceInput() {



                    var voiceresult = '';

                    var previoustalk = '';

                    var previoustalk_last = '';

                    var offtherecord = '';

                    var voicecorrect = '';

                    // Are we processing a short phrase or performing continuous dictation?
                    recognition.continuous = false;

                    // Do we require interim results in addition to the final results?
                    recognition.interimResults = true;

                    // Check if the user has a preferred language settings

                    if (inlanguage != undefined) {
                        if (inlanguage == 'auto') {
                          recognition.lang = 'en-US';
                        }
                        else {
                          recognition.lang = inlanguage;
                        }
                    }
                    else {
                        // We speak The US English here
                        recognition.lang = 'en-US';
                    }

                    if (language == 'en' || language == 'en-US' || language == 'english') {
                        recognition.lang = 'en-US';
                        localStorage.setItem('language', 'en');
                    }

                    else if (language == 'ru' || language == 'russian') {
                        recognition.lang = 'ru';
                        localStorage.setItem('language', 'ru');
                    }
                    else if (language == 'fr' || language == 'french') {
                        recognition.lang = 'fr';
                        localStorage.setItem('language', 'fr');
                    }
                    else if (language == 'de' || language == 'german') {
                        recognition.lang = 'de';
                        localStorage.setItem('language', 'de');
                    }

                    // if (localStorage.getItem('language') == 'ru') {
                    //     recognition.lang = 'ru';
                    //     localStorage.setItem('language', 'ru');
                    // }
                    // else if (localStorage.getItem('language') == 'en') {
                    //     recognition.lang = 'en';
                    //     localStorage.setItem('language', 'en');
                    // }
                    // else if (localStorage.getItem('language') == 'fr') {
                    //     recognition.lang = 'fr';
                    //     localStorage.setItem('language', 'fr');
                    // }
                    // else if (localStorage.getItem('language') == 'de') {
                    //     recognition.lang = 'de';
                    //     localStorage.setItem('language', 'de');
                    // }

                    // Kick off the Speech to Text recognition process
                    $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
                    recognition.start();

                    // Set up
                    recognition.onstart = function(event){
                        console.log("onstart", event);
                    }
                    // Set up
                    recognition.onspeechstart = function(event){
                        console.log("onspeechstart", event);
                    }

                    // Process parsed result
                    recognition.onresult = function(event){
                        // console.log("onresult", event);



                        if ($('#statement').val().length == 0) {
                          previoustalk = '';
                        }
                        voiceresult = previoustalk + event.results[0][0].transcript;
                        $('#statement').val(voiceresult);
                        $('#livetext').html(voiceresult + '<span></span>');

                        console.log(event.resultIndex);
                        for (var i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {

                                recognition.abort();

                                lastword = event.results[0][0].transcript.toLowerCase();

                                if (offtherecord == 'on') {
                                    voiceresult = previoustalk;
                                    $('#statement').val(voiceresult);
                                    $('#livetext').html(voiceresult + '<span></span>');
                                    if (lastword == 'on the record') {
                                      offtherecord = '';
                                    }
                                }
                                else if (voicecorrect == 'on') {
                                  var wordswap = lastword.split(" ");
                                  var wordwas = wordswap[0];
                                  var wordis = wordswap[2];
                                  var reg = new RegExp('('+wordwas+')', 'gi');
                                  voiceresult = previoustalk.replace(reg,wordis);
                                  previoustalk = voiceresult + ' ';
                                  $('#statement').val(voiceresult);
                                  $('#livetext').html(voiceresult + '<span></span>');
                                  voicecorrect = '';
                                }
                                else {
                                  if (voiceresult.length > 2) {
                                      if (!voice_continues) {
                                        $('#livetext').html(voiceresult + '<br><em>saving into the graph...</em> <span></span>');
                                        setTimeout(function(){
                                            $('#submitbutton').trigger('click');
                                        }, 1000);
                                        setTimeout(function(){
                                            $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
                                        }, 3000);
                                      }
                                      else {
                                        if (lastword == voice_continues) {
                                          voiceresult = previoustalk;
                                          previoustalk = '';
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          setTimeout(function(){
                                              $('#submitbutton').trigger('click');
                                          }, 1000);
                                        }
                                        else if (lastword == 'improve layout') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          $('#improve-layout').trigger('click');
                                        }
                                        else if (lastword == 'off the record') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          offtherecord = 'on';
                                        }
                                        else if (lastword == 'correct') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          voicecorrect = 'on';
                                        }
                                        else if (lastword == 'erase') {
                                          voiceresult = previoustalk_last;
                                          previoustalk = previoustalk_last;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                        }
                                        else if (lastword == 'new line') {
                                          previoustalk_last = previoustalk;
                                          previoustalk = voiceresult + ' \n';
                                        }
                                        else {
                                          previoustalk_last = previoustalk;
                                          previoustalk = voiceresult + ' ';
                                        }
                                      }
                                  }
                                  else {
                                    previoustalk = voiceresult + ' ';
                                      // recognition.start();
                                  }
                                }
                            }
                        }
                    }

                    // Handle error
                    recognition.onerror = function(event){
                        console.log("onerror", event);
                        if (event.error == 'no-speech') {

                        }
                    }

                  /*  // Housekeeping after success or failed parsing
                    recognition.onspeechend = function(){
                        console.log("onspeechend");
                        if (voiceresult.length > 4) {
                            setTimeout(function(){
                                $('#submitbutton').trigger('click');
                            }, 1000);

                        }
                        else {
                            previoustalk = voiceresult + '';
                            // recognition.start();
                        }

                    }*/


                    recognition.onend = function(){

                        console.log("onend");
                        if (localStorage.getItem('microphone') == 1 || speech == 1) {
                            recognition.start();
                        }

                    }



            }


            // END Speech recognition module





        // IMPORTANT NOTE this is the end of the cycle that shows only to the editor, if the user who' viewing is logged in and viewing their own stuff
         <% } %>

        

     

          

        

        // What happens when we click a button to delete a selected node
        $("#deletenodes").on('click', function(e) {
          e.preventDefault;
          socket.emit('node delete', {pinnedNodes: pinnedNodes});
        });

     

        // What happens if we want to pass the list of keywords we selected to the settings

        $("#stopsave").on('click', function(e) {
          e.preventDefault;
          window.location.href = "/settings?stopwords=" + encodeURIComponent(deletedNodes.join(' ')) + "&returncontext=" + current_context;
        });

        // What happens when we add a single node from the second editor on top

        $("#addnode").on('click', function(e) {
          e.preventDefault();

          $('#addnode').addClass('addnode-on');
          $('#searchnode').removeClass('searchnode-on');
          localStorage.setItem('defaultbehavior', 'add');

          document.getElementById('addnodeform').dispatchEvent(new Event('submit'));


        });

        // What if we search for a node in the graph using the form at the top right

        $("#searchnode").on('click', function(e) {
          e.preventDefault();

          $('#addnode').removeClass('addnode-on');
          $('#searchnode').addClass('searchnode-on');
          localStorage.setItem('defaultbehavior', 'search');

          var searchinput = $('#addnodeinput').val();
          // TODO implement lemmas search
          if (searchinput.length > 0) {
              var searchinarray = searchinput.split(' ');
              for (var key in searchinarray) {
                if (searchinarray[key].charAt(0) == '#') { searchinarray[key] = searchinarray[key].slice(1); }
              }
              searchinput = searchinarray.join(' ');
              $('#search').val(searchinput);
              document.getElementById('searchform').dispatchEvent(new Event('submit'));
          }
          else {
            alert('Please, enter the node name you want to find...');
          }

        });

        

      

        // What happens when we add a node using the small form top right?
        $('#addnodeform').submit(function(e) {
            e.preventDefault(); // to stop the form from submitting
            if ($(".searchnode-on").is(":visible")) {
              $('#searchnode').trigger('click');
            }
            else {
              if ($('#addnodeinput').val().length > 0) {
                  $('#statement').val($('#addnodeinput').val());
                  document.getElementById('submitform').dispatchEvent(new Event('submit'));
                  $('#addnodeinput').val('');
                  $("#addnodeinput").focus();
              }
              else {
                alert('Please, enter the name of the node you want to add...');
              }
            }

        });


        // We temporarily removed this link but it will be added again later, so save the logic
        $("#imports").click(function(e) {
            // var fornode = $('#statement').val();
            // // if (pinnedNodes.length > 0) {
            // //      fornode = toTitleCase(pinnedNodes[pinnedNodes.length - 1].replace(/_/g, " "));
            // // }
            //
            // var current_href = $(this).attr("href");
            // $(this).attr("href",current_href + '&statement=' + fornode);
        });

    


        $("#import-link").click(function(e) {

          var fornode = $('#statement').val();


          if (pinnedNodes.length > 0) {
               fornode = pinnedNodes.join("+");
          }

          var current_href = $(this).attr("href");

          $(this).attr("href",current_href + '?context=' + current_context + '&fornode=' + fornode);
        });


        function toTitleCase(str)
        {
            return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
        }

        

        var uproll = $('#entryform').height();

        if (hide_edit) {
          uproll = 50;
        }

        $('#entries').css({height:  $(window).height() - uproll - 100});

        $(window).resize(function() {
              $('#entries').css({height:  $(window).height() - uproll - 100});
              $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
        });


        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);


        // TODO We have a very strange switcher of panels here. Needs to be changed

        $('#switcher-selector').on('click', 'li', function() {


        

            var topmenuaction = $(this).children(":first").attr('id');

            // Repopulate context for addition field if it was the one clicked

            if (topmenuaction == 'adds') {

                current_context_field = [];

                // Are we inside some context already?

                if (document.getElementById('context').value) {
                    current_context_field.push(document.getElementById('context').value);
                    $("#addedContexts").val(document.getElementById('context').value);
                }

                // if not, we're making the 'private' context default
                else {
                    var lastcontexts = [];
                    var laststatement = $(".entry:last").attr('data-uid');
                    console.log(laststatement);
                    for (var key in statementsOfContext) {
                        var reiteratestatements = statementsOfContext[key];
                        for (var i = 0; i< reiteratestatements.length; i++) {
                            if (laststatement == reiteratestatements[i]) {
                                lastcontexts.push(key);
                                console.log(key);
                            }
                        }

                    }
                    if (lastcontexts[0] == 'help') {
                        current_context_field = ['private'];
                        $("#addedContexts").val('private');
                    }
                    else {
                        current_context_field = lastcontexts;
                        $("#addedContexts").val(current_context_field.join());
                    }
                }

                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                submitFormProcess();


            }


       



           


        });

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {
                var filter = ui.item.value;
            }
        });

        // Function to search the graph for the nodes selected

        search_graph();

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        var filteringstarted = 0;

        // Add the hooks to the newly rendered entries again

        entryClick();

        // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
        <% if (!perceivername) { %>
        entryDoubleClick();





        <% } %>


        // Highlight statement if clicked once

        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text(convertedTime);
        });

        // TODO move the fucntion out
        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var time = moment(modTimestamp, 'x').fromNow();
            return time;
        }


        // Some more graph interface settings

        // Did we receive a global setting to hide the graph?

        if ((hide_always || hide_edit) && !show_text) {
            toggle_statements();
            //localStorage.setItem('graph', 1);
        }

        // Did we receive a global setting to hide when small only?

        if (hide_when_small && $(window).width() < 600) {

            if ($('#menuLink').is(':visible')) {
                toggle_statements();
                //localStorage.setItem('graph', 1);
            }

            $('#analytics').hide();
            $('#analyticsbutton').removeClass('analytics-on');
            $('#analyticscaption').show();


        }

        // Did we receive a global setting to hide the editor pane?

        if (hide_edit) {
          $('.editorpane').each(function() {
            $(this).hide();
          });
        }


        // Are we loading the page to only show the graph?

        <% if (background == '1' || background == 'graph') { %>
           // $('#finds').trigger('click');

            toggle_statements();
            //localStorage.setItem('graph', 1);
            graphOnly = 1;
        <% } %>

        if (localStorage.getItem('graph') == 1 && !graphOnly && !hide_always && !hide_when_small) {
            var isHidden__ = $("#statements").is(":hidden");
            if (!isHidden__) {
                $('#statements').fadeOut();
                $("#chat-link").toggleClass('chat-highlight','add');
            }
        }

        if (localStorage.getItem('timer') == 1) {
          ($("#timer-link").trigger('click'));
        }

        // What happens when the user clicks on a node in the graph (this is caleld from sigma but processed here)

        socket.on('node click', function(msg){

              pinnedNodes = msg.pinnedNodes;
              console.log("Pinned nodes:");
              console.log(pinnedNodes);
              splicedNodes = msg.splicedNodes;
              console.log("Spliced nodes:");
              console.log(splicedNodes);
              var pinnedIndex = msg.pinnedIndex;

              // Are we clicking the node that was clicked already? Then show all divs
              if (pinnedIndex > -1) {
                    $('.entry').fadeIn(400);
              }


              // Filter statements and select nodes on the graph
              filter_statements(pinnedNodes);

        });

       

        // What happens when we delete a node

        socket.on('node delete', function(msg){

              var nodesToDelete = msg.pinnedNodes;
              var delete_from = msg.delete_from;
              var collectiond = cy.elements();
              var elesss;

              cy.remove(collectiond);

              elesnodes = [];

              // Reiterate nodes and delete all the pinned nodes

              sigma.instances(0).graph.nodes().forEach(function(n) {

                  if (nodesToDelete.indexOf(n.originalLabel) >= 0) {
                    sigma.instances(0).graph.dropNode(n.id);
                    if (deletedNodes.indexOf(n.originalLabel) == -1) {
                      deletedNodes.push(n.originalLabel);
                    }
                  }
                  else {
                    // Add the remaining ones to Cytoscape
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                    elesnodes.push({
                        group: "nodes",
                        data: { id: n.id, name: n.label}
                    });


                  }
              //n.size = sigma.graph.degree(n.id);

              });

              // Reiterate all the remaining edges and add them to Cytascape
              // TODO this code duplicates from above - move into a function
              sigma.instances(0).graph.edges().forEach(function(e) {

                  var unique_edge_id = '';

                  // Let's see if the edge source in alphabetical order is further than its target and change places

                  if (e.source > e.target) {
                      unique_edge_id = e.target + '-' + e.source;
                  }
                  else {
                      unique_edge_id = e.source + '-' + e.target;
                  }

                    elesnodes.push({
                        group: "edges",
                        data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                    });


              });


              // Betweenness Centrality Calculation using Cytoscape
              elesss = cy.add(elesnodes);


              betweennessCentrality(elesss);

              // Community detect algorithm

              communityDetect();

              // No more pinned nodes

              if (!delete_from) {
                pinnedNodes = [];
              }
              commClicked = [];

              $('.community_node').each(function(){
                $(this).removeAttr('style');
              });

              $('.top_nodes').each(function(){
                $(this).removeAttr('style');
              });

              if (sigma.instances(0).isForceAtlas2Running()) {
                  sigma.instances(0).stopForceAtlas2();
                  sigma.instances(0).killForceAtlas2();
                  setTimeout(function() {
                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                    setTimeout(function() {

                        sigma.instances(0).stopForceAtlas2();
                        sigma.instances(0).killForceAtlas2();

                    }, 5000);
                }, 1000);
              }
              else {

                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  setTimeout(function() {

                      sigma.instances(0).stopForceAtlas2();
                      sigma.instances(0).killForceAtlas2();

                  }, 5000);

              }


              // Unfliter the nodes
              filter_statements(pinnedNodes, "nodedelete");


              sigma.instances(0).refresh();



        });

        // What happens when we add a node ?

        socket.on('node add', function(msg){
              var addingNodes = msg.addingNodes;
              var stoplistNodes = msg.stoplistNodes;

              // Remove the clicked node from the stoplist

              stoplistNodes.splice(stoplistNodes.indexOf(addingNodes), 1);


              sigma.instances(0).graph.addNode({
                  id: nodeIDs[addingNodes],
                  label: addingNodes,
                  originalLabel: addingNodes,
                  size: 16,
                  x: Math.random(),
                  y: Math.random()
              });

              var cyclefinished = 0;
              var edgeproc;

              var nodeIDs_rev = _.invert(nodeIDs);



              for (var i = 0; i < edgesDB.length; i++ ) {
                if (edgesDB[i].source == nodeIDs[addingNodes] || edgesDB[i].target == nodeIDs[addingNodes]) {

                  edgeproc = edgesDB[i];

                  if (stoplistNodes.length > 0) {

                      // Do connections only if target/source is not in the remaining stoplistNodes
                        if (stoplistNodes.indexOf(nodeIDs_rev[edgeproc.source]) < 0 && stoplistNodes.indexOf(nodeIDs_rev[edgeproc.target]) < 0) {

                              sigma.instances(0).graph.addEdge({
                                     id: edgeproc.id,
                                     source: edgeproc.source,
                                     target: edgeproc.target,
                                     weight: edgeproc.weight,
                                     size: edgeproc.weight,
                                     statement_id: edgeproc.statement_id,
                                     edge_context: edgeproc.edge_context
                              });

                          }




                  }
                  else {
                    sigma.instances(0).graph.addEdge({
                           id: edgeproc.id,
                           source: edgeproc.source,
                           target: edgeproc.target,
                           weight: edgeproc.weight,
                           size: edgeproc.weight,
                           statement_id: edgeproc.statement_id,
                           edge_context: edgeproc.edge_context
                    });

                  }
                }
                cyclefinished = cyclefinished + 1;
              }



              if (cyclefinished == edgesDB.length) {
                sigma.instances(0).refresh();
                var collectiond = cy.elements();
                var elessss;

                cy.remove(collectiond);

                elesnodes = [];


                sigma.instances(0).graph.nodes().forEach(function(n) {
                                    elesnodes.push({
                                        group: "nodes",
                                        data: { id: n.id, name: n.label}
                                    });

                                    // Adding a node to the nodeIDs
                                    var key = n.label;
                                    if (!nodeIDs[key]) {
                                        nodeIDs[key] = n.id;
                                    }
                                    if (nodeNames.indexOf(key) == -1) {
                                        nodeNames.push(key);
                                    }

                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                    var unique_edge_id = '';

                    // Let's see if the edge source in alphabetical order is further than its target and change places

                    if (e.source > e.target) {
                        unique_edge_id = e.target + '-' + e.source;
                    }
                    else {
                        unique_edge_id = e.source + '-' + e.target;
                    }

                      elesnodes.push({
                          group: "edges",
                          data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                      });


                });


                // Betweenness Centrality Calculation using Cytoscape
                elessss = cy.add(elesnodes);


                betweennessCentrality(elessss);

                // Community detect algorithm

                communityDetect("node add", addingNodes);

                sigma.instances(0).refresh();

                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  // Don't run it forever not to overheat :)

                  setTimeout(function() {

                      sigma.instances(0).stopForceAtlas2();
                      sigma.instances(0).killForceAtlas2();

                  }, 5000);


                filter_statements(stoplistNodes, 'stopwords');


              }






        });




        // Textarea select conversion to hashtags

        // For now it's disabled, but will be enabled for bulk statement correction later

        var getSelected = function(){
            var t = '';
            if(window.getSelection) {
                t = window.getSelection();
            } else if(document.getSelection) {
                t = document.getSelection();
            } else if(document.selection) {
                t = document.selection.createRange().text;
            }
            return t;
        }


        $("#statement").select(function(eventObject) {
            var selectedText = getSelected().toString();

            var statementReplace = $("#statement").val();

            if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

                var regex = RegExp(selectedText, "g");

                var dasherized = S(selectedText).underscore().chompLeft('_').s;

                // TODO check words for morphology (if found, alert)

                var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
                $("#statement").val(replacedString);
            }

        });

        // Document Ready end

        });







   





    function entryClick () {



        $(".entry").on('click', function(e) {
            if (e.target.className == 'app-link-menu') {

                if ($(this).find('.app-link-menu').text() == 'hide filtered') {
                    $(this).find('.nonmatched-sentence').fadeOut(400);
                    $(this).find('.app-link-menu').text('show filtered');
                }
                else {
                    $(this).find('.nonmatched-sentence').fadeTo(400, '0.4');
                    $(this).find('.app-link-menu').text('hide filtered');
                }

            }


            // A parameter to check if we're taking off the flag

            var alreadyClicked = null;

            // Make all entries semitrasparent


            if (pinnedNodes.length == 0) {

                $(".entry").each(function() {
                    if ($(this).css('opacity') < 1) {
                        $(this).css('opacity', '1');
                        alreadyClicked = 1;
                    }
                    else {
                        $(this).css('opacity', '0.3');
                    }
                });

                // The one clicked is not transparent

                $(this).css('opacity','1');

            }



            var keepStatementID = e.currentTarget.dataset.uid;


            console.log(keepStatementID);

            // Make only those edges visible that belong to the statement selected

            if (!alreadyClicked && pinnedNodes.length == 0) {

                sigma.instances(0).graph.edges().forEach(function(e) {
                    var got_match = 0;

                    for (let item of e.statement_id) {
                        if (item == keepStatementID) {

                          got_match += 1;

                        }

                    }

                    if (got_match > 0) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = deselected_nodes_color;
                    }
                });

                // Make only those nodes visible that belong to the statement selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    // Is there no contexts at all? Show the node.
                    if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0)  {
                        n.color = deselected_nodes_color;
                        n.label = '';
                    }
                    else {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    }
                });
            }
            else if (e.target.className == 'app-link-menu') {

                // Do nothing

            }
            else {

                if (pinnedNodes.length == 0) {
                    sigma.instances(0).graph.edges().forEach(function(e) {
                        e.color = e.originalColor;
                    });

                    // Make only those nodes visible that belong to the statement selected

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    });
                }

            }

            sigma.instances(0).refresh();
        });

    }

    function entryScroll (scroll_entry, undo_select) {

      if (pinnedNodes.length == 0 && !undo_select) {

          sigma.instances(0).graph.edges().forEach(function(e) {
              var got_match = 0;
              for (let item of e.statement_id)  {
                  if (scroll_entry.indexOf(item) > -1) {
                      got_match += 1;
                  }
              }
              if (got_match > 0) {
                  e.color = e.originalColor;
              }
              else {
                  e.color = deselected_nodes_color;
              }

          });

          // Make only those nodes visible that belong to the statement selected

          sigma.instances(0).graph.nodes().forEach(function(n) {

              // Is there no contexts at all? Show the node.
              for (var i = 0; i < scroll_entry.length; i++) {
                if (nodesOfStatement[scroll_entry[i]] && (nodesOfStatement[scroll_entry[i]].indexOf(n.id) < 0))  {
                    n.color = deselected_nodes_color;
                    n.label = '';
                }
                else {
                  if (nodesOfStatement[scroll_entry[i]] != undefined) {
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                  }
                }
              }
          });
      }

      else {

          if (pinnedNodes.length == 0) {
              sigma.instances(0).graph.edges().forEach(function(e) {
                  e.color = e.originalColor;
              });

              // Make only those nodes visible that belong to the statement selected

              sigma.instances(0).graph.nodes().forEach(function(n) {
                  n.color = n.originalColor;
                  n.label = n.originalLabel;
              });
          }

      }

      sigma.instances(0).refresh();

    }



    function entryDoubleClick() {

        $(".entry").on('doubletap', function(e) {

        e.preventDefault();

        // Get the content from the form edit and copy it into the switcher panel to show to the user

        var _formcontent = $('#adds-content').html();

        $("#switcher-panel").html(_formcontent);

        // Get the statement into the edit box at the top
        $("#statement").val($('.entry-text', e.currentTarget).text());

        // Retrieve that statement's ID into the hidden field (for edit or delete)
        $('input[name="statementid"]').val(e.currentTarget.dataset.uid);

        // Retrieve the date of the statement
        $('input[name="timestamp"]').val(e.currentTarget.dataset.timestamp);

        $('#statementInputMenu').each(function() {
            $("li", this).each(function(i) {

                $(this).removeClass('pure-menu-selected-top');

            });
        });




        // Change / add buttons
        $('#submitbutton').hide();

        if (!$('#deletebutton').val()) {

            $("#submitform").append('<input type="submit" name="edit" value="edit" id="editbutton" class="pure-button"> <input type="submit" style="margin: 0px 8px;" name="delete" value="delete" id="deletebutton" > <input type="submit" name="cancel" value="cancel" id="cancelbutton" class="pure-button">');

            $('#deletecontextbutton').hide();
            $('#privacy-link').hide();
            $('#collaborate-link').hide();
            $('#import-link').hide();



            // Delete text from the form in case of Cancel, remove the buttons

            $("#cancelbutton").on('click', function(e) {

                e.preventDefault();

                $("#statement").val('');
                $('#editbutton').remove();
                $('#deletebutton').remove();
                $('#cancelbutton').remove();
                $('#submitbutton').show();
                $('#deletecontextbutton').show();
                $('#privacy-link').show();
                $('#collaborate-link').show();
                $('#import-link').show();

                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

                $('input[name="timestamp"]').val('');

                // Populate contexts list next to statement add

                current_context_field = [];

                // Are we inside some context already?

                if ($("#context").val()) {
                    current_context_field.push($("#context").val());
                    $("#addedContexts").val($("#context").val());
                }

                else {

                    if (document.getElementById('context').value) {
                        current_context_field.push(document.getElementById('context').value);
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        var lastcontexts = [];
                        var laststatement = $(".entry:last").attr('data-uid');
                        console.log(laststatement);
                        for (var key in statementsOfContext) {
                            var reiteratestatements = statementsOfContext[key];
                            for (var i = 0; i< reiteratestatements.length; i++) {
                                if (laststatement == reiteratestatements[i]) {
                                    lastcontexts.push(key);
                                    console.log(key);
                                }
                            }

                        }
                        if (lastcontexts[0] == 'help') {
                            current_context_field = ['private'];
                            $("#addedContexts").val('private');
                        }
                        else {
                            current_context_field = lastcontexts;
                            $("#addedContexts").val(current_context_field.join());
                        }
                    }


                }



                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                // TODO a better way of dealing with delete and edit - in the logic of everything else

                submitFormProcess();





            });

            $("#deletebutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#deletebutton').attr('disabled', 'disabled');

                $('input[name="timestamp"]').val('');


                var formSubmit = $("#submitform").serialize() + '&delete=delete';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            console.log(res);
                            if (res.successmsg) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#deletebutton').removeAttr('disabled');
                                socket.emit('delete message', {entryuid: res.statementid});
                                $("#warnings").append('<p class="warning">The statement was deleted.</p>');
                                $("#warnings").slideDown('slow');
                                $('#cancelbutton').trigger('click');
                                setTimeout(function() {
                                    $("#warnings").slideUp('slow');
                                    $("#warnings").text('');
                                },2000);


                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });

            $("#editbutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#editbutton').attr('disabled', 'disabled');

                var statementToHide = $('#statementid').val();

                $('[data-uid="' + statementToHide + '"]').slideUp();

                var formSubmit = $("#submitform").serialize() + '&edit=edit';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            if (res.entryuid) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#editbutton').removeAttr('disabled');
                                $('#cancelbutton').trigger('click');
                                socket.emit('chat message', {entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });



        }


        current_context_field = [];

        for (var key in statementsOfContext) {
            var checkstatements = statementsOfContext[key];
            for (var l = 0; l<checkstatements.length; l++) {
                if (checkstatements[l] == e.currentTarget.dataset.uid) {
                    current_context_field.push(key);
                }
            }

        }

        console.log('context of statement clicked: ' + current_context_field);

        // Which contexts the statement should be in?
        $("#addedContexts").val(current_context_field.join());

        // Update the contexts list if anything changes in the context settings of the statement

        $("#addToContexts").tagHandler({
            assignedTags: current_context_field,
            availableTags: contextNames,
            autocomplete: true,
            afterAdd: function(tag) {
                current_context_field.push(tag);
                $("#addedContexts").val(current_context_field.join());
                console.log('contexts in statement field: ' + current_context_field.join());
            }
        });


        // Smoothly scroll up
        $("html, body").animate({ scrollTop: 0 }, "slow");


        // THIS WAS BEFORE WHEN YOU CLICK A STATEMENT ONCE

        // Shall all statements inside Entry if clicked




    });
    }


    // Summary and Insight statements

    var summary_statements = [];


    function filter_statements_summary(top_words, top_community_words, filter_origin) {
      console.log('Filering Summary top words');
      console.log(top_words);
      console.log(top_community_words);

      // Let's first filter statements that contain all the most influential top_words
      // If all 4 are nowhere to be found, we reiterate until at least the first 3, 2, 1 is found.
      // Save that

      var found_statements = [];

      var com_statements = {0:[],1:[],2:[],3:[],4:[]};

      var current_community;

      var entries_shown = [];

      var entries_ids = [];
      var entries_keywords = [];


      if (filter_origin == 'insight') {


          for (var i = 0; i < top_community_words.length; i++) {

            current_community = i;
            find_statement(top_community_words[i].nodes,1+i);
          }

      }
      else {

          find_statement(top_words,0);
      }

      function find_statement(key_terms, sweetch) {

          var nodesfound = 0;

          // Find the first entry that contains ALL the key_terms

          $(".entry").each(function(){

            if ((found_statements.length < 1 && sweetch == 0) || (sweetch > 0 && com_statements[sweetch].length < 1)) {

              var currentDiv = $(this).attr('data-uid');


              var originaltext = $(this).children('.entry-text').html();
              var statement_hashtags = $(this).attr('data-hashtags');
              var currentTimecode = $(this).attr('data-timestamp');

              for (var j = 0; j < key_terms.length; j++) {



                var search_lemma;
                  //TODO lemmas
                  // var search_lemma = window.jstemmer(pinnedNodes[j]);

                  if (sweetch == 0) {
                   search_lemma = key_terms[j].label;
                  }
                  else {
                    search_lemma = key_terms[j].name;
                  }

                    if (statement_hashtags.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                        nodesfound = nodesfound + 1;
                    }

                    if (nodesfound == key_terms.length) {
                      if (sweetch == 0) {
                        found_statements.push({text: originaltext, id: currentDiv, time: currentTimecode, origin: key_terms});
                      }
                      else if (sweetch > 0) {
                        com_statements[sweetch].push({text: originaltext, id: currentDiv, time: currentTimecode, origin: key_terms});
                      }

                    }

                    // If not all the search words are present in an entry, nullify the counter
                    if ((j == key_terms.length - 1) && nodesfound != key_terms.length) {
                      nodesfound = 0;
                    }

              }
            }

          });



          // Ok, did we already find an entry where all the top_words exist?

          if ((sweetch == 0 && nodesfound == top_words.length)) {

                console.log('Found influential node statement:');
                console.log(found_statements);

                for (var s = 0; s < found_statements.length; s++) {
                    entries_shown.push(found_statements[s]);
                }

                nodesfound = 0;

                // Ok, now let's search through each community


                for (var i = 0; i < top_community_words.length; i++) {


                  current_community = i;
                  find_statement(top_community_words[i].nodes,1+i);

                  // TODO for when 3 words are not found

                  // if (nodesfound == top_community_words[i].nodes.length) {
                  //   console.log('found community statemenets');
                  //   console.log(a_statements);
                  // }
                  // else {
                  //   top_community_words[i].nodes = top_community_words[i].nodes.slice(0,-1);
                  //   find_statement(top_community_words[i].nodes,1+i);
                  // }
                }


          }
          else if (sweetch > 0 && nodesfound == key_terms.length) {

            // Did we reach the end of all the words?

            if (current_community == top_community_words.length -1) {


              function cleanup(obj) {
                  let newObj = [];
                  let idx = 0;
                  for (var propName in obj) {
                    let prop = obj[propName];

                    if (prop !== null
                     && prop !== undefined
                     && JSON.stringify(prop) != "[]" // not empty array
                     && JSON.stringify(prop) !== "{}") { // not empty obj
                      newObj[idx] = prop[0]; // we only need one object, NOTE can be an array if we decide to get more statemetns for each community
                      idx++;
                    }
                  }
                  return newObj;
              }

              com_statements = cleanup(com_statements);

              console.log('Main cluster topics:');
              console.log(com_statements);


              for (var s = 0; s < com_statements.length; s++) {
                entries_shown.push(com_statements[s]);
              }


              function compare(a,b) {
                if (a.time < b.time)
                  return -1;
                if (a.time > b.time)
                  return 1;
                return 0;
              }

              entries_shown.sort(compare);
              console.log(entries_shown);

              for (var s = 0; s < entries_shown.length; s++) {
                entries_ids.push(entries_shown[s].id);
                entries_keywords[entries_shown[s].id] = entries_shown[s].origin;
              }

              var most_inf_nodes_str = '';
              console.log('mostinfnodes')
              console.log(most_inf_nodes);
              for (var l = 0; l < most_inf_nodes.length; l++) {
                most_inf_nodes_str += most_inf_nodes[l].label;
                if (l < most_inf_nodes.length - 1) {
                  most_inf_nodes_str += ', ';
                }
              }


              $('.entry').hide();

              var explanation_html = 'The excerpts from the text containing the main topics and the most influential terms:';

              if (filter_origin == 'insight') {
                if (polysingularity_score == 'Dispersed') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. <br><br>To increase coherency, you can make connections between different separated clusters of key terms and statements. For example, the ones below:";
                }
                else if (polysingularity_score == 'Diversified') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. It has a balanced representation of several perspectives. <br><br>You can make it more focused if you develop the ideas around the main keywords — <strong>" + most_inf_nodes_str + "</strong> — or by identifying the structural gaps between the less represented clusters and making new connections between them (to focus) or going deeper into them (to diversify even more). Like the ones below:";
                }
                else if (polysingularity_score == 'Focused') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. While it has several perspectives, it is focused on one. <br><br>You can make it more diversified if you identify the structural gaps in the graph and make connections between them — that's where the new ideas may be. For example, these two sets of key terms and statements below:";
                }
                else if (polysingularity_score == 'Biased') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. It's leaning towards and promotes a certain perspective, circulating around the most influential words — <strong>" + most_inf_nodes_str + "</strong>. <br><br>You could further develop and make connections between the different perspectives (indicated with colored topical clusters) into this discourse to make it more diversified. For example, the ones below:";
                }
                // There is a structural gap and a potential for a new idea between these two sets of key terms and statements below:
              }

              $('#explanation').show();
              $('#explanation').html(explanation_html);

              $(".entry").each(function(){

                  var currentDiv = $(this).attr('data-uid');
                  if (entries_ids.includes(currentDiv)) {

                    $(this).fadeIn(400);

                  // TODO clear up the entry text like in the above -
                  // 1. break into sentences; 2. find the first concentrate pf words; 3. keep it. 4. either create new ones or div the part non-relevant and make it opacity low or remove fully

                    var summary_helper = '';

                    for (var l = 0; l < entries_keywords[currentDiv].length; l++) {


                        if (summary_helper.length > 0) {
                          summary_helper += ', '
                        }
                        if (entries_keywords[currentDiv][l].label) {
                          summary_helper += '<a href="#" class="top_nodes">' + entries_keywords[currentDiv][l].label + '</a>';
                        }
                        else if (entries_keywords[currentDiv][l].name) {
                          summary_helper += '<a href="#" class="community_node" community="' + community_of_node[entries_keywords[currentDiv][l].name] + '">' + entries_keywords[currentDiv][l].name + '</a>';
                        }

                    }

                    if($(this).find('.summary').length == 0){


                      $(this).prepend( "<div class='summary'>key terms: " + summary_helper + "</div>" );

                      //console.log(entries_keywords[currentDiv]);
                    }

                  }

              });



              document.getElementById('entries').scrollTop = 0;
              top_nodes_activate();

              console.log('top info');
              console.log(top_community_words);


            //  $('#finds').trigger('click');


              // Make only those edges visible that belong to the statement selected

              if (pinnedNodes.length == 0) {


                  sigma.instances(0).graph.edges().forEach(function(e) {
                      var got_match = 0;
                      for (let item of e.statement_id) {
                        if (entries_ids.includes(item)) {
                            got_match += 1;
                        }
                      }
                      if (got_match > 0) {
                          e.color = e.originalColor;
                      }
                      else {
                          e.color = deselected_nodes_color;
                      }

                  });

                  // Make only those nodes visible that belong to the statement selected
                  sigma.instances(0).graph.nodes().forEach(function(n) {

                      // Is there no contexts at all? Show the node.
                      for (var g = 0; g < entries_ids.length; g++) {
                        if (!n.marked || n.marked == '0') {
                          if (nodesOfStatement[entries_ids[g]].indexOf(n.id) < 0)  {
                              n.color = deselected_nodes_color;
                              n.label = '';
                          }
                          else {
                              n.color = n.originalColor;
                              n.label = n.originalLabel;
                              n.marked = '1';
                          }
                        }
                      }
                  });
                  sigma.instances(0).refresh();

              }



            }

          }
          else {
            // All top nodes cannot be found anywhere, so we cut the list and search again
            if (sweetch == 0) {
              top_words = top_words.slice(0, -1);
              find_statement(top_words,0)
            }
            else if (sweetch > 0) {
                var reduced_query = key_terms.slice(0,-1);
                find_statement(reduced_query,sweetch);
              }
          }


      }


    }




    $("#summary").click(function(e) {
        e.preventDefault();

        // // Top influence nodes
      //   console.log(toppbc_nodes);
        //
        // // Top community nodes
        // console.log(topp_communities);

        filter_statements_summary(most_inf_nodes, most_inf_comm_nodes);

        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        // Top community terms

    });

    $("#insight").click(function(e) {
        e.preventDefault();

        var insight_nodes = [];

        if (polysingularity_score == 'Diversified') {
          if (most_inf_comm_nodes[0]) {
            insight_nodes.push(most_inf_comm_nodes[0]);
          }
          if (most_inf_comm_nodes[1]) {
            insight_nodes.push(most_inf_comm_nodes[1]);
          }
        }
        else {
          if (most_inf_comm_nodes[most_inf_comm_nodes.length-1]) {
            insight_nodes.push(most_inf_comm_nodes[most_inf_comm_nodes.length-1]);
          }
          if (most_inf_comm_nodes[most_inf_comm_nodes.length-2]) {
            insight_nodes.push(most_inf_comm_nodes[most_inf_comm_nodes.length-2]);
          }
        }


        filter_statements_summary(most_inf_nodes, insight_nodes, 'insight');

        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        // Top community terms

    });

    $("#overview").click(function(e) {
        e.preventDefault();
        $('.entry').fadeIn(400);
        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

        if (pinnedNodes.length > 0) {
          filter_statements(pinnedNodes);
        }
        filter_graph(pinnedNodes);
        $('.summary').remove();
        $('#explanation').hide();
    });



  

    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);


        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = deselected_nodes_color;
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }




    function search_graph() {

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {

                var filter = ui.item.value;



            }

        });


        $("#searchform").submit(function(event) {

            event.preventDefault();

            // What are we searching?
            var searchPhrase = $('#search').val();

            if (searchPhrase.length > 1) {

                // Clean up the search string
                searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

                // Separate terms into array
                var searchArray = searchPhrase.toLowerCase().split(" ");

                var searchPhraseLemmas = [];


                for (var j = 0; j < searchArray.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = searchArray[j].match(/[а-яА-Я]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(searchArray[j]);

                    var search_lemma = searchArray[j];

                    searchPhraseLemmas.push(search_lemma);

                }

                for (var k = 0; k < searchPhraseLemmas.length; k++) {
                    if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                        pinnedNodes.push(searchPhraseLemmas[k]);
                    }
                }

                filter_statements(pinnedNodes, "search");

            }


        });
    }








   // Replace hashtags function

    function replaceHashtags(hash){
        var replacementString = $.trim(hash);
        return ' <a href="' + forwardTo + replacementString.substr(1) +'" class="app-concept-link" target="_blank">' + replacementString + '</a>';
    }


    var hashRegex = /(?:\s|^)(?:#(?!\d+(?:\s|$)))(\w+)(?=\s|$)/gi;

    if (link_hashtags) {
        $(".entry").each(function() {
            // Retrieve the statement text from the entry, clean from html
            var originale = $(this).children('.entry-text').html();
            // Replace with hashtags
            $(this).children('.entry-text').html(originale.replace(/#(\w+)/g,  " <a href='" + forwardTo + "$1' class='app-concept-link' target='_blank'>$&</a>"));

        });
    }


    



    setTimeout(function() {
      if (localStorage.getItem("selections")) {

          var saved_selections = JSON.parse(localStorage.getItem("selections"));

          if (saved_selections[window.location.href]) {
            deletedNodes = saved_selections[window.location.href].stopnodes;
            pinnedNodes = saved_selections[window.location.href].pinnednodes;
            if (deletedNodes.length > 0) {
              socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
            }
            else {
              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }
            }



          }
          else if (interpret) {
            console.log(saved_selections);
            for (var boom in saved_selections) {
              if (boom.indexOf('/'+addcontext+'/') > -1) {
                deletedNodes = saved_selections[boom].stopnodes;
                pinnedNodes = saved_selections[boom].pinnednodes;
                console.log(deletedNodes);
                console.log(pinnedNodes);
                if (deletedNodes.length > 0) {
                  socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                  if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                  }
                }
              }
            }
          }
          else if (selected_keywords && selected_keywords.length > 0) {
            pinnedNodes = selected_keywords.split("+");


              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }


          }

      }
      // TODO clear that
      else if (selected_keywords && selected_keywords.length > 0) {
        pinnedNodes = selected_keywords.split("+");


          if (pinnedNodes.length > 0) {
            filter_statements(pinnedNodes);
          }


      }



    }, 3000);

    // TODO above is ridiculously bad - fix this timing issue


    //downloadPNG();






})();
</script>




<% include statsbelow %>
</body>
</html>
