<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/jquery.textcomplete.css' />
    <link rel="stylesheet" href="/stylesheets/side-menu.css">
    <link rel="stylesheet" href="/stylesheets/jquery-ui.min.css">
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel='stylesheet' href='/stylesheets/jquery.taghandler.css' />
    <link rel='stylesheet' href='/stylesheets/jquery.content-panel-switcher.css' />



</head>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link">
    <!-- Hamburger icon -->
    <span></span>
    </a>

    <a href="javascript:" id="graph-link">
    <!-- Graph icon -->
    <span></span>
    </a>

    <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user) { %>
        <a class="pure-menu-heading" href="/"><%= user.name %></a>
            <br>
            <ul id="contexts" class="contexts">

            </ul>
        &nbsp;<br><br>

        <% } else { %>
            <% include menu %>

        <% } %>
        </div>

    </div>


    <div id='content'>

        <div id='statements'>


            <% include messages %>

            <div id='switcher-selector' class='pure-menu pure-menu-open pure-menu-horizontal'>
                <ul>
                    <li>
                        <a id="finds" class="switcher set1">find</a>
                    </li>
                    <li class="pure-menu-selected-top">
                        <a id="adds" class="switcher set1">add</a>
                    </li>
                    <li>
                        <a id="imports" href="/import">import</a>
                    </li>
                </ul>
            </div>

            <br>
            <!-- the panel to show content -->

            <div id="switcher-panel"></div>

            <!-- form to add, later do import here -->

            <div id="adds-content" class="switcher-content set1 show">
                <form action='/post' name='submitform' id="submitform" method='post' class='pure-form'>

                        <textarea columns="40" rows="4" name='entry[body]' id="statement" placeholder='enter a note here to visualize the words and their connections, you can also use #hashtags and @mentions.'><% if (url) { %><%= urltitle %> <%= url %> @bookmarks<% } %></textarea>
                        <div id="addToContextsLabel">contexts:</div>
                        <ul id="addToContexts"></ul>
                        <input type="hidden" id="addedContexts" name="addedContexts">
                        <input type="hidden" id="context" name="context" value="<%= context %>">
                        <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                        <input type="hidden" name="statementid" value="">
                        &nbsp;<br>
                        <input type='submit' name="submit" value="save" class="pure-button pure-button-primary">

                </form>

            </div>

            <!-- form to find -->

            <div id="finds-content" class="switcher-content set1">

                <form class="pure-form" id="searchform">
                    <input type="text" id="search" size="17" maxlength="20" class="pure-input" placeholder="search...">
                    &nbsp;&nbsp;
                    <input type='submit' name="submit" value="find" class="pure-button pure-button-primary">

                </form>
            </div>




            &nbsp;<br>&nbsp;<br>

            <div id="messages"></div>



            <% entries.forEach(function(entry) { %>
                <div class='entry' data-uid='<%= entry.uid %>' data-hashtags='<%= entry.name %>'>
                    <p class='entry-text'><%- entry.text %></p>
                    <p class='entry-date'><%= entry.timestamp %></p>
                    <p class='entry-menu'>&nbsp;&nbsp;&nbsp;<a class="app-link-menu" href="#">show filtered</a></p>
                    <div class='separator'>&nbsp;</div>
                    <div id='<%= entry.uid %>' class='hidden'></div>
                    <div id='original' class='hidden'><%= entry.text %></div>
                </div>
            <% }) %>

            <% if (context && entries.length > 2) { %>
            <form action='/post' name='deletecontext' id="deletecontext" method='post' class='pure-form' onsubmit="return confirm('Deleting the context will delete all the statements inside. Are you sure?');">

                <input type="hidden" name="context" value="<%= context %>">
                <input type="hidden" id="selectedContexts" name="selectedContexts" value="">
                <input type="hidden" name="statementid" value="">
                &nbsp;<br>
                <input type='submit' name="delete" value="delete context" class="pure-button pure-button-primary">

            </form>
            <% } %>
        </div>

        <div id="graph-container"></div>

        <div id="graph-tools"><a href="javascript:" id="zoom-in"><img src="/images/zoom-in.png" border="0"></a>&nbsp;&nbsp;&nbsp;<a href="javascript:" id="zoom-out"><img src="/images/zoom-out.png" border="0"></a></div>

    </div>




</div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.js"></script>
<script src="/javascripts/sigma/plugins/sigma.plugins.animate.min.js"></script>
<script src="/javascripts/jquery.min.js"></script>
<script src="/javascripts/jquery-ui.min.js"></script>
<script src="/javascripts/string.min.js"></script>
<script src="/javascripts/underscore-min.js"></script>
<script src="/javascripts/jquery.textcomplete.js"></script>
<script src='/javascripts/jquery.autosize.js'></script>
<script src="/javascripts/ui.js"></script>
<script src="/javascripts/jquery.mobile-events.min.js"></script>
<script src="/javascripts/jquery.highlight-4.js"></script>
<script src="/javascripts/bundle-stemmer.js"></script>
<script src="/javascripts/jquery.taghandler.js"></script>
<script src="/javascripts/jquery.content-panel-switcher.js"></script>




<script>
;(function(){

// Create node ID - Name index for filtering
var nodeIDs = [];

// What are the concepts displayed - the opposite of above
var nodeNames = [];

// Let's record all the unique edges we've got

var edgesList = [];

// Create context-node index for filtering
var contextNodeID = [];

// Create statement-node index for filtering
var nodesOfStatement = [];

// What are the concepts present in the graph?
var contextNames = [];

// What are the concepts present in the graph?
var statementsOfContext = [];

var current_context_field = [];

// Path to the JSON graph file (specific context or a general one)
    <% if (addcontext) { %>
        var jsonpath = '/api/user/nodes/<%= context %>?addcontext=<%= addcontext %>';
        var addcontext = "<%= addcontext %>";
    <% } else { %>
        var jsonpath = '/api/user/nodes/<%= context %>';
        var addcontext = "";
    <% }  %>


// Get current context
var path = window.location.pathname;
var current_context = path.match(/([^\/]*)\/*$/)[1];

// These are the nodes clicked in the graph
var pinnedNodes = [];
var splicedNodes = [];
var notfoundNodes = [];

// Whats the clicked nodes in the graph
var clickedNodes = [];


// Is the user going to look at somebody else's graph?

<% if (perceivername) { %>
    jsonpath = '/api/public/nodes/<%= perceivername %>';
<% } %>


// The button to hide / show statements

$("#graph-link").click(function(e) {
    e.preventDefault();
    $("#statements").fadeToggle();
});

// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});

// Initialize JSON parser for SIGMA visualization

sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: 5,
                maxNodeSize: 16,
                minEdgeSize: 0.5,
                maxEdgeSize: 2,
                labelThreshold: 8
            }
        },
        function(sigma) {

            var i,
                    timeout = 4000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#666688',
                    len = nodes.length;


            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.
            // We also make the initial graph layout circular, so that ForceAtlas always looks the same

            for (i = 0; i < len; i++) {
                var angle = Math.PI * 2 * i / len;
                nodes[i].x = Math.cos(angle);
                nodes[i].y = Math.sin(angle);
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodes[i].color = color_context;
            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

                var unique_edge_id = '';

                // Let's see if the edge source in alphabetical order is further than its target and change places

                if (e.source > e.target) {
                    unique_edge_id = e.target + '-' + e.source;
                }
                else {
                    unique_edge_id = e.source + '-' + e.target;
                }


                // Let's make a unique list of edges to count how many there are of the same kind

                if (edgesList[unique_edge_id]) {
                    ++edgesList[unique_edge_id];

                    // TODO this is a bit of a workaround - in the future could be better to distribute the weight evenly
                    e.size = e.weight + edgesList[unique_edge_id];
                }
                else {
                    edgesList[unique_edge_id] = 1;
                    e.size = e.weight;
                }


                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement
                if (nodesOfStatement[e.statement_id]) {
                    if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                        nodesOfStatement[e.statement_id].push(e.source);
                    if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                        nodesOfStatement[e.statement_id].push(e.target);
                }
                else {
                    nodesOfStatement[e.statement_id] = [];
                    nodesOfStatement[e.statement_id].push(e.source);
                    nodesOfStatement[e.statement_id].push(e.target);
                }

                if (statementsOfContext[e.edge_context]) {
                    if (statementsOfContext[e.edge_context].indexOf(e.statement_id) < 0)
                        statementsOfContext[e.edge_context].push(e.statement_id);
                }
                else {
                    statementsOfContext[e.edge_context] = [];
                    statementsOfContext[e.edge_context].push(e.statement_id);
                }

            });

            sigma.graph.nodes().forEach(function(n) {

                // Check if the node is in additional context and if yes, give it a different color
                if (addcontext) {
                    if (contextNodeID[addcontext].indexOf(n.id) > -1 && contextNodeID[current_context].indexOf(n.id) > -1) {
                        n.color = color_addcontext;
                    }
                }


                // Save node's default color, for hide and show later
                n.originalColor = n.color;
                n.originalLabel = n.label;

                // Creating an index of node labels to IDs for filtering
                nodeIDs[n.label] = n.id;

            });


            // Make a list of all the node labels displayed in the graph (for Autofill)

            nodeNames = _.keys(nodeIDs);

            for (var w=0;w<nodeNames.length;w++) {
                nodeNames[w] = S(nodeNames[w]).dasherize().chompLeft('-').s;
            }

            // Get the context names - all the contexts that exist in the graph we just loaded
            contextNames = _.keys(contextNodeID);

            // Put the contexts into the menu
            populateContextMenu(contextNames,nodeNames);



            // Are we inside some context already?

            if (document.getElementById('context').value) {
                current_context_field.push(document.getElementById('context').value);
                $("#addedContexts").val(document.getElementById('context').value);
            }

            // if not, we're making the 'private' context default
            else {
                var lastcontexts = [];
                var laststatement = $(".entry:first").attr('data-uid');
                console.log(laststatement);
                for (var key in statementsOfContext) {
                    var reiteratestatements = statementsOfContext[key];
                    for (var i = 0; i< reiteratestatements.length; i++) {
                        if (laststatement == reiteratestatements[i]) {
                            lastcontexts.push(key);
                            console.log(key);
                        }
                    }

                }
                if (lastcontexts[0] == 'help') {
                    current_context_field.push('private');
                    $("#addedContexts").val('private');
                }
                else {
                    current_context_field = lastcontexts;
                    $("#addedContexts").val(current_context_field.join());
                }
            }

            // let's now populate contextHandlers

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                },
                afterDelete: function(tag) {
                    console.log('initiated delete from sigma');
                    for (var i=current_context_field.length-1; i>=0; i--) {
                        if (current_context_field[i] === tag) {
                            current_context_field.splice(i, 1);
                        }
                    }
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in hidden field: ' + current_context_field.join());
                }
            });

            // Do ForceAtlasLayout

            sigma.startForceAtlas2();

            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
            },timeout);

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {

                var nodeLabel = e.data.node.originalLabel;

                // Was the node clicked already? No? Add it to array of clicked nodes.
                // Highlight the clicked node in the text.

                if (splicedNodes.length > 1) {
                     pinnedNodes = [];
                     for (var p = 0; p < splicedNodes.length; p++ ){
                         pinnedNodes[p] = splicedNodes[p];
                     }
                }
                else if (splicedNodes.length == 1) {
                    pinnedNodes = [];
                    pinnedNodes[0] = splicedNodes[0];
                    splicedNodes = [];
                }

                if (pinnedNodes.indexOf(nodeLabel) < 0) {
                    pinnedNodes.push(nodeLabel);
                }
                else {
                    var pinnedIndex = pinnedNodes.indexOf(nodeLabel);
                    if (pinnedIndex > -1) {
                        pinnedNodes.splice(pinnedIndex,1);
                        $('.entry').fadeIn(400);
                    }

                }

                // console.log("node clicked, now will filter for nodes " + pinnedNodes);




                // Now show / hide statements that have the search field

                filter_statements(pinnedNodes);


            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor && pinnedNodes.indexOf(e.data.node.originalLabel) < 0) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });

            // Zoom Graph Control

            var c = sigma.camera;


            $("#zoom-in").on('click', function(e) {
                // Zoom in - single frame :
                c.goTo({
                    ratio: c.ratio / c.settings('zoomingRatio')
                });
            });

            $("#zoom-out").on('click', function(e) {
                // Zoom out - single frame :
                c.goTo({
                    ratio: c.ratio * c.settings('zoomingRatio')
                });
            });




        }
);

   var visibleentries_original = '0';

// TODO: 1. Add search function by #hashtag; 2. Attach that same function to hashtag doubleclick;

// Auto-resize to fill content;

    $(document).ready(function(){

        // Activate content switcher Set1 and set delay time for fade
        jcps.fader(300, '#switcher-panel', '.set1');

        $('#switcher-selector').on('click', 'li', function() {
            console.log("Clicked", this);
            this.className = 'pure-menu-selected-top';
        });

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        $(".entry").on('dblclick doubletap', function(e) {

            e.preventDefault();

            // Get the statement into the edit box at the top
            $("#statement").val($('.entry-text', e.currentTarget).text());

            // Retrieve that statement's ID into the hidden field (for edit or delete)
            $('input[name="statementid"]').val(e.currentTarget.dataset.uid);


            // Chang / add buttons
            document.submitform.submit.value = "edit";
            if (!document.submitform.delete) {
                $("#submitform").append('<input type="submit" name="delete" value="delete" class="pure-button"> <input type="submit" name="cancel" value="cancel" id="cancelbutton" class="pure-button">');

                // Delete text from the form in case of Cancel, remove the buttons

                document.getElementById('cancelbutton').addEventListener('click',function(){

                    $("#statement").val('');
                    document.submitform.submit.value = "save";
                    document.submitform.delete.remove();
                    document.submitform.cancel.remove();

                    // Populate contexts list next to statement add

                    current_context_field = [];

                    // Are we inside some context already?

                    if (document.getElementById('context').value) {
                        current_context_field.push(document.getElementById('context').value);
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        current_context_field.push('private');
                        $("#addedContexts").val('private');
                    }

                    $("#addToContexts").tagHandler({
                        assignedTags: current_context_field,
                        availableTags: contextNames,
                        autocomplete: true,
                        afterAdd: function(tag) {
                            current_context_field.push(tag);
                            $("#addedContexts").val(current_context_field.join());
                            console.log('contexts in cancel field: ' + current_context_field.join());
                        }
                    });

                },false);            }


            current_context_field = [];

            for (var key in statementsOfContext) {
                var checkstatements = statementsOfContext[key];
                for (var l = 0; l<checkstatements.length; l++) {
                    if (checkstatements[l] == e.currentTarget.dataset.uid) {
                        current_context_field.push(key);
                    }
                }

            }

            console.log('context of statement clicked: ' + current_context_field);

            // Which contexts the statement should be in?
            $("#addedContexts").val(current_context_field.join());

            // Update the contexts list if anything changes in the context settings of the statement

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in statement field: ' + current_context_field.join());
                }
            });


            // Smoothly scroll up
            $("html, body").animate({ scrollTop: 0 }, "slow");


        });


        var filteringstarted = 0;

        // Highlight statement if clicked once

        $(".entry").on('click', function(e) {

            e.preventDefault();

            // Shall all statements inside Entry if clicked

            if (e.target.className == 'app-link-menu') {

                if ($(this).find('.app-link-menu').text() == 'hide filtered') {
                    $(this).find('.nonmatched-sentence').fadeOut(400);
                    $(this).find('.app-link-menu').text('show filtered');
                }
                else {
                    $(this).find('.nonmatched-sentence').fadeTo(400, '0.4');
                    $(this).find('.app-link-menu').text('hide filtered');
                }

            }

            // A parameter to check if we're taking off the flag

            var alreadyClicked = null;

            // Make all entries semitrasparent


            if (pinnedNodes.length == 0) {

                $(".entry").each(function() {
                    if ($(this).css('opacity') < 1) {
                        $(this).css('opacity', '1');
                        alreadyClicked = 1;
                    }
                    else {
                        $(this).css('opacity', '0.3');
                    }
                });

                // The one clicked is not transparent

                $(this).css('opacity','1');

            }

            var keepStatementID = e.currentTarget.dataset.uid;


            console.log(keepStatementID);

            // Make only those edges visible that belong to the statement selected

            if (!alreadyClicked && pinnedNodes.length == 0) {

                sigma.instances(0).graph.edges().forEach(function(e) {

                    if (e.statement_id == keepStatementID) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = '#ddd';
                    }

                });

                // Make only those nodes visible that belong to the statement selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    // Is there no contexts at all? Show the node.
                    if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0)  {
                        n.color = '#ddd';
                        n.label = '';
                    }
                    else {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    }
                });
            }
            else if (e.target.className == 'app-link-menu') {

                 // Do nothing

            }
            else {

                if (pinnedNodes.length == 0) {
                    sigma.instances(0).graph.edges().forEach(function(e) {
                            e.color = e.originalColor;
                    });

                    // Make only those nodes visible that belong to the statement selected

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                    });
                }

            }

            sigma.instances(0).refresh();

        });





        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text('saved ' + convertedTime);
        });


        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var a = new Date(modTimestamp *1); // *1000
            var months = ['01','02','03','04','05','06','07','08','09','10','11','12'];
            var year = a.getFullYear();
            var month = months[a.getMonth()];
            var date = a.getDate();
            var hour = a.getHours();
            var min = a.getMinutes();
            var sec = a.getSeconds();
            var time = date + '/' + month + '/' + year + ' ' + hour + ':' + min + ':' + sec ;
            return time;
        }

    });







    // Textarea select conversion to hashtags

    // For now it's disabled, but will be enabled for bulk statement correction later

    /*var getSelected = function(){
        var t = '';
        if(window.getSelection) {
            t = window.getSelection();
        } else if(document.getSelection) {
            t = document.getSelection();
        } else if(document.selection) {
            t = document.selection.createRange().text;
        }
        return t;
    }

    $("#statement").select(function(eventObject) {
        var selectedText = getSelected().toString();

        var statementReplace = $("#statement").val();

        if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

            var regex = RegExp(selectedText, "g");

            var dasherized = S(selectedText).dasherize().chompLeft('-').s;

            // TODO check words for morphology (if found, alert)

            var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
            $("#statement").val(replacedString);
        }

    });*/


    // Filter out the statements that don't have any of the nodes clicked

    var timesfiltered = 0;


    function filter_statements(pinnedNodes, origin) {


        var showingsomething = 0;

        var visibleentries = visibleentries_original;

        // Hide the sentences that don't contain the terms

        $(".entry").each(function(){

            var currentDiv = $(this).attr('data-uid');

            // Retrieve the statement text from the entry, clean from html
            var originaltext = S($(this).children('.entry-text').text()).stripTags().s;

            // Make an array from sentences of that text
            var sentences = originaltext.split(/[.|!|?]\s/gi);

            var searchlemmas = [];


            // START Check what sentences contain the node clicked

            var startmark = sentences.length; // How many sentences are inside

            for (var i = 0; i < sentences.length; i++) {

                // What language is the sentence?
                var sentence_cyrillic = sentences[i].match(/[а-яА-Я]/);

                var nodesfound = 0;

                // Transform the sentence into a series of morphemes
                var sentences_lemmas = sentences[i].split(' ');


                for (var z = 0; z < sentences_lemmas.length; z++) {
                    sentences_lemmas[z] = window.jstemmer(sentences_lemmas[z]);
                }


                var sentences_lemmas_string = sentences_lemmas.join(' ');

                // Check how many of the nodes are found in This 1 Sentence i

                for (var j = 0; j < pinnedNodes.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = pinnedNodes[j].match(/[а-яА-Я]/);

                    var search_lemma = window.jstemmer(pinnedNodes[j]);

                    searchlemmas.push(search_lemma);

                    if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                        nodesfound = nodesfound + 1;
                    }
                    else if (sentence_cyrillic != null && search_cyrillic != null)  {
                        if (sentences_lemmas_string.toLowerCase().indexOf(search_lemma.toLowerCase().slice(0,-1)) > -1) {
                            nodesfound = nodesfound + 1;
                        }
                    }

                }

                // At least one node not found? Mark it as non matched

                if (nodesfound == pinnedNodes.length) {
                    sentences[i] = sentences[i] + '.';
                }
                else {
                    sentences[i] = '<div class="nonmatched-sentence">' + sentences[i] + '.</div>';
                    startmark = startmark - 1;
                }


            }

            // Make a new text from the filtered sentences
            var newtext = '';

            if (startmark == sentences.length) {
                newtext = originaltext;
                $(this).find('.entry-menu').fadeOut(500);
                showingsomething = showingsomething + 1;
            }

            else {
                newtext = sentences.join(' ');
                $(this).find('.entry-menu').fadeIn(500);
                if (startmark != 0) {
                    showingsomething = showingsomething + 1;
                }
            }

            if (startmark == 0) {

                $(this).fadeOut(500);

                visibleentries = visibleentries - 1;

                if (visibleentries == 0 && showingsomething == 0) {

                    $('.entry').fadeIn(500);

                    timesfiltered = timesfiltered + 1;

                    // This is if we want to remove the node before the last one.
                    // var posnodes = pinnedNodes.length - timesfiltered - 1;

                    var posnodes = 0;
                    var lastnode = pinnedNodes.length - 1;

                    // Final nodes to search

                    splicedNodes = [];


                    // First all of them

                    for (var k = 0; k < pinnedNodes.length; k++) {
                        splicedNodes[k] = pinnedNodes[k];
                    }

                    // Remove the one we can't find (the very first one of the bunch)

                    splicedNodes.splice(posnodes, 1);

                    // Save that one also into the list of the nodes we removed

                    notfoundNodes.push(pinnedNodes[posnodes]);

                    // This is for alert
                    // var r = confirm('No link between ' + pinnedNodes + '.\nShow entries just with ' + splicedNodes + '?');

                    // This is for plain message
                    // $('#messages').html('No entries contain "' + pinnedNodes.join(' and ') + '".<br>Showing entries that contain "' + splicedNodes.join(' and ') + '" only:<br>&nbsp;');

                    // Get the pinnedNodes back to a good shape
                    pinnedNodes = [];
                    for (var l = 0; l < splicedNodes.length; l++) {
                        pinnedNodes[l] = splicedNodes[l];
                    }

                    // Relaunch the function with the newly cleared list of pinnedNodes

                    filter_statements(pinnedNodes);

                }

            }
            else {

                // Populate statement with a new text

                $(this).children('.entry-text').html(newtext);

                $(this).find('.nonmatched-sentence').fadeOut(500);


                // Show tags that are currently used in search

                var htmlNodes = '<ul class="tags">';

                for (var x = 0; x < notfoundNodes.length; x++) {
                    htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + notfoundNodes[x] + '</a></li>';
                }

                for (var q = 0; q < pinnedNodes.length; q++) {
                    htmlNodes = htmlNodes + '<li><a href="#">' + pinnedNodes[q] + '</a></li>';
                }


                htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

                notfoundNodes = [];

                $('#messages').html(htmlNodes);



            }


        });

        // Highlight the nodes that were clicked

        $(".entry").removeHighlight();

        for (var i=0; i<pinnedNodes.length; i++) {
            $(".entry").highlight(pinnedNodes[i]);

        }


        // Show only the clicked nodes and their neighbors in the graph

        filter_graph(pinnedNodes, origin);

        // Add triggers to newly shown Tags elements

        addTagTriggers();

    }

    function addContextTriggers() {

    // TODO Add case for clicking viewAll, so it doesn't reload the page, but simply removes all filters

    // Find @Contexts and make them filter statements when clicked

        var contextsToFilter = [];


        $(".app-context-link").click(function(e) {
            e.preventDefault();
            var that = this;
            setTimeout(function() {
                var dblclick = parseInt($(that).data('double'), 10);
                if (dblclick > 0) {
                    $(that).data('double', dblclick-1);
                } else {
                    singleClick.call(that, e);
                }
            }, 300);
        }).dblclick(function(e) {
                    $(this).data('double', 2);
                    doubleClick.call(this, e);
                });


        // If double click on the menu, open it

        function singleClick (e) {

            window.location = e.target.href;

        }

        // If double click on a link, open it

        $(".app-url-link").on('click tap', function(e) {

              e.stopPropagation();

        });



        // If only one click, filter it

        function doubleClick (e) {

                var triggeredFromStatement = null;

                var addFilter = null;

                var removeFilter = null;

                // Extract filter label
                var filter = $(e.target).text();

                // Remove the first @ in case it's @mentions clicked from the statements
                if (filter.charAt(0) == '@') {
                    filter = filter.substr(1);
                    triggeredFromStatement = 1;
                }

                // Some tricks to make context switch from statements emulate menu items behavior
                if (triggeredFromStatement) {

                    // If the context is clicked inside the statement, we're just dealing with that event, not others
                    e.stopPropagation();

                    $(".menu-item-divided").each(function() {
                         if (S($(this).html()).stripTags().s == filter) {
                             if ($(this).hasClass('pure-menu-selected')) {
                                 $(this).removeClass('pure-menu-selected');
                                 removeFilter = 1;
                             }
                             else {
                                 $(this).addClass('pure-menu-selected');
                                 addFilter = 1;
                             }
                         }

                    });
                }

                // Index of that filter in our current contextsToFilter array
                var filterIndex = contextsToFilter.indexOf(filter);

                // Toggle menu highlights
                if ($(this).hasClass('pure-menu-selected') || removeFilter) {


                    // The context is to be removed
                    if (!removeFilter) {
                        $(this).removeClass('pure-menu-selected');
                    }

                    // Does it exist in the list of contexts to filter?
                    if (filterIndex > -1) {
                        contextsToFilter.splice(filterIndex, 1);
                    }

                    //TODO WTF is that?
                  /*  // Let's remove the nodes that belong to the removed context from the contextNodes
                    contextNodeID[to_remove_clean].forEach(function(element){
                        var index = $.inArray(element, contextNodes);
                        if (index>=0) contextNodes.splice(index, 1);
                    });*/


                     // Create context query for jQuery
                    var contextstring = '';

                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if (contextsToFilter.length < 1 && !$('#listall').hasClass('pure-menu-selected') && !(current_context)) {
                        $('#listall').addClass('pure-menu-selected');
                    }

                }
                else {
                    if (!addFilter) {
                        $(this).addClass('pure-menu-selected');
                    }

                    // Add this context to a list of contextToFilter
                    if (filterIndex < 0) {
                        contextsToFilter.push(filter);
                    }

                    // Show only those that have the context

                    var contextstring = '';
                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if ($('#listall').hasClass('pure-menu-selected')) {
                        $('#listall').removeClass('pure-menu-selected');
                    }


                }

                console.log(contextsToFilter);

                // Add contexts into the submission form
                document.getElementById('selectedContexts').value = contextsToFilter.join(',');

                console.log(document.getElementById('selectedContexts').value);

                // Add some remove @context functionality
                renderGraph(contextsToFilter);

         }

    }





    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);

        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = '#ddd';
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = '#ddd';
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }


    // Populate context menu

    function populateContextMenu (contextNames,nodeNames) {

        var search_field = '';

        var context_filters = '';

        var currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/">all contexts</a></li>';

        var addNewContext = '';

        var auxLinks = '';

        // The graph exists already?
        if (typeof contextNames[0] !== 'undefined' && contextNames[0] !== null) {
            contextNames.forEach(function(n) {
                if (n == current_context) {
                    // for the menu
                    context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/contexts/' + n + '">' + n + '</a></li>';
                    currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/">all contexts</a></li>';

                }
                else {
                    // for the menu
                    context_filters += '<li class="app-context-link menu-item-divided "><a href="/contexts/' + n + '">' + n + '</a></li>';
                    // for the statement add
                }
            });
        }
        // No graph, so show private
        else {
            context_filters += '<li class="app-context-link menu-item-divided"><a href="/contexts/private">private</a></li>';
        }

        addNewContext = '<li id="addNewContext" class="menu-item-divided"><a href="javascript:">+</a></li><li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';

        search_field = '';

        auxLinks = '<br>' +
                   '<li class="menu-item-small"><a href="/logout">logout</a></li>' +
                   '<li class="menu-item-small"><a href="/settings">settings</a></li>' +
                   '<li class="menu-item-small"><a href="/import">import</a></li>' +
                   '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank">export</a></li>' +
                   '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

        document.getElementById('contexts').innerHTML = search_field +
                                                        currentContextURL +
                                                        context_filters +
                                                        addNewContext +
                                                        auxLinks;



        // Select range in textarea function

        $.fn.selectRange = function(start, end) {
            return this.each(function() {
                if (this.setSelectionRange) {
                    this.focus();
                    this.setSelectionRange(start, end);
                } else if (this.createTextRange) {
                    var range = this.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            });
        };

        // When add new context is clicked, add it into textarea and select it

        $(document).on("click", "#addNewContext", function(e){

            current_context_field = [];

            $("#addToContexts").tagHandler({
                assignedTags: current_context_field,
                availableTags: contextNames,
                autocomplete: true,
                afterAdd: function(tag) {
                    current_context_field.push(tag);
                    $("#addedContexts").val(current_context_field.join());
                    console.log('contexts in statement field: ' + current_context_field.join());
                }
            });

            $("#tagInputBox").focus();


        });

        // Now time to trigger the actions we want to have when user clicks on the contexts
        addContextTriggers();

        // Initialize autofill for hashtags and contexts
        autofill(nodeNames,contextNames);


        // Autocomplete for search input
         $("#search").autocomplete({
             source: nodeNames,
             minLength: 1,
             delay: 500,
             messages: {
                 noResults: '',
                 results: function() {}
             },
             select: function(event, ui) {

                 var filter = ui.item.value;



             }

         });

        $("#searchform").submit(function(event) {

            event.preventDefault();

            // What are we searching?
            var searchPhrase = $('#search').val();

            if (searchPhrase.length > 1) {

                // Clean up the search string
                searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

                // Separate terms into array
                var searchArray = searchPhrase.toLowerCase().split(" ");

                var searchPhraseLemmas = [];


                for (var j = 0; j < searchArray.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = searchArray[j].match(/[а-яА-Я]/);

                    var search_lemma = window.jstemmer(searchArray[j]);

                    searchPhraseLemmas.push(search_lemma);

                }

                for (var k = 0; k < searchPhraseLemmas.length; k++) {
                    if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                        pinnedNodes.push(searchPhraseLemmas[k]);
                    }
                }

                filter_statements(pinnedNodes, "search");

            }


        });


    }


    function filter_graph(pins, origin){


            var toKeep = [];

            var toKeepMap = [];


            // Debug: show which nodes are clicked
            console.log(pins);


            // Are any nodes at all selected on the graph?

            if (pins.length > 0) {

            // Now we reiterate through every node in the graph

            sigma.instances(0).graph.nodes().filter(function(n) {

                var pinSearch = '';

                // Lemmataze search query if we're coming from search box

                if (origin == 'search') {
                    var nodeLemma = window.jstemmer(n.originalLabel);


                    if (nodeLemma.length > 0) {
                        pinSearch = nodeLemma;
                    }
                    else {
                        pinSearch = n.originalLabel;
                    }
                }

                // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                else {
                    pinSearch = n.originalLabel;
                }

                // Is the node one of the ones clicked?

                if (pins.indexOf(pinSearch) > -1) {

                    // The node clicked
                    var nodeId = n.id;

                    // Its neighbors
                    var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                    // We want to keep showing the neighbors of the clicked node...
                    for (key in nnodes) {
                        toKeep.push(nnodes[key]);
                    }

                    // ... and the node itself
                    toKeep.push(n);

                }

            });

            // Make array of nodes to keep unique to avoid duplicates
            toKeep = _.uniq(toKeep);


            // Now convert this to an array that will be understood by the functions below

            for (key in toKeep) {
                toKeepMap[toKeep[key].id] = toKeep[key];
            }



            sigma.instances(0).graph.nodes().forEach(function(n) {

                if (toKeepMap[n.id])  {

                    var pinSearch = '';

                    // Lemmataze search query if we're coming from search box

                    if (origin == 'search') {
                        var nodeLemma = window.jstemmer(n.originalLabel);


                        if (nodeLemma.length > 0) {
                            pinSearch = nodeLemma;
                        }
                        else {
                            pinSearch = n.originalLabel;
                        }
                    }

                    // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                    else {
                        pinSearch = n.originalLabel;
                    }


                    if (pins.indexOf(pinSearch) > -1) {
                            n.color = '#0089e0';

                        }
                        else {
                            n.color = n.originalColor;

                        }
                        n.label = n.originalLabel;

                }
                    else  {
                        n.color = '#ddd';
                        n.label = '';
                    }
            });

            sigma.instances(0).graph.edges().forEach(function(e) {
                    if (toKeepMap[e.source] && toKeepMap[e.target]) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = '#ddd';
                    }
            });

            // Since the data has been modified, we need to
            // call the refresh method to make the colors
            // update effective.

            }

            // No nodes are selected (or all are deselected) - show the whole graph

            else {

                sigma.instances(0).graph.nodes().forEach(function(n) {


                   n.color = n.originalColor;
                   n.label = n.originalLabel;


                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                   e.color = e.originalColor;

                });

            }

            sigma.instances(0).refresh();


    }

    // Autofill initialized only after Sigma above loaded and populated all the nodes

    function autofill(nodeNames,contextNames) {

        $('#statement').textcomplete([
            { // hashtags-concepts
                words: nodeNames,
                match: /\B#(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                    return '#' + word + ' ';

                }
            },
            { // html
                mentions: contextNames,
                match: /\B@(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    return '@' + mention + ' ';
                }
            },
            { // hashtags-concepts
                words: nodeNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                        return word + ' ';

                }
            }

        ]);





        $('#addcontext').textcomplete([
            { // html
                mentions: contextNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    window.open("?addcontext=" + mention, "_self");
                    return '@' + mention + '';
                }
            }
        ]);
    }

    function addTagTriggers() {


        $(".tags").on('click', function(e) {

            e.preventDefault();

            var remove_node = e.target.innerText;

            var pinnedIndex = pinnedNodes.indexOf(remove_node);



            if (pinnedIndex > -1) {

                    pinnedNodes.splice(pinnedIndex,1);

                    notfoundNodes.push(remove_node);

            }

            if (splicedNodes.length > 1) {
                pinnedNodes = [];
                for (var p = 0; p < splicedNodes.length; p++ ){
                    pinnedNodes[p] = splicedNodes[p];
                }
            }
            else if (splicedNodes.length == 1) {
                pinnedNodes = [];
                pinnedNodes[0] = splicedNodes[0];
                splicedNodes = [];
            }

            // console.log("node clicked, now will filter for nodes " + pinnedNodes);

            $('.entry').fadeIn(400);

            filter_statements(pinnedNodes);



        });

    }






})();
</script>
<% include statsbelow %>
</body>
</html>