<!DOCTYPE html>
<html>
<head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel='stylesheet' href='/stylesheets/jquery.textcomplete.css' />
    <link rel="stylesheet" href="/stylesheets/side-menu.css">


</head>
<body>
<div id="layout">
<!-- Menu toggle -->
<a href="#menu" id="menuLink" class="menu-link">
    <!-- Hamburger icon -->
    <span></span>
</a>
<div id="graph-link">&nbsp;<a href="#"><img src="/images/graph.png" border="0"></a></div>
<div id="menu">
    <div class="pure-menu pure-menu-open">
        <% if (locals.user) { %>
        <a class="pure-menu-heading" href="/"><%= user.name %></a>
            <br>
            <ul id="contexts" class="contexts">

            </ul>
        &nbsp;<br><br>
        <a href="/logout">logout</a>
        <% } else { %>
            <% include menu %>

        <% } %>
    </div>
    <% include submenu %>
</div>


<div id='content'>

<div id='statements'>
    <% include messages %>

    <form action='/post' name='submitform' id="submitform" method='post' class='pure-form'>

            <textarea columns="40" rows="4" name='entry[body]' id="statement" placeholder='enter a note here, marking the most important words with a #hashtag and the context with @mention'></textarea>
            <input type="hidden" name="context" value="<%= context %>">
            <input type="hidden" name="statementid" value="">
            &nbsp;<br>
            <input type='submit' name="submit" value="save" class="pure-button pure-button-primary">

    </form>   &nbsp;<br>&nbsp;<br>




<% entries.forEach(function(entry) { %>
<div class='entry' data-uid='<%= entry.uid %>' data-hashtags='<%= entry.name %>'>
    <p><%- entry.text %></p>
</div>
<% }) %>
</div>
<div id="graph-container"></div>
</div>




</div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.min.js"></script>
<script src="/javascripts/jquery.min.js"></script>
<script src="/javascripts/string.min.js"></script>
<script src="/javascripts/underscore-min.js"></script>
<script src="/javascripts/jquery.textcomplete.js"></script>
<script src='/javascripts/jquery.autosize.js'></script>
<script src="/javascripts/ui.js"></script>




<script>


// The button to hide / show statements

$("#graph-link").click(function(e) {
    e.preventDefault();
    $("#statements").fadeToggle();
});

// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});


// Create node ID - Name index for filtering
var nodeIDs = [];

// What are the concepts displayed - the opposite of above
var nodeNames = [];

// Create context-node index for filtering
var contextNodeID = [];

// Create statement-node index for filtering
var nodesOfStatement = [];

// What are the concepts present in the graph?
var contextNames = [];

// Path to the JSON graph file (specific context or a general one)
var jsonpath = '/api/user/nodes/<%= context %>';

// A context for comparison
var addcontext = "";


// Is the user going to look at somebody else's graph?

<% if (perceivername) { %>
    jsonpath = '/api/public/nodes/<%= perceivername %>';
<% } %>

// Initialize JSON parser for SIGMA visualization

sigma.parsers.json(
        jsonpath,
        {
            container: 'graph-container',
            renderer: {
                container: document.getElementById('graph-container'),
                type: 'canvas'
            },
            settings: {
                minNodeSize: 6,
                maxNodeSize: 16,
                labelThreshold: 10
            }
        },
        function(sigma) {

            var i,
                    timeout = 3000,
                    nodes = sigma.graph.nodes(),
                    color_context = '#666',
                    color_addcontext = '#666688',
                    len = nodes.length;


            // This is a fix for JSON
            // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.

            for (i = 0; i < len; i++) {
                nodes[i].x = Math.random();
                nodes[i].y = Math.random();
                nodes[i].size = sigma.graph.degree(nodes[i].id);
                nodes[i].color = color_context;
            }

            // We first need to save the original colors and LABELS of our
            // nodes and edges, like this:

            sigma.graph.edges().forEach(function(e) {

                e.originalColor = e.color;

                // Make an index of nodes to context
                if (contextNodeID[e.edge_context]) {
                    if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                        contextNodeID[e.edge_context].push(e.source);
                    if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                        contextNodeID[e.edge_context].push(e.target);
                }
                else {
                    contextNodeID[e.edge_context] = [];
                    contextNodeID[e.edge_context].push(e.source);
                    contextNodeID[e.edge_context].push(e.target);
                }

                // Make an index of nodes to statement
                if (nodesOfStatement[e.statement_id]) {
                    if (nodesOfStatement[e.statement_id].indexOf(e.source) < 0)
                        nodesOfStatement[e.statement_id].push(e.source);
                    if (nodesOfStatement[e.statement_id].indexOf(e.target) < 0)
                        nodesOfStatement[e.statement_id].push(e.target);
                }
                else {
                    nodesOfStatement[e.statement_id] = [];
                    nodesOfStatement[e.statement_id].push(e.source);
                    nodesOfStatement[e.statement_id].push(e.target);
                }

            });




            sigma.graph.nodes().forEach(function(n) {

                // Check if the node is in additional context and if yes, give it a different color
                if (addcontext) {
                    if (contextNodeID[addcontext].indexOf(n.id) > -1) {
                        n.color = color_addcontext;
                    }
                }

                // Save node's default color, for hide and show later
                n.originalColor = n.color;
                n.originalLabel = n.label;

                // Creating an index of node labels to IDs for filtering
                nodeIDs[n.label] = n.id;

            });



            // Make a list of all the node labels displayed in the graph (for Autocomplete)

            nodeNames = _.keys(nodeIDs);

            for (var w=0;w<nodeNames.length;w++) {
                nodeNames[w] = S(nodeNames[w]).dasherize().chompLeft('-').s;
            }

            // Get the context names - all the contexts that exist in the graph we just loaded
            contextNames = _.keys(contextNodeID);

            // Initialize autocomplete for hashtags and contexts
            autocomplete(nodeNames,contextNames);

            // Show add context comparison field
            jqshowaddcontext();

            // Put the contexts into the menu
            populateContextMenu(contextNames);

            // Do ForceAtlasLayout

            sigma.startForceAtlas2();

            // Don't run it forever not to overheat :)

            setTimeout(function() {
                sigma.stopForceAtlas2();
            },timeout);

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.

            sigma.bind('clickNode', function(e) {

                var nodeId = e.data.node.id;

                var toKeep = [];

                console.log('x: ' + e.data.node['renderer1:x'] + ', y:' + e.data.node['renderer1:y'], ', size: ' + e.data.node['renderer1:size']);


                // Which statements the node is in? (so we can keep them on the graph

                var statementsToKeep = [];

                for (var index in nodesOfStatement) {
                    if (nodesOfStatement[index].indexOf(nodeId) > -1) statementsToKeep.push(index);
                }

                sigma.graph.edges().forEach(function(e) {
                    if (statementsToKeep.indexOf(e.statement_id) > -1) {
                        toKeep.push(e.source);
                        toKeep.push(e.target);
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = '#ddd';
                    }
                });

                sigma.graph.nodes().forEach(function(n) {
                    if (toKeep.indexOf(n.id) > -1) {
                        n.color = n.originalColor;
                    }
                    else {
                        n.color = '#ddd';
                    }
                });

                sigma.refresh();



                $(".entry").each(function(){
                    var currentDiv = $(this).attr('data-uid');

                    if (statementsToKeep.indexOf(currentDiv) > -1) {
                        $(this).show();
                        $(this).css('opacity','1');
                    }
                    else {
                        $(this).hide();
                    }



                });

            });


            // Show node's label when we're over it

            sigma.bind('overNode', function(e) {
                e.data.node.label = e.data.node.originalLabel;
                sigma.refresh();
            });



            // Hide node's label when we're out of it

            sigma.bind('outNode', function(e) {
                if (e.data.node.color != e.data.node.originalColor) {
                    e.data.node.label = '';
                }
                sigma.refresh();
            });


        }
);



// Auto-resize to fill content;

    $(document).ready(function(){
        // Make texarea automatically resizeable
        $('textarea').autosize();

        // Statement edit / delete functionality

        $(".entry").on('dblclick', function(e) {

            // Get the statement into the edit box at the top
            $("#statement").val(e.currentTarget.innerText);
            console.log(e.currentTarget.dataset.uid);

            // Retrieve that statement's ID into the hidden field (for edit or delete)
            $('input[name="statementid"]').val(e.currentTarget.dataset.uid);

            // Chang / add buttons
            document.submitform.submit.value = "edit";
            if (!document.submitform.delete) {
                $("#submitform").append('<input type="submit" name="delete" value="delete" class="pure-button"> <input type="submit" name="cancel" value="cancel" onclick="clear_form(); return false;" class="pure-button">');
            }

            // Smoothly scroll up
            $("html, body").animate({ scrollTop: 0 }, "slow");
        });


        // Highlight statement if clicked once

        $(".entry").on('click', function(e) {

            // Check if it was actually the app-context-link that was clicked on

            // Make all entries semitrasparent

            $(".entry").each(function(){
                $(this).css('opacity', '0.3');
            });

            // The one clicked is not transparent

            $(this).css('opacity','1');

            var keepStatementID = e.currentTarget.dataset.uid;


            console.log(keepStatementID);
            // Make only those edges visible that belong to the statement selected

            sigma.instances(0).graph.edges().forEach(function(e) {

                if (e.statement_id == keepStatementID) {
                    e.color = e.originalColor;
                }
                else {
                    e.color = '#ddd';
                }

            });

            // Make only those nodes visible that belong to the statement selected

            sigma.instances(0).graph.nodes().forEach(function(n) {

                // Is there no contexts at all? Show the node.
                if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0)  {
                    n.color = '#ddd';
                    n.label = '';
                }
                else {
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                }
            });

            sigma.instances(0).refresh();

        });
    });





    // Clear the form if canceled and refresh buttons

    function clear_form () {
        $("#statement").val('');
        document.submitform.submit.value = "save";
        document.submitform.delete.remove();
        document.submitform.cancel.remove();
    }


    // Textarea select conversion to hashtags

    var getSelected = function(){
        var t = '';
        if(window.getSelection) {
            t = window.getSelection();
        } else if(document.getSelection) {
            t = document.getSelection();
        } else if(document.selection) {
            t = document.selection.createRange().text;
        }
        return t;
    }

    $("#statement").select(function(eventObject) {
        var selectedText = getSelected().toString();

        var statementReplace = $("#statement").val();
        var regex = RegExp(selectedText, "g");

        var dasherized = S(selectedText).dasherize().chompLeft('-').s;

        // TODO check words for morphology (if found, alert)

        var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
        $("#statement").val(replacedString);

    });





    function addContextTriggers() {

    // TODO Add case for clicking viewAll, so it doesn't reload the page, but simply removes all filters

    // Find @Contexts and make them filter statements when clicked

        var contextsToFilter = [];

        $(".app-context-link").on('click', function(e) {

                // Do not follow the link, to change that after for Public view
                e.preventDefault();

                // If the context is clicked inside the statement, we're just dealing with that event, not others
                e.stopPropagation();

                // Extract filter label
                var filter = $(e.target).text();

                // Index of that filter in our current contextsToFilter array
                var filterIndex = contextsToFilter.indexOf(filter);

                // Toggle menu highlights
                if ($(this).hasClass('pure-menu-selected')) {

                    // The context is to be removed
                    $(this).removeClass('pure-menu-selected');

                    // Does it exist in the list of contexts to filter?
                    if (filterIndex > -1) {
                        contextsToFilter.splice(filterIndex, 1);
                    }

                    //TODO WTF is that?
                  /*  // Let's remove the nodes that belong to the removed context from the contextNodes
                    contextNodeID[to_remove_clean].forEach(function(element){
                        var index = $.inArray(element, contextNodes);
                        if (index>=0) contextNodes.splice(index, 1);
                    });*/


                     // Create context query for jQuery
                    var contextstring = '';
                    for (var l=0;l<contextsToFilter.length;++l) {
                        contextstring += ":contains('@"+contextsToFilter[l]+"')";
                    }

                    // Filter statements according to the new contexts list

                    $('.entry').hide();
                    $('.entry'+contextstring).show();


                }
                else {

                    $(this).addClass('pure-menu-selected');

                    // Add this context to a list of contextToFilter
                    if (filterIndex < 0) {
                        contextsToFilter.push(filter);
                    }

                    // Create context query for jQuery to filter statements
                    var contextstring = '';
                    for (var l=0;l<contextsToFilter.length;++l) {
                        contextstring += ":contains('@"+contextsToFilter[l]+"')";
                    }

                    // Filter text statements
                    $('.entry').hide();
                    $('.entry'+contextstring).show();

                    // TODO 2. Reiterate through the nodes and select only the parts that belong to the contextsToFilter
                    // TODO 3. Reiterate through the result and see which contexts exist, remove those that are not there from the menu



                }

                // Add some remove @context functionality
                removeContext(contextsToFilter);

         });

    }





    // Remove context filters function - launched only when the first context is added into filters

    function removeContext(contexts) {

        // Creating the context index
        var contextNodes = [];

        // Nodes to hide from the view
        var removeNodes = [];

        var removeEdges = [];


        // Reset variable - we fill it in below
        cleancontexts = [];

        // Clean up the context from @ sign
        for (var m=0;m<contexts.length;++m) {
            cleancontexts.push(contexts[m]);
        }


        // First, let's reiterate the graph and make a list of nodes and edges to be removed

        if (cleancontexts.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // See if the node id fails to be present in at least one context
                cleancontexts.forEach(function(element){
                    if (contextNodeID[element].indexOf(e.source) == -1) {
                        removeNodes.push(e.source);
                    }
                    if (contextNodeID[element].indexOf(e.target) == -1) {
                        removeNodes.push(e.target);
                    }
                });

                // See if the edge context fails to be in at least one of them

                if (cleancontexts.indexOf(e.edge_context) == -1) {
                    removeEdges.push(e.id);
                }


            });
        }

        removeNodes = $.unique(removeNodes);

        removeEdges = $.unique(removeEdges);

        // Then let's reiterate the graph and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (cleancontexts.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (removeEdges.indexOf(e.id) == -1) {

                e.color = e.originalColor;

                if (removeNodes.indexOf(e.source) == -1) {
                    contextNodes.push(e.source);
                }

                if (removeNodes.indexOf(e.target) == -1) {
                    contextNodes.push(e.target);
                }

            }
            else {
                // Otherwise color the edge invisible
                e.color = '#ddd';
            }



        });

        contextNodes = $.unique(contextNodes);

        // Now that we know which nodes and edges to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (cleancontexts.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            else if (contextNodes.indexOf(n.id) < 0)  {
                n.color = '#ddd';
                n.label = '';
            }
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        sigma.instances(0).refresh();


    }




    // Populate context menu

    function populateContextMenu (contextNames) {


        var context_filters = '';

        contextNames.forEach(function(n) {
            context_filters += '<li class="app-context-link menu-item-divided "><a href="/contexts/' + n + '">' + n + '</a></li>';
        });

        document.getElementById('contexts').innerHTML = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/">all lists</a></li>' +
                                                        context_filters;

        // Now time to trigger the actions we want to have when user clicks on the contexts
        addContextTriggers();

    }



    // Show addcontext textfield when button clicked

    function jqshowaddcontext () {

        $('#showaddcontext').click(function(){

            document.getElementById('showaddcontext_host').innerHTML = '<textarea cols="5" rows="1" id="addcontext" placeholder="type in a context to compare..." style="display:block;max-width:100px;"></textarea>';
            autocomplete(nodeNames,contextNames);
            return false;

        });

    }


    // Autocomplete initialized only after Sigma above loaded and populated all the nodes

    function autocomplete(nodeNames,contextNames) {

        $('#statement').textcomplete([
            { // hashtags-concepts
                words: nodeNames,
                match: /\B#(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                    return '#' + word + ' ';

                }
            },
            { // html
                mentions: contextNames,
                match: /\B@(\w*)$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    return '@' + mention + ' ';
                }
            },
            { // hashtags-concepts
                words: nodeNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {

                        return '#' + word + ' ';

                }
            }

        ]);


        $('#addcontext').textcomplete([
            { // html
                mentions: contextNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.mentions, function (mention) {
                        return mention.indexOf(term) === 0 ? mention : null;
                    }));
                },
                index: 1,
                replace: function (mention) {
                    window.open("?addcontext=" + mention, "_self");
                    return '@' + mention + '';
                }
            }
        ]);
    }




</script>
</body>
</html>