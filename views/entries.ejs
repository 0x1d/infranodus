<!DOCTYPE html>
<html>
<head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
</head>
<body>
<% include menu %>
<% include submenu %>

<div id='content'>


    <% include messages %>

    <form action='/post' method='post'>

       <textarea rows=4 cols="45" name='entry[body]' id="statement" placeholder='Enter a note here, marking the most important words with a #hashtag and the context with @mention'></textarea>
       <br>
       <input type='submit' value='Post' />

    </form>   <br>
<div id="contexts">&nbsp;</div>
<div id="concepts">&nbsp;</div>
<% entries.forEach(function(entry) { %>
<div class='entry' data-hashtags='<%= entry.name %>'>
    <p><%- entry.text %></p>
    <!-- UID: <%= entry.uid %> -->
</div>
<% }) %>
</div>

<% if (locals.user) { %>
<div id="graph-container"></div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.min.js"></script>
<script src="/javascripts/jquery.min.js"></script>
<script src="/javascripts/string.min.js"></script>
<script src="/javascripts/underscore-min.js"></script>
<script src="/javascripts/jquery.textcomplete.js"></script>
<script src="/javascripts/jquery.overlay.js"></script>


<script>


    // Textarea select conversion to hashtags

    var getSelected = function(){
        var t = '';
        if(window.getSelection) {
            t = window.getSelection();
        } else if(document.getSelection) {
            t = document.getSelection();
        } else if(document.selection) {
            t = document.selection.createRange().text;
        }
        return t;
    }

    $("#statement").select(function(eventObject) {
        var selectedText = getSelected().toString();

        var statementReplace = $("#statement").val();
        var regex = RegExp(selectedText, "g");

        var dasherized = S(selectedText).dasherize().chompLeft('-').s;

        // TODO check words for morphology (if found, alert)

        var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
        $("#statement").val(replacedString);

    });




    // Add a method to the graph model that returns an
    // object with every neighbors of a node inside:

    sigma.classes.graph.addMethod('neighbors', function(nodeId) {
        var k,
                neighbors = {},
                index = this.allNeighborsIndex[nodeId] || {};

        for (k in index)
            neighbors[k] = this.nodesIndex[k];

        return neighbors;
    });


    // Create node ID - Name index for filtering
    var nodeIDs = [];


    // What are the concepts displayed - the opposite of above
    var nodeNames = [];

    // Create context-node index for filtering
    var contextNodeID = [];



    // Initialize JSON parser

    sigma.parsers.json(
            '/api/user/nodes',
            {
                container: 'graph-container',
                renderer: {
                    container: document.getElementById('graph-container'),
                    type: 'canvas'
                },
                settings: {
                    minNodeSize: 8,
                    maxNodeSize: 16
                }
            },
            function(sigma) {

                var i,
                        timeout = 2000,
                        nodes = sigma.graph.nodes(),
                        len = nodes.length;

                // This is a fix for JSON
                // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.

                for (i = 0; i < len; i++) {
                    nodes[i].x = Math.random();
                    nodes[i].y = Math.random();
                    nodes[i].size = sigma.graph.degree(nodes[i].id);
                    nodes[i].color = nodes[i].center ? '#333' : '#666';
                }


                // We first need to save the original colors and LABELS of our
                // nodes and edges, like this:

                sigma.graph.nodes().forEach(function(n) {
                    n.originalColor = n.color;
                    n.originalLabel = n.label;

                    // Creating an index of node labels to IDs for filtering
                    nodeIDs[n.label] = n.id;

                });
                sigma.graph.edges().forEach(function(e) {
                    e.originalColor = e.color;

                    // Make an index of nodes to context
                    if (contextNodeID[e.edge_context]) {
                        if (contextNodeID[e.edge_context].indexOf(e.source) < 0)
                            contextNodeID[e.edge_context].push(e.source);
                        if (contextNodeID[e.edge_context].indexOf(e.target) < 0)
                            contextNodeID[e.edge_context].push(e.target);
                    }
                    else {
                        contextNodeID[e.edge_context] = [];
                        contextNodeID[e.edge_context].push(e.source);
                        contextNodeID[e.edge_context].push(e.target);
                    }

                });


                // Make a list of all the node labels displayed in the graph (for Autocomplete)

                nodeNames = _.keys(nodeIDs);
                autocomplete(nodeNames);


                // Do ForceAtlasLayout

                sigma.startForceAtlas2();

                // Don't run it forever not to overheat :)

                setTimeout(function() {
                    sigma.stopForceAtlas2();
                },timeout);

                // When a node is clicked, we check for each node
                // if it is a neighbor of the clicked one. If not,
                // we set its color as grey, and else, it takes its
                // original color.
                // We do the same for the edges, and we only keep
                // edges that have both extremities colored.

                sigma.bind('clickNode', function(e) {
                    var nodeId = e.data.node.id,
                            nodeClickedClean = S(e.data.node.originalLabel).dasherize().chompLeft('-').s,
                            nodeClicked = "#" + nodeClickedClean;

                    // Let's get which neighbors to keep
                    var toKeep = sigma.graph.neighbors(nodeId);

                    // Keep the clicked node itself
                    toKeep[nodeId] = e.data.node;

                    // Create context query for jQuery
                    var conceptstring = ":contains('" + nodeClicked + "')";

                    if (contexts.length >= 0) {
                    for (var l=0;l<contexts.length;++l) {
                        conceptstring += ":contains('"+contexts[l]+"')";
                    }
                    }

                    // Filter text statements
                    $('.entry').hide();
                    $('.entry'+conceptstring).show();


                    // TODO Maybe the graph filtering below should be driven by statements, not filters

                    // Reiterate through the nodes and edges to show/hide them
                    sigma.graph.nodes().forEach(function(n) {
                        if (toKeep[n.id])  {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                        }
                        else  {
                            n.color = '#ddd';
                            n.label = '';
                        }
                    });

                    sigma.graph.edges().forEach(function(e) {
                        if (toKeep[e.source] && toKeep[e.target])
                            e.color = e.originalColor;
                        else
                            e.color = '#ddd';
                    });

                    // Since the data has been modified, we need to
                    // call the refresh method to make the colors
                    // update effective.
                    sigma.refresh();


                });


                // Show node's label when we're over it

                sigma.bind('overNode', function(e) {
                    e.data.node.label = e.data.node.originalLabel;
                    sigma.refresh();
                });



                // Hide node's label when we're out of it

                sigma.bind('outNode', function(e) {
                    if (e.data.node.color != e.data.node.originalColor) {
                        e.data.node.label = '';
                    }
                    sigma.refresh();
                });


            }
    );




    // Find @Contexts and make them filter statements when clicked

    var contexts = [];

    var context_links = document.getElementsByClassName('app-context-link');

    for (var k=0;k<context_links.length;++k) {
        context_links[k].addEventListener('click', function(e) {

            // Do not follow the link, to change that after for Public view
            e.preventDefault();

            // Extract filter label
            var filter = e.srcElement.innerText.substr(1);

            // Save it in contexts if it's not there yet
            var index = contexts.indexOf(e.srcElement.innerText);
            if (index < 0) {
                contexts.push('@'+filter);
            }

            // Create context query for jQuery
            var contextstring = '';
            for (var l=0;l<contexts.length;++l) {
                contextstring += ":contains('"+contexts[l]+"')";
            }

            // Filter text statements
            $('.entry').hide();
            $('.entry'+contextstring).show();



            // Display @contexts above the statements

            var context_filters = '';

            contexts.forEach(function(n) {
                context_filters += '<a href="javascript:" class="remove-context">'+n+'</a> ';
            });

            document.getElementById('contexts').innerHTML = 'contexts: ' + context_filters;

            console.log(contexts);

            // Add some remove @context functionality
            removeContext();





        });
    }







    // Remove context filters function - launched only when the first context is added into filters

    function removeContext() {

        // Creating the context index
        var contextNodes = [];

        // Nodes to hide from the view
        var removeNodes = [];

        var removeEdges = [];


        // Reset variable - we fill it in below
        cleancontexts = [];

        // Clean up the context from @ sign
        for (var m=0;m<contexts.length;++m) {
            cleancontexts.push(contexts[m].substr(1));
        }

        // First, let's reiterate the graph and make a list of nodes and edges to be removed

        if (cleancontexts.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // See if the node id fails to be present in at least one context
                cleancontexts.forEach(function(element){
                    if (contextNodeID[element].indexOf(e.source) == -1) {
                        removeNodes.push(e.source);
                    }
                    if (contextNodeID[element].indexOf(e.target) == -1) {
                        removeNodes.push(e.target);
                    }
                });

                // See if the edge context fails to be in at least one of them

                if (cleancontexts.indexOf(e.edge_context) == -1) {
                    removeEdges.push(e.id);
                }


            });
        }

        removeNodes = $.unique(removeNodes);

        removeEdges = $.unique(removeEdges);

        // Then let's reiterate the graph and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (cleancontexts.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (removeEdges.indexOf(e.id) == -1) {

                e.color = e.originalColor;

                if (removeNodes.indexOf(e.source) == -1) {
                    contextNodes.push(e.source);
                }

                if (removeNodes.indexOf(e.target) == -1) {
                    contextNodes.push(e.target);
                }

            }
            else {
                // Otherwise color the edge invisible
                e.color = '#ddd';
            }



        });

        contextNodes = $.unique(contextNodes);

        // Now that we know which nodes and edges to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (cleancontexts.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            else if (contextNodes.indexOf(n.id) < 0)  {
                n.color = '#ddd';
                n.label = '';
            }
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        sigma.instances(0).refresh();



        var remove_context_links = document.getElementsByClassName('remove-context');

        for (var j=0;j<remove_context_links.length;++j) {
            remove_context_links[j].addEventListener('click', function(e) {

                // Do not follow the link, to change that after for Public view
                e.preventDefault();

                // Extract the context to remove
                var to_remove = e.srcElement.innerText;

                // Extract the clean context name to remove
                var to_remove_clean = e.srcElement.innerText.substr(1);

                // Find its index in contexts array and remove it
                var index = contexts.indexOf(to_remove);
                if (index > -1) {
                    contexts.splice(index, 1);
                }

                // Let's remove the nodes that belong to the removed context from the contextNodes
                contextNodeID[to_remove_clean].forEach(function(element){
                    var index = $.inArray(element, contextNodes);
                    if (index>=0) contextNodes.splice(index, 1);
                });



                // Create context query for jQuery
                var contextstring = '';
                for (var l=0;l<contexts.length;++l) {
                    contextstring += ":contains('"+contexts[l]+"')";
                }

                // Filter statements according to the new contexts list

                $('.entry').hide();
                $('.entry'+contextstring).show();




                // Update the filters list after the removal

                if (contexts.length > 0) {

                    var context_filters = '';

                    contexts.forEach(function(n) {
                        context_filters += '<a href="javascript:" class="remove-context">'+n+'</a> ';
                    });

                    document.getElementById('contexts').innerHTML = 'contexts: ' + context_filters;
                }
                else {
                    document.getElementById('contexts').innerHTML = '&nbsp;';
                }

                // Launch itself to update the @contexts cache
                removeContext();

            });
        }
    }


    // Find #Concepts and make them filter statements when clicked

    var concept_links = document.getElementsByClassName('app-concept-link');


    for (var k=0;k<concept_links.length;++k) {

        concept_links[k].addEventListener('click', function(e) {

            e.preventDefault();

            var filter = e.srcElement.innerText.substr(1);

            // Create context query for jQuery
            var conceptstring = ":contains('" + filter + "')";

            if (contexts.length >= 0) {
                for (var l=0;l<contexts.length;++l) {
                    conceptstring += ":contains('"+contexts[l]+"')";
                }
            }

            // Filter text statements
            $('.entry').hide();
            $('.entry'+conceptstring).show();


            // TODO Create index of nodes ID to avoid iteration within iteration
            // TODO move the node hiding code into a separate function for re-use

            sigma.instances(0).graph.nodes().filter(function(n) {
                if (n.originalLabel === filter) {
                    var nodeId = n.id,
                            toKeep = sigma.instances(0).graph.neighbors(nodeId);
                    toKeep[nodeId] = n;

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                        if (toKeep[n.id])  {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                        }
                        else  {
                            n.color = '#ddd';
                            n.label = '';
                        }
                    });

                    sigma.instances(0).graph.edges().forEach(function(e) {
                        if (toKeep[e.source] && toKeep[e.target])
                            e.color = e.originalColor;
                        else
                            e.color = '#ddd';
                    });

                    // Since the data has been modified, we need to
                    // call the refresh method to make the colors
                    // update effective.
                    sigma.instances(0).refresh();
                }
            });





        });

    }


    // Autocomplete initialized only after Sigma above loaded and populated all the nodes

    function autocomplete(nodeNames) {


        $('#statement').textcomplete([
            { // tech companies
                words: nodeNames,
                match: /\b(\w{2,})$/,
                search: function (term, callback) {
                    callback($.map(this.words, function (word) {
                        return word.indexOf(term) === 0 ? word : null;
                    }));
                },
                index: 1,
                replace: function (word) {
                    return '#' + word + ' ';
                }
            }
        ]).overlay([
                    {
                        match: /\B#\w+/g,
                        css: {
                            'background-color': '#d8dfea'
                        }
                    }
         ]);
    }



</script>
<% } %>

</body>
</html>