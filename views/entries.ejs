<!DOCTYPE html>
<html>
<head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
</head>
<body>
<% include menu %>
<% include submenu %>

<div id='content'>


    <% include messages %>

    <form action='/post' method='post'>

       <textarea rows=4 cols="45" name='entry[body]' placeholder='Enter a note here, marking the most important words with a #hashtag'></textarea>
       <br>
       <input type='submit' value='Post' />

    </form>     <br>&nbsp;
<br>
<% entries.forEach(function(entry) { %>
<div class='entry' data-hashtags='<%= entry.name %>'>
    <p><%- entry.text %></p>
    <!-- UID: <%= entry.uid %> -->
</div>
<% }) %>
</div>

<% if (locals.user) { %>
<div id="graph-container"></div>

<script src="/javascripts/sigma/sigma.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.parsers.json.min.js"></script>
<script src="/javascripts/sigma/plugins/sigma.layout.forceAtlas2.min.js"></script>
<script src="/javascripts/jquery.min.js"></script>
<script src="/javascripts/string.min.js"></script>

<script>


    // Add a method to the graph model that returns an
    // object with every neighbors of a node inside:

    sigma.classes.graph.addMethod('neighbors', function(nodeId) {
        var k,
                neighbors = {},
                index = this.allNeighborsIndex[nodeId] || {};

        for (k in index)
            neighbors[k] = this.nodesIndex[k];

        return neighbors;
    });

    // Initialize JSON parser

    sigma.parsers.json(
            '/api/user/nodes',
            {
                container: 'graph-container',
                renderer: {
                    container: document.getElementById('graph-container'),
                    type: 'canvas'
                },
                settings: {
                    minNodeSize: 8,
                    maxNodeSize: 16
                }
            },
            function(sigma) {

                var i,
                        timeout = 2000,
                        nodes = sigma.graph.nodes(),
                        len = nodes.length;

                // This is a fix for JSON
                // Sigma requires that nodes have X, Y, Size and Color properties which our JSON doesn't have. So we add them.

                for (i = 0; i < len; i++) {
                    nodes[i].x = Math.random();
                    nodes[i].y = Math.random();
                    nodes[i].size = sigma.graph.degree(nodes[i].id);
                    nodes[i].color = nodes[i].center ? '#333' : '#666';
                }


                // We first need to save the original colors and LABELS of our
                // nodes and edges, like this:

                sigma.graph.nodes().forEach(function(n) {
                    n.originalColor = n.color;
                    n.originalLabel = n.label;
                });
                sigma.graph.edges().forEach(function(e) {
                    e.originalColor = e.color;
                });


                // Do ForceAtlasLayout

                sigma.startForceAtlas2();

                // Don't run it forever not to overheat :)

                setTimeout(function() {
                    sigma.stopForceAtlas2();
                },timeout);

                // When a node is clicked, we check for each node
                // if it is a neighbor of the clicked one. If not,
                // we set its color as grey, and else, it takes its
                // original color.
                // We do the same for the edges, and we only keep
                // edges that have both extremities colored.

                sigma.bind('clickNode', function(e) {
                    var nodeId = e.data.node.id,
                            nodeClicked = "#" + S(e.data.node.originalLabel).dasherize().chompLeft('-').s,
                            toKeep = sigma.graph.neighbors(nodeId);
                    toKeep[nodeId] = e.data.node;

                    // Filter statements
                    $('.entry').each(function(){
                        $('.entry').hide();
                        $('.entry:contains('+nodeClicked+')').show();
                        return false;
                    })


                    sigma.graph.nodes().forEach(function(n) {
                        if (toKeep[n.id])  {
                            n.color = n.originalColor;
                            n.label = n.originalLabel;
                        }
                        else  {
                            n.color = '#ddd';
                            n.label = '';
                        }
                    });

                    sigma.graph.edges().forEach(function(e) {
                        if (toKeep[e.source] && toKeep[e.target])
                            e.color = e.originalColor;
                        else
                            e.color = '#ddd';
                    });

                    // Since the data has been modified, we need to
                    // call the refresh method to make the colors
                    // update effective.
                    sigma.refresh();
                });

                // When the stage is clicked, we just color each
                // node and edge with its original color.
                sigma.bind('clickStage', function(e) {
                    sigma.graph.nodes().forEach(function(n) {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    });

                    sigma.graph.edges().forEach(function(e) {
                        e.color = e.originalColor;
                    });

                    // UnFilter statements
                    $('.entry').each(function(){
                        $('.entry').show();
                        return false;
                    })

                    // Same as in the previous event:
                    sigma.refresh();
                });
            }
    );





</script>
<% } %>

</body>
</html>