<!DOCTYPE html>
<html>
<%- include('components/entries/header') %>
<%- include('dependencies/entries') %>
<%- include('components/common/index') %>
<%- include('components/entries/index') %>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link editorpane">
    <!-- Hamburger icon -->
    <span></span>
    </a>
     <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/apps"><%= user.name %></a>
            <% } %>
                <br>
                <ul id="contexts" class="contexts">

                </ul>
            &nbsp;<br><br>

        <% } else { %>
            <%- include('components/common/menu', {contextlist:contextlist}); %>

        <% } %>
        </div>
   </div>
     <div id='content'>

          <%- include('components/entries/StatementMenu'); %>
           
          <%- include('components/entries/StatementSidePanel/index',
                {entries, perceivername, addcontext, user, context, contextpublic, url, urltitle}); %>

          <%- include('components/entries/Graph/GraphCanvas'); %>

          <%- include('components/entries/Analytics/BiasSlider'); %>   

          <%- include('components/entries/VoiceInput/VoiceInputLiveText'); %>

          <%- include('components/entries/Analytics/AnalyticsPane'); %>

      </div>

    </div>

</div>

<%- include('components/entries/ContextMenu') %>
<%- include('components/entries/Graph/Graph') %>
<%- include('components/entries/Graph/GraphTags') %>
<%- include('components/entries/Graph/GraphEdit') %>
<%- include('components/entries/Graph/GraphMenu') %>
<%- include('components/entries/Graph/Walkthrough') %>
<%- include('components/entries/MidiController') %>
<%- include('components/entries/VoiceInput/VoiceInputController') %>

<script>
;(function(){



// Auto-resize to fill content;

    // This launches only when all other stuff from above have loaded
    $(document).ready(function(){

     
         // Add hooks on all tooltips
        $('.tooltip').tooltipster({
            theme: 'tooltipster-noir',
            position: 'left',
            maxWidth: 200,
            delay: 1000
        });

       

    

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        var filteringstarted = 0;

        // Add the hooks to the newly rendered entries again
        entryClick();

        // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
        <% if (!perceivername) { %>
          entryDoubleClick();
        <% } %>


        // Highlight statement if clicked once

        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text(convertedTime);
        });

        // TODO move the fucntion out
        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var time = moment(modTimestamp, 'x').fromNow();
            return time;
        }


        // Some more graph interface settings

     

        // Did we receive a global setting to hide the editor pane?

        if (hide_edit) {
          $('.editorpane').each(function() {
            $(this).hide();
          });
        }

        if (localStorage.getItem('timer') == 1) {
          ($("#timer-link").trigger('click'));
        }


        // Document Ready end

        });


    
    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);


        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = deselected_nodes_color;
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }





    // TODO to move to a separate file that will load after all
    // This function checks if the user had any nodes selected and selects them for him, but only after the graph is loaded

    var selected_keywords = getUrlVars()["keywords"];

    setTimeout(function() {
      if (localStorage.getItem("selections")) {

          var saved_selections = JSON.parse(localStorage.getItem("selections"));

          if (saved_selections[window.location.href]) {
            deletedNodes = saved_selections[window.location.href].stopnodes;
            pinnedNodes = saved_selections[window.location.href].pinnednodes;
            if (deletedNodes.length > 0) {
              socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
            }
            else {
              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }
            }



          }
          else if (interpret) {
            console.log(saved_selections);
            for (var boom in saved_selections) {
              if (boom.indexOf('/'+addcontext+'/') > -1) {
                deletedNodes = saved_selections[boom].stopnodes;
                pinnedNodes = saved_selections[boom].pinnednodes;
                console.log(deletedNodes);
                console.log(pinnedNodes);
                if (deletedNodes.length > 0) {
                  socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                  if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                  }
                }
              }
            }
          }
          else if (selected_keywords && selected_keywords.length > 0) {
            pinnedNodes = selected_keywords.split("+");


              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }


          }

      }
      // TODO clear that
      else if (selected_keywords && selected_keywords.length > 0) {
        pinnedNodes = selected_keywords.split("+");


          if (pinnedNodes.length > 0) {
            filter_statements(pinnedNodes);
          }


      }



    }, 3000);

    // TODO above is ridiculously bad - fix this timing issue


    //downloadPNG();



})();
</script>




<% include statsbelow %>
</body>
</html>
