<!DOCTYPE html>
<html>
<%- include('components/entries/header') %>
<%- include('components/common/index') %>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link editorpane">
    <!-- Hamburger icon -->
    <span></span>
    </a>
     <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/apps"><%= user.name %></a>
            <% } %>
                <br>
                <ul id="contexts" class="contexts">

                </ul>
            &nbsp;<br><br>

        <% } else { %>
            <%- include('components/common/menu', {contextlist:contextlist}); %>

        <% } %>
        </div>
   </div>
     <div id='content'>

          <%- include('components/entries/StatementMenu'); %>
           
          <%- include('components/entries/StatementSidePanel/index',
                {entries, perceivername, addcontext, user, context, contextpublic, url, urltitle}); %>


        <div id="graph-container"></div>

        <div id="biasindex" class="tooltip" title="shows how diversified the discourse network structure is: biased > focused > diverse > dispersed"><div class="slidercaption">network diversity level: </div>
        <div class="slidercontainer">
        <input type="range" min="1" max="100" value="50" class="slider" disabled id="biasRange">
        </div></div>

        <div id="livetext"></div>

        <div id="messages">
        <% if (!perceivername) { %>
          <a href="javascript:" id="addnode" class="tooltip editorpane" title="add a node in the graph"></a>
        <% } %>
          <a href="javascript:" id="searchnode" class="tooltip" title="find a node in the graph"></a>
          <form action="" method="" class="pure-form" id="addnodeform"><input type="text" id="addnodeinput" size="10" placeholder="#node_name" class="pure-input"></form>
          <div id="pinnedlist"><a href="javascript:" id="undo" class="tooltip" title="remove selected nodes and reset graph" ></a><a href="javascript:" id="deletenodes" class="tooltip" title="remove selected nodes from the graph"></a><div id="pinnednodeslist"></div><div id="stopnodeslist"></div><a href="javascript:" id="stopsave" class="tooltip" title="save to permanent stopwords"></a></div></div>

          

         <div id="analytics"></div>


            <a href="javascript:" class="tooltip editorpane" title="graph analytics" id="analyticsbutton"><div id="analyticscaption"></div></a>
      </div>





    </div>





</div>

<%- include('dependencies/entries') %>
<%- include('components/entries/index') %>
<%- include('components/entries/Graph') %>
<%- include('components/entries/GraphMenu') %>



             <script>
;(function(){

  


    // Get URL variables in the form of an array
    // TODO can be moved out

 



    // First we query URL parameters

    /* {

     Which queries to add to search keywords from the graph:
     "go_next_add": "keyword",
     Which website to refer people to with the keywords (include search string with URL)
     "go_next_url" : "http://soundcloud.com/search?q="
     }

     */

 

    var link_hashtags = getUrlVars()["link_hashtags"];

    var convert_hashtags = getUrlVars()["convert_hashtags"];



    var mute = getUrlVars()["mute"];

    var speech = getUrlVars()["speech"];

    var walkthrough = getUrlVars()["walkthrough"];

    var newcontextname = getUrlVars()["newcontextname"];


    var customization = ' ';


    var interpret = getUrlVars()["interpret"];

    var highlight = getUrlVars()["highlight"];

    var missing = getUrlVars()["missing"];

    var add_statement = getUrlVars()["statement"];

    var selected_keywords = getUrlVars()["keywords"];

    var voice_continues = getUrlVars()["voice_continues"];

    // Getting the details parsed from routes/entries.js to see how to show the graph

    <% if (locals.user && locals.user.voice_continues != undefined && locals.user.voice_continues != '00') { %>
        voice_continues = '<%=locals.user.voice_continues%>';
    <% } %>

    



    // Let's define some walkthrough tutorials, depending on the situation
    var walkthroughtype = 'default';

    <% if (perceivername) { %>
    walkthroughtype = 'external';
    <% } %>

    
    // For collaboration - Socket.IO chat
    var collaborate_invite = getUrlVars()["collaborate"];



// MAIN SETTINGS START


var current_context_field = [];




var addcontext = '';

var maxnodes = '';

// Get the setting from user DB how many max nodes we show
<% if (maxnodes) { %>
  maxnodes = <%= maxnodes %>;
<% } %>




// These are the nodes clicked in the graph

var global_totalnodes = 0;

// These are for Summary / Insight functionality

var most_inf_nodes = [];

var most_inf_comm_nodes = {};

var polysingularity_score = 0;

// Whats the clicked nodes in the graph
var clickedNodes = [];

// What are the shown nodes on the graph;
var shownNodes = [];

// Inactivity timeout
var inactiveTimeout = null;

// This variable shows if there was a meaningful interaction with the graph yet
var graphInteraction = null;

// Loaded with graph only?
var graphOnly = null;


// Who posted the message?
var selfPosted = null;


// Socket.IO chat collaborate

// This matrix relates each URL path to each unique chat that can happen within that room

var collaborate_matrix = {};

var collaborate_room = urlPath + '/';

var collaborate_id = '';

var collaborate_content = '';

var collaborate_message = '';

var collaborate_html = '';

var collaborate_storage = JSON.parse(localStorage.getItem("collaborate"));








// This is for the option to emit and receive MIDI signals for the graph

var midi = '';

// TODO for desktop browses that support webwork (not iphone): webworker: true, slowdown: 300



// Some settings from routes/entries.js

<% if (locals.user && !locals.vieweduser) { %>
var inlanguage = '<%= user.inlanguage %>';

<% if (locals.user.label_threshold) { %>
in_label_threshold = '<%= user.label_threshold %>';
<% } %>

<% if (locals.user.midi) { %>
midi = '<%= user.midi %>';
<% } %>



if (!graphPalette) {
 graphPalette = '<%= user.palette %>';
}

<% if (locals.user.customization) { %>
 customization = '<%= user.customization %>';
<% } %>

<% if (locals.user.maxnodes) { %>
 maxnodes = '<%= user.maxnodes %>';
<% } %>



<% } else { %>

  <% if (locals.vieweduser) { %>

  most_influential = '<%= vieweduser.topnodes %>';

  in_label_threshold = '<%= vieweduser.label_threshold %>';

  if (!graphPalette) {
    graphPalette = '<%= vieweduser.palette %>';
  }

  if (!background) {
    background = '<%= vieweduser.background %>';
  }

  <% } %>

<% } %>



var deselected_nodes_color = '#ddd';

var forcedatlas_running = false;

var adding_entry = false;

// This is a very stupid way to change the interface color to dark if the setting is on (through URL or user settings)

if (background == 'dark') {
  $('#graph-container').addClass('graph-dark');
  $('#analyticsbutton').addClass('analyticsbutton-dark');
  $('.entry').addClass('entry-dark');
  $('.entry-text').addClass('entry-text-dark');
  $('#analytics').addClass('analytics-dark');
  $('#entryform').addClass('entryform-dark');
  $('#addnodeinput').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('#statement').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('body').css('color', '#aaaab5');
  // $('li.pure-menu-selected-top a').css('backgroundColor', '#888888');
  $('.menu-link').css('background', 'rgba(250, 250, 250, 0.4)');
  $('#graph-link').addClass('graph-link-dark');
  $('#chat-link').addClass('chat-dark');
  $('#addnode').addClass('addnode-dark');
  $('#go_next').addClass('go_next-dark');
  $('#reloadbutton').addClass('reloadbutton-dark');
  $('#improve-layout').addClass('improve-layout-dark');
  $('#abstract-layout').addClass('abstract-layout-dark');
  $('#walkthrough').addClass('walkthrough-dark');
  $('#zoom-in').addClass('zoom-in-dark');
  $('#zoom-out').addClass('zoom-out-dark');
  $('#microphone-link').css({'background-image': "url('/images/microphone-white.png')", "opacity": "0.6"});
  $('#addcontext-link').css({'background-image': "url('/images/compare-white.png')", "opacity": "0.6"});
  $('#deletecontextbutton').addClass('deletecontextbutton-dark');
  $('#collaborate-link').addClass('collaborate-link-dark');
  $('#import-link').addClass('import-link-dark');
  $('#windowdown-link').addClass('windowdown-link-dark');
  $('#statements-link').addClass('statements-link-dark');
  $('#timer-link').addClass('timer-link-dark');
  $('#watch-link').addClass('watch-link-dark');
  if (graphPalette == 'contrast') {
      deselected_nodes_color = '#555';
  }
  else {
      deselected_nodes_color = '#444';
  }
}

$('#analyticscaption').html(customization);


// locals.user basically checks the user settings

<% if (locals.user) { %>
<% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>

var output;
var input;

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

WebMidi.enable(function (err) {

  if (err) {
    console.log("WebMidi could not be enabled.", err);
  } else {


    console.log("WebMidi enabled!");
    console.log(WebMidi.inputs);
    console.log(WebMidi.outputs);
    console.log(WebMidi.time);

    output = WebMidi.outputs[0];
    console.log('midi substr ' + midi.substr(4,2));

    if (midi.substr(4,2) != '00') {
      output = WebMidi.outputs[parseInt(midi.substr(4,2))];
    }

    if (output) {
      console.log('MIDI device connected');
    }
    else {
      console.log('MIDI out device not connected');
    }

    input = WebMidi.inputs[0];

    if (input) {

      // Listen for a 'note on' message on all channels
      input.addListener('noteon', "all",
        function (e) {
          console.log("Received 'noteon' message (" + e.note.name + e.note.octave + ").");
          console.log(e);

          if (midi.substr(14,2) != '' && midi.substr(14,2) != undefined && midi.substr(14,2) != 'no') {
            $('#statement').val($('#statement').val() + '#' + e.note.name.replace(/#/g,'') + e.note.number + ' ');
          }

        }
      );
    }
    else {
      console.log('MIDI input device not connected');
    }

  }



});

<% } %>
<% } %>


// If the user opened a URL with collaborate=xxxxxx then they join the room that's the "url_path/xxxxxx"
if (collaborate_invite) {
    collaborate_id = collaborate_invite;
}
// Otherwise they join a room which is "url_path/randomnumber"
else {
    collaborate_id = Math.round((Math.random() * 1000000));
}

collaborate_matrix[collaborate_room] = collaborate_room + collaborate_id;

// console.log('room id');
// console.log(collaborate_matrix[collaborate_room]);

if (!collaborate_invite) {
    if (collaborate_storage) {

        if (collaborate_storage[collaborate_room]) {
            if (collaborate_storage[collaborate_room].length > 0) {
                collaborate_matrix[collaborate_room] = collaborate_storage[collaborate_room];
                collaborate_id = collaborate_matrix[collaborate_room].split("/").pop();
            }
        }
    }

    // Now in case the original user reloads the page by error, they'll get the new collaborate ID, so we avoid that by storing their data
    localStorage.setItem("collaborate", JSON.stringify(collaborate_matrix));
}

    // Collaboration features realized using Socket.IO
    // On connection to server get the id of the current chat "room", which is actually the folder/URL of the current user

    socket.on('connect', function(){
        console.log('connected');
        socket.emit('login', {user: current_user, context: current_context, id: collaborate_matrix[collaborate_room]});
    });


    socket.on('startChat', function(data){
        console.log('chat started');
        if(data.boolean && data.id == collaborate_matrix[collaborate_room]) {
            console.log('in chat room ' + data.id);
            var collab_content = $('#collaborate-link').tooltipster('content');
            $('#collaborate-link').tooltipster('content', 'Collaboration is ON');
            $('#collaborate-link').addClass('is-collab');
            $('#collaborate-link').tooltipster('show');
            setTimeout(function() {
                $('#collaborate-link').tooltipster('hide');
                setTimeout(function() {
                    $('#collaborate-link').tooltipster('content', collab_content);
                }, 1000);

            }, 2000);
        }
    });

    socket.on('leave', function(msg){
        console.log('partner left');
        console.log(msg.people);
        if (msg.people < 2) {
          $('#collaborate-link').removeClass('is-collab');
          var collab_content = $('#collaborate-link').tooltipster('content');
          $('#collaborate-link').tooltipster('content', 'Collaboration is OFF');
          $('#collaborate-link').tooltipster('show');
          setTimeout(function() {
              $('#collaborate-link').tooltipster('hide');
              setTimeout(function() {
                  $('#collaborate-link').tooltipster('content', collab_content);
              }, 1000);
          }, 2000);
        }
    });

    socket.on('tooMany', function(data){

        console.log('one too many');
        alert('There are already 2 users working on this context and this is our max so far. If you think it is a mistake, please, check if any of your extra browser tabs are opened.');
        window.location.href = 'http://' + hostsite + '/' + 'home' + '/edit';

    });






    // Dynamic graph functionality

    // It basically makes only the nodes / edges of the graph visible that the user is currently seeing in the statements div

    var dynamic_graph = 0;

    var dynamic_watch = 0;

    $("#timer-link").click(function(e) {
      if (dynamic_graph == 0) {
        //localStorage.setItem('timer',1);
        dynamic_graph = 1;
        $('#timer-link').addClass('timer-link-on');
        $('#entries').scrollTop($('#entries').scrollTop() + 1);
      }
      else {
        dynamic_graph = 0;
        //localStorage.setItem('timer',0);
        $('#timer-link').removeClass('timer-link-on');
        entryScroll('',true);
        if (dynamic_watch == 1) {
          $("#watch-link").trigger('click');
        }

      }

    });



    // When scroll happens if the dynamic graph is on, show which uids are visible

    var scroll_signal;

    $("#entries").scroll(function() { //.box is the class of the div

          if (dynamic_graph == 1) {

            var ventries = [];


              $('#entries').children(".entry").each(function(){
                  var vresult;
                  vresult = checkInView(this,true);
                  if (vresult == true) {
                      if (ventries.indexOf($(this).attr('data-uid')) == -1) {
                          ventries.push($(this).attr('data-uid'));
                      }
                  }

                //  result2 += " " +  checkInView($(e),true);
               });

              entryScroll(ventries);



              if (!$(this).is(':animated')) {

                var current_scroll = ($(this).scrollTop());
                var max_scroll = $(this)[0].scrollHeight - $(this).height();

                if (current_scroll == max_scroll && scroll_signal != 'bottom') {
                  $(this).scrollTop(0);
                  scroll_signal = 'top';
                }
                else if (current_scroll == 0 && scroll_signal != 'top') {
                  $(this).scrollTop($(this)[0].scrollHeight);
                  scroll_signal = 'bottom';
                }

              }


          }

    });


    // Dynamically watch the graph unfold

    $("#watch-link").click(function(e) {

      if (dynamic_watch == 0) {
          var speed_scroll = 1000;
          dynamic_watch = 1;

          $('#watch-link').addClass('watch-link-on');

          if (dynamic_graph == 0) {
            $("#timer-link").trigger('click');
          }

          var max_scroll = $('#entries')[0].scrollHeight - $('#entries').height();

          function autoScrollUp(){
            var current_scroll = ($('#entries').scrollTop());
            var scroll_to = max_scroll;
            var num_entries =  $('.entry').length;

            if (current_scroll == max_scroll) {
              $('#entries').scrollTop(0);
              current_scroll = $('#entries').scrollTop();
            }
            var play_time = Math.round(((max_scroll - current_scroll)/max_scroll) * num_entries * speed_scroll);

            $("#entries").animate({scrollTop: scroll_to},play_time,"linear", autoScrollUp); // and animate
          }
          autoScrollUp();

      }
      else  {
        dynamic_watch = 0;
        $('#watch-link').removeClass('watch-link-on');
        $("#entries").stop();

      }
    });

    // TODO move this general function out — this is just to check which elements inside (#entries) are visible for the dynamic graph feature above

    function checkInView(elem,partial)
      {
          var container = $("#entries");
          var contHeight = container.height();
          var contTop = container.scrollTop();
          var contBottom = contTop + contHeight ;

          var elemTop = $(elem).offset().top - container.offset().top;
          var elemBottom = elemTop + $(elem).height();

          var isTotal = (elemTop >= 0 && elemBottom <=contHeight);
          var isPart = ((elemTop < 0 && elemBottom > 0 ) || (elemTop > 0 && elemTop <= container.height())) && partial ;

          return  isTotal  || isPart ;
      }



    // When the document loaded, add some hooks to the submit form

    document.addEventListener("DOMContentLoaded", function(event) {


        submitFormProcess();


    });


// What do do when the form is submitted and a new entry (text) is added?

function submitFormProcess() {

    document.querySelector('#submitform').addEventListener('submit', function(e) {

        e.preventDefault();

        $('#statement').addClass('loading');

        $('#submitbutton').attr('disabled', 'disabled');

        if ($('#livetext').html().length > 0 && voice_continues) {
          $('#livetext').html($('#statement').val() + '<br><em>saving into the graph...</em><span></span>');
          setTimeout(function(){
              $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
          }, 3000);
        }

        // We will set a user for posting. If the posting user does not equal the user who's watching the graph, we force-add the statement into theirs (provided they collaborate)
        var postedby = '';

        <% if (receivername) { %>
           postedby = '<%= receivername %>';
        <% } %>
        // TODO make it possible that those statements get submitted in both graphs

        // is urlvars mute off? then post as usual
        if (!mute) {
        $.post('/post', $("#submitform").serialize())
                .done(function(res) {
                    //3. Receive the server response, no need to emit an event
                    if (res.entryuid) {
                        //4. Show the updated text
                        selfPosted = '1';
                        $("#statement").val('');
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');

                        // This below if a few statements were posted
                        // TODO as we can now get all the s.uid back as an array this could be rewritten so no need for the condition after
                        if (res.entryuid == 'multiple') {
                            socket.emit('chat message', {postedby: postedby, entryuid: 'multiplesocket', entrytext: res.entrycontent, graph: res.graph});
                            if (res.successmsg) {
                              $("#warnings").append('<p class="warning">Please, reload the page after a few seconds to see the graph.</p>');
                              $("#warnings").slideDown('slow');
                            }
                            setTimeout(function() {
                                location.reload();
                            },3000);
                        }
                        else {
                            // Only one statement added? Initiate processing that will show it both to the user and the collaborator (if exists)
                            socket.emit('chat message', {postedby: postedby, entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                        }

                    }
                    else if (res.errormsg) {
                        $('#statement').removeClass('loading');
                        $('#submitbutton').removeAttr('disabled');
                        alert(res.errormsg);
                    }
                    else {
                        alert('Something went wrong, please, try again...');
                    }
                })
                .fail(function(res) {
                    alert("Server Error: " + res.status + " " + res.statusText);
                });

        }
        // otherwise - make a dummy post - it appears in the list but doesn't get submitted into the graph
        // This was made before to introduce a chat feature — so the software can "talk" to the user without adding stuff into the graph
        else {
            selfPosted = '1';
            $('#statement').removeClass('loading');
            $('#submitbutton').removeAttr('disabled');
            $("#statement").val('');
            socket.emit('chat message', {mute: 1, postedby: postedby, entryuid: '', entrytext: $('#statement').val(), graph: ''});
        }

        return false;
    });


    $('#statement').keypress(function(e){

        // Submit the form on enter

        if(e.which == 13 && !e.shiftKey) {
            e.preventDefault();
            $('#submitbutton').trigger('click');
        }

    });

}

// A function to hide / Show Statements and edit pane DIVs

// Has to be called with every update of the edit pane #entryform

function toggle_statements() {

    /*$('#graph-link').toggleClass('graph-chat');
    $('#entries').toggleClass("hide-entries");
    $('#statements').toggleClass("hide-statements");

    if ($('#graph-link').hasClass('graph-chat')) {
        //$('#switcher-panel').toggleClass("hide-menu");
        $('#finds').trigger('click');
        $('#switcher-selector').toggleClass("hide-menu");
    }
    else {
        // $('#switcher-panel').toggleClass("hide-menu");
        $('#switcher-selector').toggleClass("hide-menu");
        if (pinnedNodes.length == 0) {
            $('#adds').trigger('click');
        }
    }*/

   $("#statements").fadeToggle();


    if (!$("#chat-link").hasClass('chat-highlight')) {
        localStorage.setItem('graph', 1);
    }
    else {
        localStorage.setItem('graph', 0);
    }
    $("#chat-link").toggleClass('chat-highlight');

    if (!localStorage.getItem('analytics')) {
    $('#analytics').toggle('slide', function(){
      if ($('#analytics').is(":visible")) {
            $('#analyticsbutton').addClass('analytics-on');
            $('#analyticscaption').hide();
            //localStorage.setItem('analytics', 1);
      }
      else {
            $('#analyticsbutton').removeClass('analytics-on');
            $('#analyticscaption').show();
            //localStorage.setItem('analytics', 0);
          }
    });
    }






}

function showStatements () {
        var isHidden_ = $("#statements").is(":hidden");
        if (isHidden_) {
            $('#statements').fadeIn();
            $("#chat-link").toggleClass('chat-highlight');
        }
}

function showEntries () {
        var isHidden_ = $("#entries").is(":hidden");
        if (isHidden_) {
            $('#entries').fadeIn();
        }
}





// Add a method to the graph model that returns an
// object with every neighbors of a node inside:

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
        neighbors[k] = this.nodesIndex[k];

    return neighbors;
});

// Initialize JSON parser for SIGMA visualization

var color_addcontext = '#666666'; // #cccccc

var highlight_addcontext = '#0089e0';







   var visibleentries_original = '0';

// TODO: 1. Add search function by #hashtag; 2. Attach that same function to hashtag doubleclick;

// Auto-resize to fill content;

    // This launches only when all other stuff from above have loaded
    $(document).ready(function(){




      // Get the context names - all the contexts that exist in the graph we just loaded
      // This IF statement is for the case when the contextlist parameter is not passed on
      <% if (contextlist.length > 0) { %>
      <% contextlist.forEach(function(contextlabel) { %>
        contextNames.push("<%= contextlabel[0] %>");
      <% }); %>
      <% } %>

      // Memorize which interface option the user had on last time
      if (localStorage.getItem('defaultbehavior') == 'add') {
        $('#addnode').addClass('addnode-on');
      }
      else {
        $('#searchnode').addClass('searchnode-on');
      }

      // Put the contexts into the menu
      populateContextMenu(contextNames);

        $('.tooltip').tooltipster({
            theme: 'tooltipster-noir',
            position: 'left',
            maxWidth: 200,
            delay: 1000
        });

        // Some more settings from the URL or user settings passed from routes/entries.js and defined above in global parameters

        var privacyform = '';

        var graph_share_url = hostsite + '/' + current_user;

        if (current_context) {
            graph_share_url = graph_share_url + "/" + current_context + "?";
        }

        if (background) {
            graph_share_url += 'background=' + background + '&';
        }

        if (most_influential) {
            graph_share_url += '&most_influential=' + most_influential + '&';
        }

        if (maxnodes) {
            graph_share_url += '&maxnodes=' + maxnodes + '&';
        }

        if (abstract == 'yes') {
            graph_share_url += '&abstract=yes&hide_always=1&';
        }


        var privacy_iframe = "<iframe width='100%' height='500' style='height: 500px' src='https://" + graph_share_url + "hide_always=1&link_hashtags=1&background=" + background + "&maxnodes=" + maxnodes + "' frameborder='0' allowfullscreen></iframe>";

        <% if (contextpublic && context && !perceivername && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This context can be viewed on:<br><input type="text" id="embedurl" size="25" maxlength="80" class="pure-input" value="https://' + graph_share_url + '"><br><br>Embed code for websites:<br><input type="text" id="embedcode" size="25" maxlength="100" class="pure-input" value="' + privacy_iframe + '"><br><br><input type="submit" id="privacybutton" name="privacy" value="make private"></form></span>')

        <% } else if (!perceivername && context && entries.length > 0) { %>
            privacyform = $('<span><form action="/context" name="privacycontext" method="post" class="pure-form"><input type="hidden" name="context" value="<%= context %>">This context is currently private and cannot be seen by the public.<br><br><input type="submit" id="privacybutton" name="privacy" value="make public"></form></span>')
        <% }  %>

        $('#privacy-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: privacyform,
            functionReady: function() {
                $('#embedurl').focus(function(event) {
                    setTimeout(function() {$('#embedurl').select();}, 0);
                });
                $('#embedcode').focus(function(event) {
                    setTimeout(function() {$('#embedcode').select();}, 0);
                });

            }
        });


        collaborate_message = '<a href="mailto:chat@infranodus.com?subject=Chat%20Now&body=https://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '">Invite us</a> or other people for a real-time constellaversation – just share the link below:<br>';

        collaborate_html = '<span><form class="pure-form">' + collaborate_message + '<input type="text" id="collaburl" size="22" maxlength="80" class="pure-input" value="http://' + graph_share_url + '/edit?collaborate=' + collaborate_id + '"></form></span>';

        collaborate_content = $(collaborate_html);

        $('#collaborate-link').tooltipster({
            theme: 'tooltipster-noir',
            position: 'top-right',
            maxWidth: 220,
            interactive: true,
            content: collaborate_content,
            functionReady: function() {
                $('#collaburl').focus(function(event) {
                    this.setSelectionRange(0, 9999);
                });
            }
        });





        // So the perceiver is the one who is viewing the graph
        // receiver is the one who created it
        // We use it to basically identify if the user is logged in as perceiver is only passed in this case if the user who's viewing the graph is not logged in

        <% if (!perceivername) { %>

            // Advertise graph collaboration module
            if (!collaborate_invite) {
                var collab_content = $('#collaborate-link').tooltipster('content');

                var graph_share_url = hostsite + '/' + current_user;

                if (current_context) {
                    graph_share_url = graph_share_url + "/" + current_context;
                }


            }

        // START Speech Recognition Module only for Chrome

        if ('webkitSpeechRecognition' in window) {

            var recognition = new webkitSpeechRecognition();

            $('#microphone-link').fadeIn();

            if (localStorage.getItem('microphone') == 1) {
                $('#microphone-link').toggleClass('microphone-on', 'add');
                activateVoiceInput();
            }

            if (speech) {
              $('#microphone-link').toggleClass('microphone-on', 'add');

              activateVoiceInput();

              if (walkthrough == "mic") {
              // Instance the walkthrough tour
                var tour = new Tour({
                  storage: false,
                  steps: [
                  {
                    element: "#microphone-link",
                    placement: "left",
                    title: "Turn on Your Microphone",
                    content: "When it's blue, it's on. Make sure you also have the sound and microphone turned on in your computer.",
                    onNext: function (tour) {
                      setTimeout(function() {
                        var player = new talkify.Html5Player(); //or new talkify.Html5Player()
                        player.playText('Please speak into your microphone and every word you say, will be visualized in a network.');
                      },1000);
                    }
                  },
                  {
                    element: "#entryform",
                    title: "Continue Talking...",
                    content: "As you speak, the words will appear here. Please, speak clearly and make breaks between sentences."
                  },
                  {
                    element: ".entry",
                    title: "Edit the Statements",
                    content: "You will see visualization on the right. To delete a statement, double-click it."
                  },
                  {
                    element: "#statement",
                    title: "Delete Statements",
                    content: "If you double-clicked the statement, it appears here. Then simply click the Delete icon below the statement and it will be removed."
                  }
                ]});

                // Initialize the tour
                tour.init();

                // Start the tour
                tour.start();
              }

            }

            $("#microphone-link").click(function(e) {

                e.preventDefault();

                if (localStorage.getItem('microphone')  == 1) {
                    localStorage.setItem('microphone', 0);
                    $('#microphone-link').toggleClass('microphone-on', 'remove');
                    recognition.abort();
                    $('#livetext').html('');
                }
                else {
                    localStorage.setItem('microphone', 1);
                    activateVoiceInput();
                    $('#microphone-link').toggleClass('microphone-on', 'add');
                }

            });



        }


            function activateVoiceInput() {



                    var voiceresult = '';

                    var previoustalk = '';

                    var previoustalk_last = '';

                    var offtherecord = '';

                    var voicecorrect = '';

                    // Are we processing a short phrase or performing continuous dictation?
                    recognition.continuous = false;

                    // Do we require interim results in addition to the final results?
                    recognition.interimResults = true;

                    // Check if the user has a preferred language settings

                    if (inlanguage != undefined) {
                        if (inlanguage == 'auto') {
                          recognition.lang = 'en-US';
                        }
                        else {
                          recognition.lang = inlanguage;
                        }
                    }
                    else {
                        // We speak The US English here
                        recognition.lang = 'en-US';
                    }

                    if (language == 'en' || language == 'en-US' || language == 'english') {
                        recognition.lang = 'en-US';
                        localStorage.setItem('language', 'en');
                    }

                    else if (language == 'ru' || language == 'russian') {
                        recognition.lang = 'ru';
                        localStorage.setItem('language', 'ru');
                    }
                    else if (language == 'fr' || language == 'french') {
                        recognition.lang = 'fr';
                        localStorage.setItem('language', 'fr');
                    }
                    else if (language == 'de' || language == 'german') {
                        recognition.lang = 'de';
                        localStorage.setItem('language', 'de');
                    }

                    // if (localStorage.getItem('language') == 'ru') {
                    //     recognition.lang = 'ru';
                    //     localStorage.setItem('language', 'ru');
                    // }
                    // else if (localStorage.getItem('language') == 'en') {
                    //     recognition.lang = 'en';
                    //     localStorage.setItem('language', 'en');
                    // }
                    // else if (localStorage.getItem('language') == 'fr') {
                    //     recognition.lang = 'fr';
                    //     localStorage.setItem('language', 'fr');
                    // }
                    // else if (localStorage.getItem('language') == 'de') {
                    //     recognition.lang = 'de';
                    //     localStorage.setItem('language', 'de');
                    // }

                    // Kick off the Speech to Text recognition process
                    $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
                    recognition.start();

                    // Set up
                    recognition.onstart = function(event){
                        console.log("onstart", event);
                    }
                    // Set up
                    recognition.onspeechstart = function(event){
                        console.log("onspeechstart", event);
                    }

                    // Process parsed result
                    recognition.onresult = function(event){
                        // console.log("onresult", event);



                        if ($('#statement').val().length == 0) {
                          previoustalk = '';
                        }
                        voiceresult = previoustalk + event.results[0][0].transcript;
                        $('#statement').val(voiceresult);
                        $('#livetext').html(voiceresult + '<span></span>');

                        console.log(event.resultIndex);
                        for (var i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {

                                recognition.abort();

                                lastword = event.results[0][0].transcript.toLowerCase();

                                if (offtherecord == 'on') {
                                    voiceresult = previoustalk;
                                    $('#statement').val(voiceresult);
                                    $('#livetext').html(voiceresult + '<span></span>');
                                    if (lastword == 'on the record') {
                                      offtherecord = '';
                                    }
                                }
                                else if (voicecorrect == 'on') {
                                  var wordswap = lastword.split(" ");
                                  var wordwas = wordswap[0];
                                  var wordis = wordswap[2];
                                  var reg = new RegExp('('+wordwas+')', 'gi');
                                  voiceresult = previoustalk.replace(reg,wordis);
                                  previoustalk = voiceresult + ' ';
                                  $('#statement').val(voiceresult);
                                  $('#livetext').html(voiceresult + '<span></span>');
                                  voicecorrect = '';
                                }
                                else {
                                  if (voiceresult.length > 2) {
                                      if (!voice_continues) {
                                        $('#livetext').html(voiceresult + '<br><em>saving into the graph...</em> <span></span>');
                                        setTimeout(function(){
                                            $('#submitbutton').trigger('click');
                                        }, 1000);
                                        setTimeout(function(){
                                            $('#livetext').html('<em>waiting...</em>' + ' <span></span>');
                                        }, 3000);
                                      }
                                      else {
                                        if (lastword == voice_continues) {
                                          voiceresult = previoustalk;
                                          previoustalk = '';
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          setTimeout(function(){
                                              $('#submitbutton').trigger('click');
                                          }, 1000);
                                        }
                                        else if (lastword == 'improve layout') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          $('#improve-layout').trigger('click');
                                        }
                                        else if (lastword == 'off the record') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          offtherecord = 'on';
                                        }
                                        else if (lastword == 'correct') {
                                          voiceresult = previoustalk;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                          voicecorrect = 'on';
                                        }
                                        else if (lastword == 'erase') {
                                          voiceresult = previoustalk_last;
                                          previoustalk = previoustalk_last;
                                          $('#statement').val(voiceresult);
                                          $('#livetext').html(voiceresult + '<span></span>');
                                        }
                                        else if (lastword == 'new line') {
                                          previoustalk_last = previoustalk;
                                          previoustalk = voiceresult + ' \n';
                                        }
                                        else {
                                          previoustalk_last = previoustalk;
                                          previoustalk = voiceresult + ' ';
                                        }
                                      }
                                  }
                                  else {
                                    previoustalk = voiceresult + ' ';
                                      // recognition.start();
                                  }
                                }
                            }
                        }
                    }

                    // Handle error
                    recognition.onerror = function(event){
                        console.log("onerror", event);
                        if (event.error == 'no-speech') {

                        }
                    }

                  /*  // Housekeeping after success or failed parsing
                    recognition.onspeechend = function(){
                        console.log("onspeechend");
                        if (voiceresult.length > 4) {
                            setTimeout(function(){
                                $('#submitbutton').trigger('click');
                            }, 1000);

                        }
                        else {
                            previoustalk = voiceresult + '';
                            // recognition.start();
                        }

                    }*/


                    recognition.onend = function(){

                        console.log("onend");
                        if (localStorage.getItem('microphone') == 1 || speech == 1) {
                            recognition.start();
                        }

                    }



            }


            // END Speech recognition module





        // IMPORTANT NOTE this is the end of the cycle that shows only to the editor, if the user who' viewing is logged in and viewing their own stuff
         <% } %>

         // BEGIN WALKTHROUGH Module for tutorial Help
         // TODO move this out for sure

         // Basic tutorial
         function initializeWalkthrough () {
           // Instance the tour
             var tour = new Tour({
               storage: false,
               steps: [
               {
                 element: "#entryform",
                 orphan: true,
                 placement: "top",
                 title: "Welcome to InfraNodus",
                 content: "You can start typing your ideas and notes here. Press Enter or Save to submit. They will be visualized as a graph.",
                 onNext: function (tour) {
                     $('#statement').val('Every word you type is a node in a graph. When the words cooccur together, they are connected.');
                 }
               },
               {
                 element: "#statement",
                 placement: "top",
                 title: "Add a Statement...",
                 content: "You can add this statement or edit and add your own. Then press the SAVE button...",
                 onNext: function (tour) {
                     $('#statement').val('');
                 }
               },
               {
                 element: ".entry:first",
                 orphan: true,
                 placement: "auto",
                 title: "See the Statements",
                 content: "You will then see this statement appear here. To edit it, double-click it."
               },
               {
                 element: "#statement",
                 placement: "top",
                 title: "Delete Statements",
                 content: "If you double-clicked the statement, it appears here. Then simply click the Delete icon below the statement and it will be removed. You can also Edit and click Edit. Or Cancel."
               },
               {
                 element: "#import-link",
                 placement: "top",
                 title: "Import Statements",
                 content: "You can also import any data from a PDF / TXT file, a URL (inc Wikipedia), RSS Feeds, Twitter, Google search results, your notes, etc."
               },
               {
                 element: "#menuLink",
                 title: "Context Menu",
                 content: "You can navigate using this menu here. Here you can choose another context (list / graph / set), add a new one, or see all of them at once.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#chat-link",
                 placement: "left",
                 title: "Hide/Show Edit Pane",
                 content: "You can use this button to hide / show the edit pane, so you can clearly see the graph.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#statements-link",
                 placement: "right",
                 title: "Hide/Show Statements",
                 content: "You can also use this button to hide the text but to leave the edit pane on.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "This Tutorial",
                 content: "If, at any point, you want to see this tutorial again, click here.",

               },
               {
               element: "#addnodeinput",
               placement: "bottom",
               title: "Search in Graph",
               content: "You can also use this search field to look for the nodes in the graph. Once you find the nodes, they will appear below. You can click the 'delete' button to remove them from the graph.",
               },
               {
               element: "#addnode",
               placement: "bottom",
               title: "Add a Node",
               content: "You can use this field to quickly add a node in the graph.",
               },
               {
                 element: "#microphone-link",
                 orphan: true,
                 placement: "left",
                 title: "Voice to Text Input",
                 content: "If you use Chrome browser, you can also turn on Voice to Text input. Great for interviews and when you're lazy to type. English, French, German and Russian."
               },
               {
                 element: "#graph-container",
                 placement: "top",
                 title: "Use the Graph",
                 content: "You can click on the nodes on the graph to see what they're connected to and to filter the statements, which contain them."
               },
               {
                 element: "#analyticsbutton",
                 placement: "left",
                 title: "Text / Graph Analytics",
                 content: "Here you can see the main topics identified in the graph and the main keywords / nodes and click them to get more insights about the graph. You can also discover what questions to ask to make your discourse more connected.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "How to Analyze the Graph",
                 content: "The top topics are identified according to Louvain community detection algorithm (Blondes et al 2008). It detects the words that co-occur more often together than others and puts them into the same community (designated with a specific color)."
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "Most Influential Words",
                 content: "The most influential words are the words in the graph that have the highest betweenness centrality — they appear most often on the shortest path between any two randomly chosen words. It means they serve as the 'crossroads' of meaning, often linking different contexts together. This is not the same as the most frequently used words, rather these words connect the different topics in this discourse. (it is also possible to use degree as the most influential words setting)"
               },
               {
                 element: "#graphstats",
                 placement: "top",
                 title: "Graph Stats",
                 content: "We use our own measure of <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>discourse polysingularity</a> (Paranyushkin 2012, 2018) to score the discourse visualized based on the structure of the graph. <br><b>'Sparse'</b> — indicates a fragmented discourse (e.g. poetry, the beginning of a research, etc.) <br><b>'Diversified'</b> — indicates a discourse with a high level of plurality.<br><b>'Focused'</b> — prioritizes one or two topics. <br><b>'Biased'</b> — an agenda or mobilizing action present (e.g. advertising, ideology, manifesto)."
               },
               {
                 element: "#biasindex",
                 placement: "top",
                 title: "Bias Level",
                 content: "This measures the level of bias in graph: if it consists of disjointed islands it's 'dispersed'; if those islands are interconnected, there are several topics within, it's 'diversified'; if most of the nodes are in one topic it's 'focused', if it's tightly interconnected and there are no distinct topical clusters, it's 'biased'. Read more about the methology in our <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>Identifying the Discourse Bias</a> (Paranyushkin 2018) article in Towards Data Science."
               },
               {
                 element: "#graph-container",
                 placement: "bottom",
                 title: "Discover New Ideas",
                 content: "You can also discover new ideas if you look for the gaps inside the graph.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#go_next",
                 placement: "left",
                 title: "Search the Web",
                 content: "Once you select a few nodes in the graph, you can click this to search them on the web.",
                 onShow: function (tour) {
                   if ($('#analytics').is(":visible")) {
                      $('#analyticsbutton').click();
                   }
                 }
               },
               {
                 element: "#collaborate-link",
                 title: "Collaborate",
                 placement: "top",
                 content: "You can invite somebody to collaborate and to work with you on this graph. Click on this button to copy and paste the URL and then send it to your collaborators."
               },
               {
                 element: "#privacy-link",
                 title: "Privacy / Embed",
                 placement: "top",
                 content: "All your data is private by default and cannot be seen by anybody. You can make this graph public and then embed it on any other html page. Just click this button and then copy and paste the URL or the embed code."
               },
               {
                 element: "#settingspane",
                 title: "Settings Pane",
                 content: "Here you can log out, adjust the settings, and export your graph in any format for further visualization using Gephi or any other software.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#addNewContext",
                 title: "Add a New Context",
                 content: "You can add a new context here (click, type in the new name and click Enter to save). Think of contexts as lists or folders. You can store different notes there or you can organize them by hashtags."
               },
               {
                 element: "#improve-layout",
                 title: "Improve Graph Layout",
                 placement: "left",
                 content: "You can use this button to improve the graph's layout.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#abstract-layout",
                 title: "Show Abstract Layout",
                 placement: "left",
                 content: "Click this button to see an abstract representation of the graph."
               },
               {
                 element: "#graph-tools",
                 placement: "left",
                 title: "Zoom In / Zoom Out",
                 content: "Use these buttons to zoom in and zoom out (or scroll your trackpad or pinch your iPad/iPhone)"
               },
               {
                 element: "#reloadbutton",
                 placement: "left",
                 title: "Reload Graph",
                 content: "If, at any point, something goes wrong, you can always click this to reload the graph."
               },
               {
                 element: "#summary",
                 placement: "bottom",
                 title: "Essence / Summary",
                 content: "Click here to filter the most essential statements from the discourse. These will be the ones that contain the key terms (the main topical clusters) of the discourse as identified in the Analytics pane.",
                 onShow: function (tour) {
                     $('#summary').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#insight",
                 placement: "bottom",
                 title: "Insight",
                 content: "Click here to generate new ideas: we will show you the two topical clusters and the associated statements, which could be linked together to get a new insight into the discourse or to develop it further (depending on its structure).",
                 onShow: function (tour) {
                     $('#insight').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Interactive Help",
                 content: "When you want to see this guide again, click here.",
                 onShow: function (tour) {
                     if ($('#analytics').is(":visible")) {
                        $('#analyticsbutton').click();
                     }
                     $('#overview').click();
                 }
               }

             ]});

             // New context tutorial? Do not show it if it's been shown before
             if (walkthrough == 'newcontext' || walkthrough == 'tldr') {
               tour._options.storage = window.localStorage;
             }

             if (walkthrough == 'tldr') {
             //  console.log(tour._options.steps);
               tour._options.steps = [
                 {
                 element: "#entryform",
                 placement: "right",
                 title: "Visualizing a Long Text",
                 content: "If you would like to visualize a long text, copy and paste it here and click Save. You will probably need to wait for about 20-60 seconds. If nothign happens, you can try to reload the page after. We currently can handle about 150K max.",
               },
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Navigate the Graph",
               content: "You will then see a graph representation of this text. The most prominent topics will be shown as bigger nodes in the graph, those words, which are used in the same context will be closer to each other.",
               },
               {
               element: "#graph-container",
               placement: "top",
               title: "Search through Text",
               content: "You can then click on the nodes in the graph to find the parts of the text that you find interesting.",
               },
               {
               element: "#graph-container",
               placement: "left",
               title: "Discover New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask.",
               },
               {
               element: "#graph-container",
               placement: "left",
               title: "Discover New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask.",
               },
               {
                 element: "#menuLink",
                 title: "Context Menu",
                 content: "You will be able to later find your text here.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#summary",
                 placement: "bottom",
                 title: "Essence / Summary",
                 content: "Click here to filter the most essential statements from the discourse. These will be the ones that contain the key terms (the main topical clusters) of the discourse as identified in the Analytics pane.",
                 onShow: function (tour) {
                     $('#summary').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#insight",
                 placement: "bottom",
                 title: "Insight",
                 content: "Click here to generate new ideas: we will show you the two topical clusters and the associated statements, which could be linked together to get a new insight into the discourse or to develop it further (depending on its structure).",
                 onShow: function (tour) {
                     $('#insight').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Detailed Tutorial",
                 content: "If, at any point, you want to see a more detailed Tutorial, click here.",
                 onShow: function (tour) {
                     if ($('#analytics').is(":visible")) {
                        $('#analyticsbutton').click();
                     }
                     $('#overview').click();
                 }
               }
               ]
             }

             // Another walkthrough option passed through the URL

             if (walkthrough == 'analytics') {
             //  console.log(tour._options.steps);
               tour._options.steps = [
                 {
                 element: "#entryform",
                 placement: "right",
                 title: "Text Analytics",
                 content: "If you would like to analyze a text, please, copy and paste it here or <a href='/import'>import a file</a>.",
               },
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Navigate the Graph",
               content: "You will then see a graph representation of this text. The most prominent topics will be shown as bigger nodes in the graph, those words, which are used in the same context will be closer to each other.",
               },
               {
               element: "#graph-container",
               placement: "left",
               title: "Discover New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask.",
               },
               {
                 element: "#analyticsbutton",
                 placement: "left",
                 title: "Text / Graph Analytics",
                 content: "Here you can see the main topics identified in the graph and the main keywords / nodes and click them to get more insights about the graph. You can also discover what questions to ask to make your discourse more connected.",
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "How to Analyze the Graph",
                 content: "The top topics are identified according to Louvain community detection algorithm (Blondes et al 2008). It detects the words that co-occur more often together than others and puts them into the same community (designated with a specific color)."
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "Most Influential Words",
                 content: "The most influential words are the words in the graph that have the highest betweenness centrality — they appear most often on the shortest path between any two randomly chosen words. It means they serve as the 'crossroads' of meaning, often linking different contexts together. This is not the same as the most frequently used words, rather these words connect the different topics in this discourse. (it is also possible to use degree as the most influential words setting)"
               },
               {
                 element: "#graphstats",
                 placement: "top",
                 title: "Graph Stats",
                 content: "We use our own measure of <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>discourse polysingularity</a> (Paranyushkin 2012, 2018) to score the discourse visualized based on the structure of the graph. <br><b>'Sparse'</b> — indicates a fragmented discourse (e.g. poetry, the beginning of a research, etc.) <br><b>'Diversified'</b> — indicates a discourse with a high level of plurality.<br><b>'Focused'</b> — prioritizes one or two topics. <br><b>'Biased'</b> — an agenda or mobilizing action present (e.g. advertising, ideology, manifesto)."
               },
               {
                 element: "#biasindex",
                 placement: "top",
                 title: "Bias Level",
                 content: "This measures the level of bias in graph: if it consists of disjointed islands it's 'dispersed'; if those islands are interconnected, there are several topics within, it's 'diversified'; if most of the nodes are in one topic it's 'focused', if it's tightly interconnected and there are no distinct topical clusters, it's 'biased'. Read more about the methology in our <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>Identifying the Discourse Bias</a> (Paranyushkin 2018) article in Towards Data Science."
               },
               {
                 element: "#menuLink",
                 title: "Context Menu",
                 content: "You will be able to later find your text here.",
                 onShow: function (tour) {
                     $('#menuLink').click();
                 }
               },
               {
                 element: "#summary",
                 placement: "bottom",
                 title: "Essence / Summary",
                 content: "Click here to filter the most essential statements from the discourse. These will be the ones that contain the key terms (the main topical clusters) of the discourse as identified in the Analytics pane.",
                 onShow: function (tour) {
                     $('#summary').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#insight",
                 placement: "bottom",
                 title: "Insight",
                 content: "Click here to generate new ideas: we will show you the two topical clusters and the associated statements, which could be linked together to get a new insight into the discourse or to develop it further (depending on its structure).",
                 onShow: function (tour) {
                     $('#insight').click();
                 }
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Detailed Tutorial",
                 content: "If, at any point, you want to see a more detailed Tutorial, click here.",
                 onShow: function (tour) {
                     if ($('#analytics').is(":visible")) {
                        $('#analyticsbutton').click();
                     }
                     $('#overview').click();
                 }
               }
               ]
             }

             if (walkthroughtype=='external') {

               var windowsize = $(window).width();
               if (windowsize <= 460) {
                  if (!$("#statements").is(":hidden")) {
                        $('#statements').hide();
                  }

               }

               tour._options.steps = [
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Welcome to InfraNodus",
               content: "Here you can see network visualization of the text on the left. The most prominent topics are shown as the bigger nodes in the graph. The words, which are more often used in the same context will be closer to each other. The different colors will show the topical clusters that belong together.",
               onShow: function (tour) {
                   $('#analytics').hide();
               }
               },
               {
               element: "#graph-container",
               placement: "top",
               title: "Search through Text",
               content: "You can then click on the nodes in the graph to find the parts of the text that you find interesting.",
               },
               {
               element: "#addnodeinput",
               placement: "bottom",
               title: "Search in Graph",
               content: "You can also use this search field to look for the nodes in the graph. Once you find the nodes, they will appear below. You can click the 'delete' button to remove them from the graph.",
               },
               {
                 element: "#chat-link",
                 placement: "left",
                 title: "Hide/Show Statements",
                 content: "You can use this button to hide / show statements, so you can clearly see the graph.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                 }
               },
               {
                 element: "#analyticsbutton",
                 placement: "left",
                 title: "Text / Graph Analytics",
                 content: "Here you can see the main topics identified in the graph and the main keywords / nodes and click them to get more insights about the graph. You can also discover what questions to ask to make your discourse more connected.",
                 onShow: function (tour) {
                     $('#chat-link').click();
                     if ($('#analytics').is(":visible")) {
                     }
                     else {
                       $('#analyticsbutton').click();
                     }
                 }
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "How to Analyze the Graph",
                 content: "The top topics are identified according to Louvain community detection algorithm (Blondes et al 2008). It detects the words that co-occur more often together than others and puts them into the same community (designated with a specific color)."
               },
               {
                 element: "#analytics",
                 placement: "auto",
                 title: "Most Influential Words",
                 content: "The most influential words are the words in the graph that have the highest betweenness centrality — they appear most often on the shortest path between any two randomly chosen words. It means they serve as the 'crossroads' of meaning, often linking different contexts together. This is not the same as the most frequently used words, rather these words connect the different topics in this discourse. (it is also possible to use degree as the most influential words setting)"
               },
               {
                 element: "#graphstats",
                 placement: "top",
                 title: "Graph Stats",
                 content: "We use our own measure of <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>discourse polysingularity</a> (Paranyushkin 2012, 2018) to score the discourse visualized based on the structure of the graph. <br><b>'Sparse'</b> — indicates a fragmented discourse (e.g. poetry, the beginning of a research, etc.) <br><b>'Diversified'</b> — indicates a discourse with a high level of plurality.<br><b>'Focused'</b> — prioritizes one or two topics. <br><b>'Biased'</b> — an agenda or mobilizing action present (e.g. advertising, ideology, manifesto)."
               },
               {
                 element: "#biasindex",
                 placement: "top",
                 title: "Bias Level",
                 content: "This measures the level of bias in graph: if it consists of disjointed islands it's 'dispersed'; if those islands are interconnected, there are several topics within, it's 'diversified'; if most of the nodes are in one topic it's 'focused', if it's tightly interconnected and there are no distinct topical clusters, it's 'biased'. Read more about the methology in our <a href='https://noduslabs.com/research/visualization-text-polysingularity-network-analysis/' target='_blank'>Identifying the Discourse Bias</a> (Paranyushkin 2018) article in Towards Data Science."
               },
               {
               element: "#graph-container",
               placement: "bottom",
               title: "Discover the New Ideas",
               content: "The gaps in the graph will show you where you could do more research or what questions to ask."
               },
               {
                 element: "#walkthrough",
                 placement: "left",
                 title: "Detailed Tutorial",
                 content: "If, at any point, you want to see a this Tutorial again, click here.",
                 onShow: function (tour) {
                   if ($('#analytics').is(":visible")) {
                      $('#analyticsbutton').click();
                   }
                 }
               },
               {
                 element: "#menuLink",
                 title: "Create Your Own Graphs",
                 content: "To create your own text network visualizations, you can create a new account on <a href='https://infranodus.com'>InfraNodus.Com</a>.",
               }
               ]
             }

             // Initialize the tour
             tour.init();

             // Start the tour
             tour.start();

           }

          // Which walkthrough tutorial we want to see (pass through the URL global parameter )

           if (walkthrough == 'default' || walkthrough == 'newcontext' || walkthrough == 'analytics' || walkthrough == "tldr" || walkthrough == "force") {

             initializeWalkthrough();

           }

           $("#walkthrough").click(function(e) {
               e.preventDefault();
               walkthrough = 'default';
               initializeWalkthrough();
           });

        

        // What happens when we click a button to delete a selected node
        $("#deletenodes").on('click', function(e) {
          e.preventDefault;
          socket.emit('node delete', {pinnedNodes: pinnedNodes});
        });

        // What happens when we click the button to remove a selected / deleted node

        $("#undo").on('click', function(e) {
          e.preventDefault;
          socket.emit('graph reset');
        });

        // What happens if we want to pass the list of keywords we selected to the settings

        $("#stopsave").on('click', function(e) {
          e.preventDefault;
          window.location.href = "/settings?stopwords=" + encodeURIComponent(deletedNodes.join(' ')) + "&returncontext=" + current_context;
        });

        // What happens when we add a single node from the second editor on top

        $("#addnode").on('click', function(e) {
          e.preventDefault();

          $('#addnode').addClass('addnode-on');
          $('#searchnode').removeClass('searchnode-on');
          localStorage.setItem('defaultbehavior', 'add');

          document.getElementById('addnodeform').dispatchEvent(new Event('submit'));


        });

        // What if we search for a node in the graph using the form at the top right

        $("#searchnode").on('click', function(e) {
          e.preventDefault();

          $('#addnode').removeClass('addnode-on');
          $('#searchnode').addClass('searchnode-on');
          localStorage.setItem('defaultbehavior', 'search');

          var searchinput = $('#addnodeinput').val();
          // TODO implement lemmas search
          if (searchinput.length > 0) {
              var searchinarray = searchinput.split(' ');
              for (var key in searchinarray) {
                if (searchinarray[key].charAt(0) == '#') { searchinarray[key] = searchinarray[key].slice(1); }
              }
              searchinput = searchinarray.join(' ');
              $('#search').val(searchinput);
              document.getElementById('searchform').dispatchEvent(new Event('submit'));
          }
          else {
            alert('Please, enter the node name you want to find...');
          }

        });

        // Are we viewing additional context?
        if (addcontext) {
          $('#addcontext-link').addClass('addcontext-visible');
        }

        $("#addcontext-link").on('click', function(e) {
          e.preventDefault();
          if ($(".addcontext-on").is(":visible")) {
              $('#addcontext-link').removeClass('addcontext-on');
          }
          else {
              $('#addcontext-link').addClass('addcontext-on');
          }


        });

        // What happens when we add a node using the small form top right?
        $('#addnodeform').submit(function(e) {
            e.preventDefault(); // to stop the form from submitting
            if ($(".searchnode-on").is(":visible")) {
              $('#searchnode').trigger('click');
            }
            else {
              if ($('#addnodeinput').val().length > 0) {
                  $('#statement').val($('#addnodeinput').val());
                  document.getElementById('submitform').dispatchEvent(new Event('submit'));
                  $('#addnodeinput').val('');
                  $("#addnodeinput").focus();
              }
              else {
                alert('Please, enter the name of the node you want to add...');
              }
            }

        });


        // We temporarily removed this link but it will be added again later, so save the logic
        $("#imports").click(function(e) {
            // var fornode = $('#statement').val();
            // // if (pinnedNodes.length > 0) {
            // //      fornode = toTitleCase(pinnedNodes[pinnedNodes.length - 1].replace(/_/g, " "));
            // // }
            //
            // var current_href = $(this).attr("href");
            // $(this).attr("href",current_href + '&statement=' + fornode);
        });

    


        $("#import-link").click(function(e) {

          var fornode = $('#statement').val();


          if (pinnedNodes.length > 0) {
               fornode = pinnedNodes.join("+");
          }

          var current_href = $(this).attr("href");

          $(this).attr("href",current_href + '?context=' + current_context + '&fornode=' + fornode);
        });


        function toTitleCase(str)
        {
            return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
        }

        

        var uproll = $('#entryform').height();

        if (hide_edit) {
          uproll = 50;
        }

        $('#entries').css({height:  $(window).height() - uproll - 100});

        $(window).resize(function() {
              $('#entries').css({height:  $(window).height() - uproll - 100});
              $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
        });


        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);


        // TODO We have a very strange switcher of panels here. Needs to be changed

        $('#switcher-selector').on('click', 'li', function() {


        

            var topmenuaction = $(this).children(":first").attr('id');

            // Repopulate context for addition field if it was the one clicked

            if (topmenuaction == 'adds') {

                current_context_field = [];

                // Are we inside some context already?

                if (document.getElementById('context').value) {
                    current_context_field.push(document.getElementById('context').value);
                    $("#addedContexts").val(document.getElementById('context').value);
                }

                // if not, we're making the 'private' context default
                else {
                    var lastcontexts = [];
                    var laststatement = $(".entry:last").attr('data-uid');
                    console.log(laststatement);
                    for (var key in statementsOfContext) {
                        var reiteratestatements = statementsOfContext[key];
                        for (var i = 0; i< reiteratestatements.length; i++) {
                            if (laststatement == reiteratestatements[i]) {
                                lastcontexts.push(key);
                                console.log(key);
                            }
                        }

                    }
                    if (lastcontexts[0] == 'help') {
                        current_context_field = ['private'];
                        $("#addedContexts").val('private');
                    }
                    else {
                        current_context_field = lastcontexts;
                        $("#addedContexts").val(current_context_field.join());
                    }
                }

                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                submitFormProcess();


            }


       



           


        });

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {
                var filter = ui.item.value;
            }
        });

        // Function to search the graph for the nodes selected

        search_graph();

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        var filteringstarted = 0;

        // Add the hooks to the newly rendered entries again

        entryClick();

        // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
        <% if (!perceivername) { %>
        entryDoubleClick();





        <% } %>


        // Highlight statement if clicked once

        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text(convertedTime);
        });

        // TODO move the fucntion out
        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var time = moment(modTimestamp, 'x').fromNow();
            return time;
        }


        // Some more graph interface settings

        // Did we receive a global setting to hide the graph?

        if ((hide_always || hide_edit) && !show_text) {
            toggle_statements();
            //localStorage.setItem('graph', 1);
        }

        // Did we receive a global setting to hide when small only?

        if (hide_when_small && $(window).width() < 600) {

            if ($('#menuLink').is(':visible')) {
                toggle_statements();
                //localStorage.setItem('graph', 1);
            }

            $('#analytics').hide();
            $('#analyticsbutton').removeClass('analytics-on');
            $('#analyticscaption').show();


        }

        // Did we receive a global setting to hide the editor pane?

        if (hide_edit) {
          $('.editorpane').each(function() {
            $(this).hide();
          });
        }


        // Are we loading the page to only show the graph?

        <% if (background == '1' || background == 'graph') { %>
           // $('#finds').trigger('click');

            toggle_statements();
            //localStorage.setItem('graph', 1);
            graphOnly = 1;
        <% } %>

        if (localStorage.getItem('graph') == 1 && !graphOnly && !hide_always && !hide_when_small) {
            var isHidden__ = $("#statements").is(":hidden");
            if (!isHidden__) {
                $('#statements').fadeOut();
                $("#chat-link").toggleClass('chat-highlight','add');
            }
        }

        if (localStorage.getItem('timer') == 1) {
          ($("#timer-link").trigger('click'));
        }

        // What happens when the user clicks on a node in the graph (this is caleld from sigma but processed here)

        socket.on('node click', function(msg){

              pinnedNodes = msg.pinnedNodes;
              console.log("Pinned nodes:");
              console.log(pinnedNodes);
              splicedNodes = msg.splicedNodes;
              console.log("Spliced nodes:");
              console.log(splicedNodes);
              var pinnedIndex = msg.pinnedIndex;

              // Are we clicking the node that was clicked already? Then show all divs
              if (pinnedIndex > -1) {
                    $('.entry').fadeIn(400);
              }


              // Filter statements and select nodes on the graph
              filter_statements(pinnedNodes);

        });

        // When we click reset button

        socket.on('graph reset', function(msg){

              pinnedNodes = [];
              splicedNodes = [];
              notfoundNodes = [];

              $('.entry').fadeIn(400);

              // Filter statements and select nodes on the graph
              filter_statements(pinnedNodes);

        });

        // What happens when we delete a node

        socket.on('node delete', function(msg){

              var nodesToDelete = msg.pinnedNodes;
              var delete_from = msg.delete_from;
              var collectiond = cy.elements();
              var elesss;

              cy.remove(collectiond);

              elesnodes = [];

              // Reiterate nodes and delete all the pinned nodes

              sigma.instances(0).graph.nodes().forEach(function(n) {

                  if (nodesToDelete.indexOf(n.originalLabel) >= 0) {
                    sigma.instances(0).graph.dropNode(n.id);
                    if (deletedNodes.indexOf(n.originalLabel) == -1) {
                      deletedNodes.push(n.originalLabel);
                    }
                  }
                  else {
                    // Add the remaining ones to Cytoscape
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                    elesnodes.push({
                        group: "nodes",
                        data: { id: n.id, name: n.label}
                    });


                  }
              //n.size = sigma.graph.degree(n.id);

              });

              // Reiterate all the remaining edges and add them to Cytascape
              // TODO this code duplicates from above - move into a function
              sigma.instances(0).graph.edges().forEach(function(e) {

                  var unique_edge_id = '';

                  // Let's see if the edge source in alphabetical order is further than its target and change places

                  if (e.source > e.target) {
                      unique_edge_id = e.target + '-' + e.source;
                  }
                  else {
                      unique_edge_id = e.source + '-' + e.target;
                  }

                    elesnodes.push({
                        group: "edges",
                        data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                    });


              });


              // Betweenness Centrality Calculation using Cytoscape
              elesss = cy.add(elesnodes);


              betweennessCentrality(elesss);

              // Community detect algorithm

              communityDetect();

              // No more pinned nodes

              if (!delete_from) {
                pinnedNodes = [];
              }
              commClicked = [];

              $('.community_node').each(function(){
                $(this).removeAttr('style');
              });

              $('.top_nodes').each(function(){
                $(this).removeAttr('style');
              });

              if (sigma.instances(0).isForceAtlas2Running()) {
                  sigma.instances(0).stopForceAtlas2();
                  sigma.instances(0).killForceAtlas2();
                  setTimeout(function() {
                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                    setTimeout(function() {

                        sigma.instances(0).stopForceAtlas2();
                        sigma.instances(0).killForceAtlas2();

                    }, 5000);
                }, 1000);
              }
              else {

                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  setTimeout(function() {

                      sigma.instances(0).stopForceAtlas2();
                      sigma.instances(0).killForceAtlas2();

                  }, 5000);

              }


              // Unfliter the nodes
              filter_statements(pinnedNodes, "nodedelete");


              sigma.instances(0).refresh();



        });

        // What happens when we add a node ?

        socket.on('node add', function(msg){
              var addingNodes = msg.addingNodes;
              var stoplistNodes = msg.stoplistNodes;

              // Remove the clicked node from the stoplist

              stoplistNodes.splice(stoplistNodes.indexOf(addingNodes), 1);


              sigma.instances(0).graph.addNode({
                  id: nodeIDs[addingNodes],
                  label: addingNodes,
                  originalLabel: addingNodes,
                  size: 16,
                  x: Math.random(),
                  y: Math.random()
              });

              var cyclefinished = 0;
              var edgeproc;

              var nodeIDs_rev = _.invert(nodeIDs);



              for (var i = 0; i < edgesDB.length; i++ ) {
                if (edgesDB[i].source == nodeIDs[addingNodes] || edgesDB[i].target == nodeIDs[addingNodes]) {

                  edgeproc = edgesDB[i];

                  if (stoplistNodes.length > 0) {

                      // Do connections only if target/source is not in the remaining stoplistNodes
                        if (stoplistNodes.indexOf(nodeIDs_rev[edgeproc.source]) < 0 && stoplistNodes.indexOf(nodeIDs_rev[edgeproc.target]) < 0) {

                              sigma.instances(0).graph.addEdge({
                                     id: edgeproc.id,
                                     source: edgeproc.source,
                                     target: edgeproc.target,
                                     weight: edgeproc.weight,
                                     size: edgeproc.weight,
                                     statement_id: edgeproc.statement_id,
                                     edge_context: edgeproc.edge_context
                              });

                          }




                  }
                  else {
                    sigma.instances(0).graph.addEdge({
                           id: edgeproc.id,
                           source: edgeproc.source,
                           target: edgeproc.target,
                           weight: edgeproc.weight,
                           size: edgeproc.weight,
                           statement_id: edgeproc.statement_id,
                           edge_context: edgeproc.edge_context
                    });

                  }
                }
                cyclefinished = cyclefinished + 1;
              }



              if (cyclefinished == edgesDB.length) {
                sigma.instances(0).refresh();
                var collectiond = cy.elements();
                var elessss;

                cy.remove(collectiond);

                elesnodes = [];


                sigma.instances(0).graph.nodes().forEach(function(n) {
                                    elesnodes.push({
                                        group: "nodes",
                                        data: { id: n.id, name: n.label}
                                    });

                                    // Adding a node to the nodeIDs
                                    var key = n.label;
                                    if (!nodeIDs[key]) {
                                        nodeIDs[key] = n.id;
                                    }
                                    if (nodeNames.indexOf(key) == -1) {
                                        nodeNames.push(key);
                                    }

                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                    var unique_edge_id = '';

                    // Let's see if the edge source in alphabetical order is further than its target and change places

                    if (e.source > e.target) {
                        unique_edge_id = e.target + '-' + e.source;
                    }
                    else {
                        unique_edge_id = e.source + '-' + e.target;
                    }

                      elesnodes.push({
                          group: "edges",
                          data: { id: unique_edge_id, source: e.source, target: e.target, weight: e.weight }
                      });


                });


                // Betweenness Centrality Calculation using Cytoscape
                elessss = cy.add(elesnodes);


                betweennessCentrality(elessss);

                // Community detect algorithm

                communityDetect("node add", addingNodes);

                sigma.instances(0).refresh();

                  sigma.instances(0).startForceAtlas2(forceatlas_options);
                  // Don't run it forever not to overheat :)

                  setTimeout(function() {

                      sigma.instances(0).stopForceAtlas2();
                      sigma.instances(0).killForceAtlas2();

                  }, 5000);


                filter_statements(stoplistNodes, 'stopwords');


              }






        });




        // Textarea select conversion to hashtags

        // For now it's disabled, but will be enabled for bulk statement correction later

        var getSelected = function(){
            var t = '';
            if(window.getSelection) {
                t = window.getSelection();
            } else if(document.getSelection) {
                t = document.getSelection();
            } else if(document.selection) {
                t = document.selection.createRange().text;
            }
            return t;
        }


        $("#statement").select(function(eventObject) {
            var selectedText = getSelected().toString();

            var statementReplace = $("#statement").val();

            if ((statementReplace.indexOf('@'+selectedText) === -1) && (selectedText !== statementReplace)) {

                var regex = RegExp(selectedText, "g");

                var dasherized = S(selectedText).underscore().chompLeft('_').s;

                // TODO check words for morphology (if found, alert)

                var replacedString = statementReplace.replace(regex,"#" + dasherized).replace(/##/g,'#');
                $("#statement").val(replacedString);
            }

        });

        // Document Ready end

        });







   





    function entryClick () {



        $(".entry").on('click', function(e) {
            if (e.target.className == 'app-link-menu') {

                if ($(this).find('.app-link-menu').text() == 'hide filtered') {
                    $(this).find('.nonmatched-sentence').fadeOut(400);
                    $(this).find('.app-link-menu').text('show filtered');
                }
                else {
                    $(this).find('.nonmatched-sentence').fadeTo(400, '0.4');
                    $(this).find('.app-link-menu').text('hide filtered');
                }

            }


            // A parameter to check if we're taking off the flag

            var alreadyClicked = null;

            // Make all entries semitrasparent


            if (pinnedNodes.length == 0) {

                $(".entry").each(function() {
                    if ($(this).css('opacity') < 1) {
                        $(this).css('opacity', '1');
                        alreadyClicked = 1;
                    }
                    else {
                        $(this).css('opacity', '0.3');
                    }
                });

                // The one clicked is not transparent

                $(this).css('opacity','1');

            }



            var keepStatementID = e.currentTarget.dataset.uid;


            console.log(keepStatementID);

            // Make only those edges visible that belong to the statement selected

            if (!alreadyClicked && pinnedNodes.length == 0) {

                sigma.instances(0).graph.edges().forEach(function(e) {
                    var got_match = 0;

                    for (let item of e.statement_id) {
                        if (item == keepStatementID) {

                          got_match += 1;

                        }

                    }

                    if (got_match > 0) {
                        e.color = e.originalColor;
                    }
                    else {
                        e.color = deselected_nodes_color;
                    }
                });

                // Make only those nodes visible that belong to the statement selected

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    // Is there no contexts at all? Show the node.
                    if (nodesOfStatement[keepStatementID].indexOf(n.id) < 0)  {
                        n.color = deselected_nodes_color;
                        n.label = '';
                    }
                    else {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    }
                });
            }
            else if (e.target.className == 'app-link-menu') {

                // Do nothing

            }
            else {

                if (pinnedNodes.length == 0) {
                    sigma.instances(0).graph.edges().forEach(function(e) {
                        e.color = e.originalColor;
                    });

                    // Make only those nodes visible that belong to the statement selected

                    sigma.instances(0).graph.nodes().forEach(function(n) {
                        n.color = n.originalColor;
                        n.label = n.originalLabel;
                    });
                }

            }

            sigma.instances(0).refresh();
        });

    }

    function entryScroll (scroll_entry, undo_select) {

      if (pinnedNodes.length == 0 && !undo_select) {

          sigma.instances(0).graph.edges().forEach(function(e) {
              var got_match = 0;
              for (let item of e.statement_id)  {
                  if (scroll_entry.indexOf(item) > -1) {
                      got_match += 1;
                  }
              }
              if (got_match > 0) {
                  e.color = e.originalColor;
              }
              else {
                  e.color = deselected_nodes_color;
              }

          });

          // Make only those nodes visible that belong to the statement selected

          sigma.instances(0).graph.nodes().forEach(function(n) {

              // Is there no contexts at all? Show the node.
              for (var i = 0; i < scroll_entry.length; i++) {
                if (nodesOfStatement[scroll_entry[i]] && (nodesOfStatement[scroll_entry[i]].indexOf(n.id) < 0))  {
                    n.color = deselected_nodes_color;
                    n.label = '';
                }
                else {
                  if (nodesOfStatement[scroll_entry[i]] != undefined) {
                    n.color = n.originalColor;
                    n.label = n.originalLabel;
                  }
                }
              }
          });
      }

      else {

          if (pinnedNodes.length == 0) {
              sigma.instances(0).graph.edges().forEach(function(e) {
                  e.color = e.originalColor;
              });

              // Make only those nodes visible that belong to the statement selected

              sigma.instances(0).graph.nodes().forEach(function(n) {
                  n.color = n.originalColor;
                  n.label = n.originalLabel;
              });
          }

      }

      sigma.instances(0).refresh();

    }



    function entryDoubleClick() {

        $(".entry").on('doubletap', function(e) {

        e.preventDefault();

        // Get the content from the form edit and copy it into the switcher panel to show to the user

        var _formcontent = $('#adds-content').html();

        $("#switcher-panel").html(_formcontent);

        // Get the statement into the edit box at the top
        $("#statement").val($('.entry-text', e.currentTarget).text());

        // Retrieve that statement's ID into the hidden field (for edit or delete)
        $('input[name="statementid"]').val(e.currentTarget.dataset.uid);

        // Retrieve the date of the statement
        $('input[name="timestamp"]').val(e.currentTarget.dataset.timestamp);

        $('#statementInputMenu').each(function() {
            $("li", this).each(function(i) {

                $(this).removeClass('pure-menu-selected-top');

            });
        });




        // Change / add buttons
        $('#submitbutton').hide();

        if (!$('#deletebutton').val()) {

            $("#submitform").append('<input type="submit" name="edit" value="edit" id="editbutton" class="pure-button"> <input type="submit" style="margin: 0px 8px;" name="delete" value="delete" id="deletebutton" > <input type="submit" name="cancel" value="cancel" id="cancelbutton" class="pure-button">');

            $('#deletecontextbutton').hide();
            $('#privacy-link').hide();
            $('#collaborate-link').hide();
            $('#import-link').hide();



            // Delete text from the form in case of Cancel, remove the buttons

            $("#cancelbutton").on('click', function(e) {

                e.preventDefault();

                $("#statement").val('');
                $('#editbutton').remove();
                $('#deletebutton').remove();
                $('#cancelbutton').remove();
                $('#submitbutton').show();
                $('#deletecontextbutton').show();
                $('#privacy-link').show();
                $('#collaborate-link').show();
                $('#import-link').show();

                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

                $('input[name="timestamp"]').val('');

                // Populate contexts list next to statement add

                current_context_field = [];

                // Are we inside some context already?

                if ($("#context").val()) {
                    current_context_field.push($("#context").val());
                    $("#addedContexts").val($("#context").val());
                }

                else {

                    if (document.getElementById('context').value) {
                        current_context_field.push(document.getElementById('context').value);
                        $("#addedContexts").val(document.getElementById('context').value);
                    }

                    // if not, we're making the 'private' context default
                    else {
                        var lastcontexts = [];
                        var laststatement = $(".entry:last").attr('data-uid');
                        console.log(laststatement);
                        for (var key in statementsOfContext) {
                            var reiteratestatements = statementsOfContext[key];
                            for (var i = 0; i< reiteratestatements.length; i++) {
                                if (laststatement == reiteratestatements[i]) {
                                    lastcontexts.push(key);
                                    console.log(key);
                                }
                            }

                        }
                        if (lastcontexts[0] == 'help') {
                            current_context_field = ['private'];
                            $("#addedContexts").val('private');
                        }
                        else {
                            current_context_field = lastcontexts;
                            $("#addedContexts").val(current_context_field.join());
                        }
                    }


                }



                $("#addToContexts").tagHandler({
                    assignedTags: current_context_field,
                    availableTags: contextNames,
                    autocomplete: true,
                    afterAdd: function(tag) {
                        current_context_field.push(tag);
                        $("#addedContexts").val(current_context_field.join());
                        console.log('contexts in cancel field: ' + current_context_field.join());
                    }
                });

                // TODO a better way of dealing with delete and edit - in the logic of everything else

                submitFormProcess();





            });

            $("#deletebutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#deletebutton').attr('disabled', 'disabled');

                $('input[name="timestamp"]').val('');


                var formSubmit = $("#submitform").serialize() + '&delete=delete';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            console.log(res);
                            if (res.successmsg) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#deletebutton').removeAttr('disabled');
                                socket.emit('delete message', {entryuid: res.statementid});
                                $("#warnings").append('<p class="warning">The statement was deleted.</p>');
                                $("#warnings").slideDown('slow');
                                $('#cancelbutton').trigger('click');
                                setTimeout(function() {
                                    $("#warnings").slideUp('slow');
                                    $("#warnings").text('');
                                },2000);


                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });

            $("#editbutton").on('click', function(e) {
                e.preventDefault();

                $('#statement').addClass('loading');

                $('#editbutton').attr('disabled', 'disabled');

                var statementToHide = $('#statementid').val();

                $('[data-uid="' + statementToHide + '"]').slideUp();

                var formSubmit = $("#submitform").serialize() + '&edit=edit';

                $.post('/post', formSubmit)
                        .done(function(res) {
                            //3. Receive the server response, no need to emit an event
                            if (res.entryuid) {
                                //4. Show the updated text
                                selfPosted = '1';
                                $('#statement').removeClass('loading');
                                $('#editbutton').removeAttr('disabled');
                                $('#cancelbutton').trigger('click');
                                socket.emit('chat message', {entryuid: JSON.parse(res.entryuid).data, entrytext: res.entrytext, graph: res.graph});
                            }
                            else if (res.errormsg) {
                                alert(res.errormsg);
                            }
                            else {
                                alert('Something went wrong, please, try again...');
                            }
                        })
                        .fail(function(res) {
                            alert("Server Error: " + res.status + " " + res.statusText);
                        });



            });



        }


        current_context_field = [];

        for (var key in statementsOfContext) {
            var checkstatements = statementsOfContext[key];
            for (var l = 0; l<checkstatements.length; l++) {
                if (checkstatements[l] == e.currentTarget.dataset.uid) {
                    current_context_field.push(key);
                }
            }

        }

        console.log('context of statement clicked: ' + current_context_field);

        // Which contexts the statement should be in?
        $("#addedContexts").val(current_context_field.join());

        // Update the contexts list if anything changes in the context settings of the statement

        $("#addToContexts").tagHandler({
            assignedTags: current_context_field,
            availableTags: contextNames,
            autocomplete: true,
            afterAdd: function(tag) {
                current_context_field.push(tag);
                $("#addedContexts").val(current_context_field.join());
                console.log('contexts in statement field: ' + current_context_field.join());
            }
        });


        // Smoothly scroll up
        $("html, body").animate({ scrollTop: 0 }, "slow");


        // THIS WAS BEFORE WHEN YOU CLICK A STATEMENT ONCE

        // Shall all statements inside Entry if clicked




    });
    }


    // Summary and Insight statements

    var summary_statements = [];


    function filter_statements_summary(top_words, top_community_words, filter_origin) {
      console.log('Filering Summary top words');
      console.log(top_words);
      console.log(top_community_words);

      // Let's first filter statements that contain all the most influential top_words
      // If all 4 are nowhere to be found, we reiterate until at least the first 3, 2, 1 is found.
      // Save that

      var found_statements = [];

      var com_statements = {0:[],1:[],2:[],3:[],4:[]};

      var current_community;

      var entries_shown = [];

      var entries_ids = [];
      var entries_keywords = [];


      if (filter_origin == 'insight') {


          for (var i = 0; i < top_community_words.length; i++) {

            current_community = i;
            find_statement(top_community_words[i].nodes,1+i);
          }

      }
      else {

          find_statement(top_words,0);
      }

      function find_statement(key_terms, sweetch) {

          var nodesfound = 0;

          // Find the first entry that contains ALL the key_terms

          $(".entry").each(function(){

            if ((found_statements.length < 1 && sweetch == 0) || (sweetch > 0 && com_statements[sweetch].length < 1)) {

              var currentDiv = $(this).attr('data-uid');


              var originaltext = $(this).children('.entry-text').html();
              var statement_hashtags = $(this).attr('data-hashtags');
              var currentTimecode = $(this).attr('data-timestamp');

              for (var j = 0; j < key_terms.length; j++) {



                var search_lemma;
                  //TODO lemmas
                  // var search_lemma = window.jstemmer(pinnedNodes[j]);

                  if (sweetch == 0) {
                   search_lemma = key_terms[j].label;
                  }
                  else {
                    search_lemma = key_terms[j].name;
                  }

                    if (statement_hashtags.toLowerCase().indexOf(search_lemma.toLowerCase()) > -1) {
                        nodesfound = nodesfound + 1;
                    }

                    if (nodesfound == key_terms.length) {
                      if (sweetch == 0) {
                        found_statements.push({text: originaltext, id: currentDiv, time: currentTimecode, origin: key_terms});
                      }
                      else if (sweetch > 0) {
                        com_statements[sweetch].push({text: originaltext, id: currentDiv, time: currentTimecode, origin: key_terms});
                      }

                    }

                    // If not all the search words are present in an entry, nullify the counter
                    if ((j == key_terms.length - 1) && nodesfound != key_terms.length) {
                      nodesfound = 0;
                    }

              }
            }

          });



          // Ok, did we already find an entry where all the top_words exist?

          if ((sweetch == 0 && nodesfound == top_words.length)) {

                console.log('Found influential node statement:');
                console.log(found_statements);

                for (var s = 0; s < found_statements.length; s++) {
                    entries_shown.push(found_statements[s]);
                }

                nodesfound = 0;

                // Ok, now let's search through each community


                for (var i = 0; i < top_community_words.length; i++) {


                  current_community = i;
                  find_statement(top_community_words[i].nodes,1+i);

                  // TODO for when 3 words are not found

                  // if (nodesfound == top_community_words[i].nodes.length) {
                  //   console.log('found community statemenets');
                  //   console.log(a_statements);
                  // }
                  // else {
                  //   top_community_words[i].nodes = top_community_words[i].nodes.slice(0,-1);
                  //   find_statement(top_community_words[i].nodes,1+i);
                  // }
                }


          }
          else if (sweetch > 0 && nodesfound == key_terms.length) {

            // Did we reach the end of all the words?

            if (current_community == top_community_words.length -1) {


              function cleanup(obj) {
                  let newObj = [];
                  let idx = 0;
                  for (var propName in obj) {
                    let prop = obj[propName];

                    if (prop !== null
                     && prop !== undefined
                     && JSON.stringify(prop) != "[]" // not empty array
                     && JSON.stringify(prop) !== "{}") { // not empty obj
                      newObj[idx] = prop[0]; // we only need one object, NOTE can be an array if we decide to get more statemetns for each community
                      idx++;
                    }
                  }
                  return newObj;
              }

              com_statements = cleanup(com_statements);

              console.log('Main cluster topics:');
              console.log(com_statements);


              for (var s = 0; s < com_statements.length; s++) {
                entries_shown.push(com_statements[s]);
              }


              function compare(a,b) {
                if (a.time < b.time)
                  return -1;
                if (a.time > b.time)
                  return 1;
                return 0;
              }

              entries_shown.sort(compare);
              console.log(entries_shown);

              for (var s = 0; s < entries_shown.length; s++) {
                entries_ids.push(entries_shown[s].id);
                entries_keywords[entries_shown[s].id] = entries_shown[s].origin;
              }

              var most_inf_nodes_str = '';
              console.log('mostinfnodes')
              console.log(most_inf_nodes);
              for (var l = 0; l < most_inf_nodes.length; l++) {
                most_inf_nodes_str += most_inf_nodes[l].label;
                if (l < most_inf_nodes.length - 1) {
                  most_inf_nodes_str += ', ';
                }
              }


              $('.entry').hide();

              var explanation_html = 'The excerpts from the text containing the main topics and the most influential terms:';

              if (filter_origin == 'insight') {
                if (polysingularity_score == 'Dispersed') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. <br><br>To increase coherency, you can make connections between different separated clusters of key terms and statements. For example, the ones below:";
                }
                else if (polysingularity_score == 'Diversified') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. It has a balanced representation of several perspectives. <br><br>You can make it more focused if you develop the ideas around the main keywords — <strong>" + most_inf_nodes_str + "</strong> — or by identifying the structural gaps between the less represented clusters and making new connections between them (to focus) or going deeper into them (to diversify even more). Like the ones below:";
                }
                else if (polysingularity_score == 'Focused') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. While it has several perspectives, it is focused on one. <br><br>You can make it more diversified if you identify the structural gaps in the graph and make connections between them — that's where the new ideas may be. For example, these two sets of key terms and statements below:";
                }
                else if (polysingularity_score == 'Biased') {
                  explanation_html = "This discourse's structure is <strong>" + polysingularity_score + "</strong>. It's leaning towards and promotes a certain perspective, circulating around the most influential words — <strong>" + most_inf_nodes_str + "</strong>. <br><br>You could further develop and make connections between the different perspectives (indicated with colored topical clusters) into this discourse to make it more diversified. For example, the ones below:";
                }
                // There is a structural gap and a potential for a new idea between these two sets of key terms and statements below:
              }

              $('#explanation').show();
              $('#explanation').html(explanation_html);

              $(".entry").each(function(){

                  var currentDiv = $(this).attr('data-uid');
                  if (entries_ids.includes(currentDiv)) {

                    $(this).fadeIn(400);

                  // TODO clear up the entry text like in the above -
                  // 1. break into sentences; 2. find the first concentrate pf words; 3. keep it. 4. either create new ones or div the part non-relevant and make it opacity low or remove fully

                    var summary_helper = '';

                    for (var l = 0; l < entries_keywords[currentDiv].length; l++) {


                        if (summary_helper.length > 0) {
                          summary_helper += ', '
                        }
                        if (entries_keywords[currentDiv][l].label) {
                          summary_helper += '<a href="#" class="top_nodes">' + entries_keywords[currentDiv][l].label + '</a>';
                        }
                        else if (entries_keywords[currentDiv][l].name) {
                          summary_helper += '<a href="#" class="community_node" community="' + community_of_node[entries_keywords[currentDiv][l].name] + '">' + entries_keywords[currentDiv][l].name + '</a>';
                        }

                    }

                    if($(this).find('.summary').length == 0){


                      $(this).prepend( "<div class='summary'>key terms: " + summary_helper + "</div>" );

                      //console.log(entries_keywords[currentDiv]);
                    }

                  }

              });



              document.getElementById('entries').scrollTop = 0;
              top_nodes_activate();

              console.log('top info');
              console.log(top_community_words);


            //  $('#finds').trigger('click');


              // Make only those edges visible that belong to the statement selected

              if (pinnedNodes.length == 0) {


                  sigma.instances(0).graph.edges().forEach(function(e) {
                      var got_match = 0;
                      for (let item of e.statement_id) {
                        if (entries_ids.includes(item)) {
                            got_match += 1;
                        }
                      }
                      if (got_match > 0) {
                          e.color = e.originalColor;
                      }
                      else {
                          e.color = deselected_nodes_color;
                      }

                  });

                  // Make only those nodes visible that belong to the statement selected
                  sigma.instances(0).graph.nodes().forEach(function(n) {

                      // Is there no contexts at all? Show the node.
                      for (var g = 0; g < entries_ids.length; g++) {
                        if (!n.marked || n.marked == '0') {
                          if (nodesOfStatement[entries_ids[g]].indexOf(n.id) < 0)  {
                              n.color = deselected_nodes_color;
                              n.label = '';
                          }
                          else {
                              n.color = n.originalColor;
                              n.label = n.originalLabel;
                              n.marked = '1';
                          }
                        }
                      }
                  });
                  sigma.instances(0).refresh();

              }



            }

          }
          else {
            // All top nodes cannot be found anywhere, so we cut the list and search again
            if (sweetch == 0) {
              top_words = top_words.slice(0, -1);
              find_statement(top_words,0)
            }
            else if (sweetch > 0) {
                var reduced_query = key_terms.slice(0,-1);
                find_statement(reduced_query,sweetch);
              }
          }


      }


    }




    $("#summary").click(function(e) {
        e.preventDefault();

        // // Top influence nodes
      //   console.log(toppbc_nodes);
        //
        // // Top community nodes
        // console.log(topp_communities);

        filter_statements_summary(most_inf_nodes, most_inf_comm_nodes);

        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        // Top community terms

    });

    $("#insight").click(function(e) {
        e.preventDefault();

        var insight_nodes = [];

        if (polysingularity_score == 'Diversified') {
          if (most_inf_comm_nodes[0]) {
            insight_nodes.push(most_inf_comm_nodes[0]);
          }
          if (most_inf_comm_nodes[1]) {
            insight_nodes.push(most_inf_comm_nodes[1]);
          }
        }
        else {
          if (most_inf_comm_nodes[most_inf_comm_nodes.length-1]) {
            insight_nodes.push(most_inf_comm_nodes[most_inf_comm_nodes.length-1]);
          }
          if (most_inf_comm_nodes[most_inf_comm_nodes.length-2]) {
            insight_nodes.push(most_inf_comm_nodes[most_inf_comm_nodes.length-2]);
          }
        }


        filter_statements_summary(most_inf_nodes, insight_nodes, 'insight');

        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        // Top community terms

    });

    $("#overview").click(function(e) {
        e.preventDefault();
        $('.entry').fadeIn(400);
        $('#topnav_items').each(function() {
            $("li", this).each(function(i) {
                $(this).removeClass('pure-menu-selected-top');
            });
        });
        this.className = 'pure-menu-selected-top';
        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);

        if (pinnedNodes.length > 0) {
          filter_statements(pinnedNodes);
        }
        filter_graph(pinnedNodes);
        $('.summary').remove();
        $('#explanation').hide();
    });

    // Filter out the statements that don't have any of the nodes clicked

    var timesfiltered = 0;

    function filter_statements(pinnedNodes, origin) {

        var visibleentries = visibleentries_original;

        var nodeIDs_reversed = _.invert(nodeIDs);

        // Hide the sentences that don't contain the terms

        if (origin != 'stopwords') {

             if (pinnedNodes.length == 0) {

               $(".entry").fadeIn(500);

             }

             else {

               $(".entry").each(function(){

                  var currentDiv = $(this).attr('data-uid');

                  // Retrieve the statement text from the entry, clean from html
                  var originaltext = $(this).children('.entry-text').html();

                  var nodesfound = 0;

                  var matched1entry = 0;

                  // For each node present in this statement:
                  for (var item in nodesOfStatement[currentDiv]) {

                    var nmarker = nodesOfStatement[currentDiv][item]; //

                    // Is this node in pinnedNodes?
                    if (pinnedNodes.indexOf(nodeIDs_reversed[nmarker]) > -1) {
                      nodesfound = nodesfound + 1;
                      if (nodesfound == pinnedNodes.length) {
                          matched1entry = 1;
                      }

                    }
                  }

                // All the pinned nodes are not found in the entry
                if (matched1entry == 0) {

                    // Hide this entry
                    $(this).fadeOut(500);

                    // Set the counter
                    visibleentries = visibleentries - 1;

                    // We finished iterating through all the entries and nothing is shown
                    // Then launch a different logic

                    if (visibleentries == 0) {


                        // #1 Logic for intersections

                        var lastNode = pinnedNodes[pinnedNodes.length - 1];

                        var nnodes = sigma.instances(0).graph.neighbors(nodeIDs[lastNode]);

                        var selectedNNodes = [];

                        // We create an array from neighbors that looks like toKeep one

                        for (var key in nnodes) {
                            selectedNNodes.push(nnodes[key].label);
                        }

                        var overlapNodes = [];
                        overlapNodes = _.intersection(selectedNNodes, selectedNodes);

                        // TODO we always should have ONLY entries with one intersection and at least one of the pinned
                        // This breaks when we start navigating in the graph and have 3 pinned items — in this case no neighbors and it breaks

                        // Also some problems with deselection

                        $(".entry").each(function(){
                            var matchedentry = 0;
                            var currentDiv = $(this).attr('data-uid');

                            // For each node present in this statement:
                            for (var item in nodesOfStatement[currentDiv]) {
                              var nmarker = nodesOfStatement[currentDiv][item];

                              // Does this node belong to the Overlap nodes AND at the same time
                              if (overlapNodes.indexOf(nodeIDs_reversed[nmarker]) > -1) {
                                for (var node in nodesOfStatement[currentDiv]) {
                                  var n2marker = nodesOfStatement[currentDiv][node];
                                  if (pinnedNodes.indexOf(nodeIDs_reversed[n2marker]) > -1 || lastNode == nodeIDs_reversed[n2marker]) {
                                    matchedentry = 1;
                                  }
                                }
                              }
                            }
                            if (matchedentry == 1) {
                                $(this).fadeIn(500);
                                visibleentries = visibleentries + 1;
                            }
                        });


                        if (visibleentries == 0) {

                            $('.entry').fadeIn(500);
                            // #2 Logic
                            // This is if we want to remove the node before the last one.

                            // timesfiltered = timesfiltered + 1;
                            // var posnodes = pinnedNodes.length - timesfiltered - 1;

                            var posnodes = 0;

                            // Final nodes to search

                            splicedNodes = [];

                            // First all of them

                            for (var k = 0; k < pinnedNodes.length; k++) {
                                splicedNodes[k] = pinnedNodes[k];
                            }

                            // Remove the one we can't find (the very first one of the bunch)

                            splicedNodes.splice(posnodes, 1);

                            // Save that one also into the list of the nodes we removed

                            notfoundNodes.push(pinnedNodes[posnodes]);

                            // This is for alert
                            // var r = confirm('No link between ' + pinnedNodes + '.\nShow entries just with ' + splicedNodes + '?');

                            // This is for plain message
                            // $('#messages').html('No entries contain "' + pinnedNodes.join(' and ') + '".<br>Showing entries that contain "' + splicedNodes.join(' and ') + '" only:<br>&nbsp;');

                            // Get the pinnedNodes back to a good shape
                            pinnedNodes = [];
                            for (var l = 0; l < splicedNodes.length; l++) {
                                pinnedNodes[l] = splicedNodes[l];
                            }

                            // Relaunch the function with the newly cleared list of pinnedNodes

                            filter_statements(pinnedNodes, origin);
                      }

                    }
                // END OF not found any entries with the nodes clicked
                }

                // FOUND something with the nodes clicked
                else {

                    // Populate statement with a new text

                  //  $(this).children('.entry-text').html(newtext);

                    // $(this).find('.nonmatched-sentence').fadeOut(500); this is only if we want to fade non-matched sentences - see above also



                }


            });
          }



                        if (pinnedNodes.length > 0) {
                                if (background == 'dark') {
                                  $('#deletenodes').addClass('deletenodes-dark');
                                  $('#undo').addClass('undo-dark');
                                }
                                else {
                                  $('#deletenodes').addClass('deletenodes-on');
                                  $('#undo').addClass('undo-on');
                                }

                        }
                        else {
                          if (background == 'dark') {
                            $('#deletenodes').removeClass('deletenodes-dark');
                            $('#undo').removeClass('undo-dark');
                          }
                          else {
                            $('#deletenodes').removeClass('deletenodes-on');
                            $('#undo').removeClass('undo-on');
                          }

                        }

                        // Show tags that are currently used in search

                        var htmlNodes =  '<ul class="tags">';
                        var pinnedNodes_string = '';

                        if (pinnedNodes.length == 0) { notfoundNodes = [] }

                        for (var x = 0; x < notfoundNodes.length; x++) {
                            htmlNodes = htmlNodes + '<li><a class="notfound" href="#">' + notfoundNodes[x] + '</a></li>';
                            pinnedNodes_string = pinnedNodes_string + '#' + notfoundNodes[x] + ' ';
                        }

                        for (var q = 0; q < pinnedNodes.length; q++) {
                            htmlNodes = htmlNodes + '<li><a href="#">' + pinnedNodes[q] + '</a></li>';
                            pinnedNodes_string = pinnedNodes_string + '#' + pinnedNodes[q] + ' ';
                        }

                        if ($('#addnodeinput').val().length == 0 || $('#addnodeinput').val().charAt(0) == '#') {
                          $('#addnodeinput').val(pinnedNodes_string);
                        }

                        if ($('#statement').val().length == 0 || $('#statement').val().charAt(0) == '#') {
                          $('#statement').val(pinnedNodes_string);
                        }


                        htmlNodes = htmlNodes + '<div class="tagsend"></div></ul>';

                        //  notfoundNodes = [];

                        $('#pinnednodeslist').html(htmlNodes);


        // Highlight the nodes that were clicked

        $(".entry").removeHighlight();


        for (var i=0; i<pinnedNodes.length; i++) {
            if (pinnedNodes[i].match(/[а-яА-Я]/)) {
              $(".entry").highlight(window.jstemmer(pinnedNodes[i]));
            }
            else {
              $(".entry").highlight(pinnedNodes[i]);
            }

        }

        // Show only the clicked nodes and their neighbors in the graph
        if (origin != 'community' && origin != 'stopwords') {
          filter_graph(pinnedNodes, origin);
        }


        // END OF if origin != stopwords
      }

       // If we're coming from stopwords, adjust deletedNodes
        if (origin == 'stopwords') {
                deletedNodes = pinnedNodes;
                  if ($('#summary').hasClass('pure-menu-selected-top')) {
                      $('#summary').click();
                  }
                  if ($('#insight').hasClass('pure-menu-selected-top')) {
                      $('#insight').click();
                  }
        }

        // Then generate the interface
        var stopNodesList = '<ul class="tags">';
        for (var x = 0; x < deletedNodes.length; x++) {
            stopNodesList = stopNodesList + '<li><a class="deleted" href="#">' + deletedNodes[x] + '</a></li>';
        }
        stopNodesList = stopNodesList + '</ul>';


        // Save all this data in localStorage

        if (localStorage.getItem("selections")) {
            var localstore = JSON.parse(localStorage.getItem("selections"));
        }
        else {
            var localstore = {};
        }

        var localstore_cell = {};

        localstore_cell.stopnodes = deletedNodes;
        localstore_cell.pinnednodes = pinnedNodes;

        if (deletedNodes.length == 0 && pinnedNodes.length == 0) {
          delete localstore[window.location.href]
        }
        else {
          localstore[window.location.href] = localstore_cell;
        }

        localStorage.setItem("selections",JSON.stringify(localstore));

        if (deletedNodes.length > 0) {
          if (background == 'dark') {
            $('#stopsave').addClass('stopsave-dark');

          }
          else {
            $('#stopsave').addClass('stopsave-on');

          }
        }
        else {
          if (background == 'dark') {
            $('#stopsave').removeClass('stopsave-dark');

          }
          else {
            $('#stopsave').removeClass('stopsave-on');

          }

        }

        $('#stopnodeslist').html(stopNodesList);

        // Add triggers to newly shown Tags elements

        addTagTriggers();


        if (pinnedNodes.length == 0) {
            if (addcontext && interpret) {


              $('.entry').hide();

              for (var ite in statementsOfContext[current_context]) {

                $('.entry[data-uid="' + statementsOfContext[current_context][ite] + '"]').each(function() {
                  $(this).show();
                });

              }

          }
        }

        if ($('#summary').hasClass('pure-menu-selected-top')) {
          if (pinnedNodes.length == 0) {
            $('#summary').click();
          }
        }
        if ($('#insight').hasClass('pure-menu-selected-top')) {
          if (pinnedNodes.length == 0) {
            $('#insight').click();
          }
        }

    }

    function addContextTriggers() {

    // TODO Add case for clicking viewAll, so it doesn't reload the page, but simply removes all filters

    // Find @Contexts and make them filter statements when clicked

        var contextsToFilter = [];


        $(".app-context-link").click(function(e) {
            e.preventDefault();
            var that = this;
            setTimeout(function() {
                var dblclick = parseInt($(that).data('double'), 10);
                if (dblclick > 0) {
                    $(that).data('double', dblclick-1);
                } else {
                    if (e.shiftKey || ($(".addcontext-on").is(":visible"))) {
                      shiftClick.call(that, e);
                    }
                    else {
                      singleClick.call(that, e);
                    }
                }
            }, 300);
        }).dblclick(function(e) {
                    $(this).data('double', 2);
                    doubleClick.call(this, e);
                });


        // If double click on the menu, open it

        function singleClick (e) {

            window.location = e.target.href;

        }

        // If shift click on the menu, open comparison with other context

        function shiftClick (e) {

            window.location = e.target.href + '?addcontext=' + current_context;

        }

        // If double click on a link, open it

        $(".app-url-link").on('click tap', function(e) {

              e.stopPropagation();

        });



        // If only one click, filter it

        function doubleClick (e) {

                var triggeredFromStatement = null;

                var addFilter = null;

                var removeFilter = null;

                // Extract filter label
                var filter = $(e.target).text();

                // Remove the first @ in case it's @mentions clicked from the statements
                if (filter.charAt(0) == '@') {
                    filter = filter.substr(1);
                    triggeredFromStatement = 1;
                }

                // Some tricks to make context switch from statements emulate menu items behavior
                if (triggeredFromStatement) {

                    // If the context is clicked inside the statement, we're just dealing with that event, not others
                    e.stopPropagation();

                    $(".menu-item-divided").each(function() {
                         if (S($(this).html()).stripTags().s == filter) {
                             if ($(this).hasClass('pure-menu-selected')) {
                                 $(this).removeClass('pure-menu-selected');
                                 removeFilter = 1;
                             }
                             else {
                                 $(this).addClass('pure-menu-selected');
                                 addFilter = 1;
                             }
                         }

                    });
                }

                // Index of that filter in our current contextsToFilter array
                var filterIndex = contextsToFilter.indexOf(filter);

                // Toggle menu highlights
                if ($(this).hasClass('pure-menu-selected') || removeFilter) {


                    // The context is to be removed
                    if (!removeFilter) {
                        $(this).removeClass('pure-menu-selected');
                    }

                    // Does it exist in the list of contexts to filter?
                    if (filterIndex > -1) {
                        contextsToFilter.splice(filterIndex, 1);
                    }

                    //TODO WTF is that?
                  /*  // Let's remove the nodes that belong to the removed context from the contextNodes
                    contextNodeID[to_remove_clean].forEach(function(element){
                        var index = $.inArray(element, contextNodes);
                        if (index>=0) contextNodes.splice(index, 1);
                    });*/


                     // Create context query for jQuery
                    var contextstring = '';

                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if (contextsToFilter.length < 1 && !$('#listall').hasClass('pure-menu-selected') && !(current_context)) {
                        $('#listall').addClass('pure-menu-selected');
                    }

                }
                else {
                    if (!addFilter) {
                        $(this).addClass('pure-menu-selected');
                    }

                    // Add this context to a list of contextToFilter
                    if (filterIndex < 0) {
                        contextsToFilter.push(filter);
                    }

                    // Show only those that have the context

                    var contextstring = '';
                    if (contextsToFilter.length >= 0) {
                        contextstring += ".entry:contains('@"+contextsToFilter[0]+"')";

                        for (var l=1;l<contextsToFilter.length;++l) {
                            contextstring += ", .entry:contains('@"+contextsToFilter[l]+"')";
                        }

                        $('.entry').addClass('hidden');
                        $(contextstring).removeClass('hidden');

                    }
                    else {
                        $('.entry').removeClass('hidden');
                    }


                    if ($('#listall').hasClass('pure-menu-selected')) {
                        $('#listall').removeClass('pure-menu-selected');
                    }


                }

                console.log(contextsToFilter);

                // Add contexts into the submission form
                document.getElementById('selectedContexts').value = contextsToFilter.join(',');

                console.log(document.getElementById('selectedContexts').value);

                // Add some remove @context functionality
                renderGraph(contextsToFilter);

         }

    }





    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);


        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = deselected_nodes_color;
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }


    // Populate context menu

    function populateContextMenu (contextNames) {

        var switch_field = '';

        var context_filters = '';

        var currentContextURL = '';

        var appshome = '';

        var settingspane = '';
        <% if (perceivername) { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>">all contexts</a></li>';

        <% } else { %>

            currentContextURL = '<li id="listall" class="menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/edit">all contexts</a></li>';

        <% } %>

        var addNewContext = '';

        var auxLinks = '';

        var detectedContext = null;

        // The graph exists already?
        if (typeof contextNames[0] !== 'undefined' && contextNames[0] !== null) {
            contextNames.forEach(function(n) {
                if (n == current_context) {
                    detectedContext = 1;
                    // for the menu
                    <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= perceivername %>">all contexts</a></li>';
                    <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';
                        currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= user.name %>/edit">all contexts</a></li>';
                    <% } %>
                }
                else {
                    // for the menu
                    <% if (perceivername) { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= perceivername %>/' + n + '">' + n + '</a></li>';
                    <% } else { %>
                        context_filters += '<li class="app-context-link menu-item-divided "><a href="/<%= user.name %>/' + n + '/edit">' + n + '</a></li>';

                    <% } %>

                    // for the statement add
                }
            });
            // TODO this is code repeat from above, optimize
            if (!detectedContext && current_context) {
              <% if (perceivername) { %>
                  context_filters = '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= perceivername %>/' + current_context + '">' + current_context + '</a></li>' + context_filters;
                  currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= perceivername %>">all contexts</a></li>';
              <% } else { %>
                  context_filters = '<li class="app-context-link menu-item-divided pure-menu-selected"><a href="/<%= user.name %>/' + current_context + '/edit">' + current_context + '</a></li>' + context_filters;
                  currentContextURL = '<li id="listall" class="menu-item-divided"><a href="/<%= user.name %>/edit">all contexts</a></li>';
              <% } %>
            }
        }
        // No graph, so show private
        else {
            context_filters += '<li class="app-context-link menu-item-divided"><a href="/<%= perceivername %>/private/edit">private</a></li>';
        }

        <% if (!perceivername) { %>
            addNewContext = '<li id="addNewContext" class="menu-item-divided"><a id="addcontextbutton" href="javascript:"> + new context&nbsp;&nbsp;</a>&nbsp;<form action="/post" method="GET" class="pure-form" id="addcontextinput"><input type="text" id="addcontextname" size="7" class="pure-input"></form></li>';
        <% } else { %>
            addNewContext = '<li class="menu-item-divided">&nbsp;<a href="javascript:"></a></li>';

        <% } %>


        // We are viewing the user's public page?

        <% if ((perceivername)) { %>

            // So we know whose statements we see, but is it the same as the user who's viewing them?
            <% if (perceivername == receivername) { %>

            <% if (context) { %>
                // switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/<%= context %>/edit">go to private view</a></li>';
            <% } else { %>
                // switch_field = '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">go to private view</a></li>';
            <% } %>

            // So we know whose statements we're going to view, but the user is not the same as the one who made them.
            <% } else { %>



            <% } %>

        // We are viewing the user's private page

        <% } else {  %>

        <% if (context) { %>

                switch_field = '<li class="menu-item-small">&nbsp;</li><li class="menu-item-small"><a href="/<%= user.name %>/<% context %>">go to public view</a></li>';

            <% } else { %>

                switch_field = '<li class="menu-item-small">&nbsp;</li><li class="menu-item-small"><a href="/<%= user.name %>">go to public view</a></li>';

            <% } %>


        <% } %>


        <% if (perceivername) { %>

            <% if (perceivername == receivername) { %>
                settingspane = '<li class="menu-item-small" id="settingspane"><a href="/settings">settings</a></li><br>';
                appshome = '<li class="menu-item-small"><a href="/apps">apps/home</a></li>';
                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/<%= perceivername %>/edit">back to private view</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/logout">logout</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/import">import</a></li>' +
                        '<li class="menu-item-divided"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank" download="<%= perceivername %>_<%= context %>.gexf">gexf</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csv=1" target="_blank" download="<%= perceivername %>_<%= context %>.csv">csv</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csvdata=1" target="_blank">csv matrix</a>  <a href="/api/public/statements/<%= perceivername %>/<%= context %>?textonly=1" target="_blank">text only</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else if (receivername) { %>
                settingspane = '<li class="menu-item-small" id="settingspane"><a href="/settings">settings</a></li><br>';
                appshome = '<li class="menu-item-small"><a href="/apps">apps/home</a></li>';
                auxLinks = '<br>' +
                        '<li class="menu-item-small"><a href="/<%= receivername %>/edit">back to <%= receivername %></a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/">home page</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/import">import</a></li>' +
                        '<li class="menu-item-divided"><a href="/api/user/nodes/<%= context %>" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank" download="<%= context %>.gexf">gexf</a> <a href="/api/user/nodes/<%= context %>?csv=1" target="_blank">csv</a> <a href="/api/user/nodes/<%= context %>?csvdata=1" target="_blank">csv matrix</a>  <a href="/api/user/statements/<%= context %>?textonly=1" target="_blank">text only</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';


            <% } else { %>
              appshome = '<li class="menu-item-small"><a href="/">infranodus.com</a></li>';
                auxLinks = '<br>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/login">login</a></li>' +
                        '<li class="menu-item-divided"><a href="/signup">signup</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>" target="_blank">export</a></li>' +
                        '<li class="menu-item-small"><a href="/api/public/nodes/<%= perceivername %>/<%= context %>?gexf=1" target="_blank" download="<%= context %>.gexf">gexf</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csv=1" target="_blank">csv</a> <a href="/api/public/nodes/<%= perceivername %>/<%= context %>?csvdata=1" target="_blank">csv matrix</a>  <a href="/api/public/statements/<%= perceivername %>/<%= context %>?textonly=1" target="_blank">text only</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li> ' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-divided"><a href="/#tutorials" target="_blank">tutorials</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/infranodus/" target="_blank">about</a></li>' +
                        '<li class="menu-item-small"><a href="/#features">demo</a></li>' +
                        '<li class="menu-item-small"><a href="/#usecases">case studies</a></li>' +
                        '<li class="menu-item-small">&nbsp;</li>' +
                        '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                        '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

            <% } %>

        // THis below is a case when the user is logged in, so PERCEIVER does not exist (only RECEIVER) and we just use intternal APIs for exports

        <% } else { %>
            settingspane = '<li class="menu-item-small" id="settingspane"><a href="/settings">settings</a></li><br>';
            appshome = '<li class="menu-item-small"><a href="/">infranodus.com</a></li><li class="menu-item-small"><a href="/apps">apps/home</a></li>';
            auxLinks = '<br>' +
                    '<li class="menu-item-divided"><a href="/logout">logout</a></li>' +
                    '<li class="menu-item-small">&nbsp;</li>' +
                    '<li class="menu-item-divided"><a href="/import">import</a></li>' +
                    '<li class="menu-item-divided"><a href="/api/user/nodes/<%= context %>" target="_blank">export</a></li>' +
                    '<li class="menu-item-small"><a href="/api/user/nodes/<%= context %>?gexf=1" target="_blank" download="<%= context %>.gexf">gexf</a> <a href="/api/user/nodes/<%= context %>?csv=1" target="_blank">csv</a> <a href="/api/user/nodes/<%= context %>?csvdata=1" target="_blank">csv matrix</a>  <a href="/api/user/statements/<%= context %>?textonly=1" target="_blank">text only</a> <a href="" target="_blank" id="downloadpng">PNG image</a></li>' +
                    '<li class="menu-item-small">&nbsp;</li>' +
                    '<li class="menu-item-small"><a href="/#tutorials" target="_blank">video tutorials</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/courses/text-network-analysis-for-cognitive-stimulation/" target="_blank">online course</a></li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/category/tutorials/" target="_blank">case studies</a></li>' +
                    '<li class="menu-item-small">&nbsp;</li>' +
                    '<li class="menu-item-small"><a href="http://noduslabs.com/contact/" target="_blank">contact</a></li>' +
                    '<li class="menu-item-small"><a href="http://github.com/noduslabs/infranodus" target="_blank">help &amp; github</a></li>';

        <% } %>

        document.getElementById('contexts').innerHTML = appshome +
                                                        settingspane +
                                                        addNewContext +
                                                        currentContextURL +
                                                        context_filters +
                                                        switch_field +
                                                        auxLinks;



        // Select range in textarea function

        $.fn.selectRange = function(start, end) {
            return this.each(function() {
                if (this.setSelectionRange) {
                    this.focus();
                    this.setSelectionRange(start, end);
                } else if (this.createTextRange) {
                    var range = this.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            });
        };

        // When add new context is clicked, add it into textarea and select it

        $("#addNewContext").on('tap', function(e) {

            $("#addcontextinput").css("visibility", "visible");
            $("#add").css("visibility", "visible");
            $("#addcontextname").focus();


        });

        <% if (!perceivername) { %>
        $('#addcontextinput').submit(function(e) {
            e.preventDefault(); // to stop the form from submitting
            if ($('#addcontextname').val().length > 0) {
                var contextredirect = $('#addcontextname').val();
                contextredirect = contextredirect.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                contextredirect = contextredirect.replace(/[^\w]/gi, '');
                window.location.href = "/<%= user.name %>/" + contextredirect + '/edit';
            }

        });
        <% } %>

        // Now time to trigger the actions we want to have when user clicks on the contexts
        addContextTriggers();



        if (newcontextname) {
          // $('#menuLink').click();
          $("#addcontextinput").css("visibility", "visible");
          $("#addcontextname").focus();
          $("#addcontextname").val(newcontextname);
        }


    }

    function search_graph() {

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {

                var filter = ui.item.value;



            }

        });


        $("#searchform").submit(function(event) {

            event.preventDefault();

            // What are we searching?
            var searchPhrase = $('#search').val();

            if (searchPhrase.length > 1) {

                // Clean up the search string
                searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

                // Separate terms into array
                var searchArray = searchPhrase.toLowerCase().split(" ");

                var searchPhraseLemmas = [];


                for (var j = 0; j < searchArray.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = searchArray[j].match(/[а-яА-Я]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(searchArray[j]);

                    var search_lemma = searchArray[j];

                    searchPhraseLemmas.push(search_lemma);

                }

                for (var k = 0; k < searchPhraseLemmas.length; k++) {
                    if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                        pinnedNodes.push(searchPhraseLemmas[k]);
                    }
                }

                filter_statements(pinnedNodes, "search");

            }


        });
    }


    function filter_graph(pins, origin){


            var toKeep = [];

            var toKeepPinned = [];

            var toKeepMap = [];


            // Debug: show which nodes are clicked
            // console.log("Pinned nodes clicked:");
            // console.log(pins);


            // Are any nodes at all selected on the graph?

            if (pins.length > 0) {

                // Reiterate for each pinned node

                for (var i = 0; i < pins.length; i ++) {

                    // Now we reiterate through every node in the graph

                    sigma.instances(0).graph.nodes().filter(function(n) {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box

                        // SEARCHMOD
                       /* if (origin == 'search') {

                            var nodeLemma = window.jstemmer(n.originalLabel);


                            if (nodeLemma.length > 0) {
                                pinSearch = nodeLemma;
                            }
                            else {
                                pinSearch = n.originalLabel;
                            }
                        }

                        // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                        else {
                            pinSearch = n.originalLabel;
                        }*/

                        pinSearch = n.originalLabel;

                        // Is the current node of the graph one of the ones that was clicked before?

                        if (pins[i] == pinSearch) {


                            // The ID of the current node is...
                            var nodeId = n.id;

                            // Its neighbors are...
                            var nnodes = sigma.instances(0).graph.neighbors(nodeId);

                            var nnodesArray = [];

                            // We create an array from neighbors that looks like toKeep one

                            for (var key in nnodes) {
                                nnodesArray.push(nnodes[key]);
                            }


                            // If that's not the first iteration, we only keep intersection of both

                            if (i > 0) {
                                toKeep = _.intersection(toKeep, nnodesArray);
                            }
                            else {
                                toKeep = nnodesArray;
                            }

                            toKeepPinned.push(n);


                        }

                    });

                }

                // Make array of nodes to keep unique to avoid duplicates



                toKeep = _.uniq(toKeep);

                toKeep = _.union(toKeep,toKeepPinned);


                // console.log("Keeping the nodes:");
                // console.log(toKeep);

                console.log(toKeep.length + ' nodes selected out of ' + global_totalnodes + ' (' + (toKeep.length/global_totalnodes).toFixed(2)*100 + '%)')

                selectedNodes = [];
                for (var irr in toKeep) {
                  selectedNodes.push(toKeep[irr].label);
                }


                // Now convert this to an array that will be understood by the functions below

                for (key in toKeep) {
                    toKeepMap[toKeep[key].id] = toKeep[key];
                }


                // For each node in the graph

                sigma.instances(0).graph.nodes().forEach(function(n) {

                    if (toKeepMap[n.id])  {

                        var pinSearch = '';

                        // Lemmataze search query if we're coming from search box
                        // SEARCHMOD
                       /* if (origin == 'search') {
                            var nodeLemma = window.jstemmer(n.originalLabel);


                            if (nodeLemma.length > 0) {
                                pinSearch = nodeLemma;
                            }
                            else {
                                pinSearch = n.originalLabel;
                            }
                        }

                        // This means the user clicked on the tag or on the graph, so we use that exact parameter to search

                        else {
                            pinSearch = n.originalLabel;
                        }*/

                        pinSearch = n.originalLabel;


                        if (pins.indexOf(pinSearch) > -1) {
                                n.color = '#0089e0';

                                if (n.originalLabel == toKeepPinned[toKeepPinned.length-1].label) {
                                    console.log('The node "' + n.originalLabel + '" has ' + n.size + ' edges (degree), betweenness centrality: ' + n.bc + ', belongs to ' + n.community + ' community.');
                                }

                            }
                            else {
                                n.color = n.originalColor;

                            }
                            n.label = n.originalLabel;

                    }
                        else  {
                            n.color = deselected_nodes_color;
                            n.label = '';
                        }

                });

                sigma.instances(0).graph.edges().forEach(function(e) {
                        if (toKeepMap[e.source] && toKeepMap[e.target]) {
                            e.color = e.originalColor;
                        }
                        else {
                            e.color = deselected_nodes_color;
                        }
                });



            }

            // No nodes are selected (or all are deselected) - show the whole graph

            else {
                console.log('deselecting the graph');

                sigma.instances(0).graph.nodes().forEach(function(n) {


                   n.color = n.originalColor;
                   n.label = n.originalLabel;

                   n.marked = 0;



                });

                sigma.instances(0).graph.edges().forEach(function(e) {

                   e.color = e.originalColor;

                });

                // Remove all selections
                selectedNodes = [];


                // We show the whole graph above so scroll down to all the statements
                $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);


            }

            // Since the data has been modified, we need to
            // call the refresh method to make the colors
            // update effective.

            sigma.instances(0).refresh();

            <% if (locals.user) { %>
            <% if (locals.user.midi != undefined && locals.user.midi != 'off') { %>


            console.log('using MIDI data ' + midi);
            console.log('playing MIDI device:');
            console.log(output);

            var timecode = 0;

            var note_node = midi.substr(10,2);
            if (note_node.substr(1,1) == '0') {
              note_node = note_node.substr(0,1) + '1';
            }

            var note_edge = midi.substr(12,2);
            if (note_edge.substr(1,1) == '0') {
              note_edge = note_edge.substr(0,1) + '1';
            }



            for (var m = 0; m < pins.length; m++) {


                setTimeout(function () {
                  output.playNote(note_node, parseInt(midi.substr(0,2)));
                  output.stopNote(note_node, parseInt(midi.substr(0,2)), {time: "+500"});
                  console.log('playing a node note ' + note_node + ' at ' + timecode + ' on channel ' + parseInt(midi.substr(0,2)));
                }, timecode);
                timecode = getRandomInt(0,parseInt(midi.substr(6,4)));
            }

            var timecodea = 0;

            for (var ed = 0; ed < toKeep.length; ed++) {

                setTimeout(function () {
                  output.playNote(note_edge, parseInt(midi.substr(2,2)));
                  output.stopNote(note_edge, parseInt(midi.substr(2,2)), {time: "+500"});
                  console.log('playing an edge note ' + note_edge + ' at ' + timecodea + ' on ' + parseInt(midi.substr(2,2)));
                }, timecodea);
                  timecodea = getRandomInt(0,parseInt(midi.substr(6,4)));

            }

            <% } %>
            <% } %>


    }



    function addTagTriggers() {


        $(".tags").on('click', function(e) {

            e.preventDefault();

            var remove_node = e.target.innerText;

            // Is the clicked node in the pinnedNodes list
            var pinnedIndex = pinnedNodes.indexOf(remove_node);

            // Yes, it is, remove it and push it into the notfoundNodes list

            if (pinnedIndex > -1) {

                    pinnedNodes.splice(pinnedIndex,1);

                  //  notfoundNodes.push(remove_node);

            }


            // TODO this is very fuzzy logic here bad bad

            // Is there any nodes that were clicked before but not displayed on the graph?
            // Yes, more than 1
            if (splicedNodes.length > 1) {
                // Add them into the pinned
                pinnedNodes = [];
                for (var p = 0; p < splicedNodes.length; p++ ){
                    pinnedNodes[p] = splicedNodes[p];
                }
            }


            // Only one
            else if (splicedNodes.length == 1) {
                pinnedNodes = [];
                pinnedNodes[0] = splicedNodes[0];
                splicedNodes = [];
            }


            if (deletedNodes.indexOf(remove_node) > -1) {
                socket.emit('node add', {addingNodes: remove_node, stoplistNodes: deletedNodes});
            }
            else {

            // console.log("node clicked, now will filter for nodes " + pinnedNodes);

                  $('.entry').fadeIn(400);

                  filter_statements(pinnedNodes);


            }





        });

    }

   // Replace hashtags function

    function replaceHashtags(hash){
        var replacementString = $.trim(hash);
        return ' <a href="' + forwardTo + replacementString.substr(1) +'" class="app-concept-link" target="_blank">' + replacementString + '</a>';
    }


    var hashRegex = /(?:\s|^)(?:#(?!\d+(?:\s|$)))(\w+)(?=\s|$)/gi;

    if (link_hashtags) {
        $(".entry").each(function() {
            // Retrieve the statement text from the entry, clean from html
            var originale = $(this).children('.entry-text').html();
            // Replace with hashtags
            $(this).children('.entry-text').html(originale.replace(/#(\w+)/g,  " <a href='" + forwardTo + "$1' class='app-concept-link' target='_blank'>$&</a>"));

        });
    }


    



    setTimeout(function() {
      if (localStorage.getItem("selections")) {

          var saved_selections = JSON.parse(localStorage.getItem("selections"));

          if (saved_selections[window.location.href]) {
            deletedNodes = saved_selections[window.location.href].stopnodes;
            pinnedNodes = saved_selections[window.location.href].pinnednodes;
            if (deletedNodes.length > 0) {
              socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
            }
            else {
              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }
            }



          }
          else if (interpret) {
            console.log(saved_selections);
            for (var boom in saved_selections) {
              if (boom.indexOf('/'+addcontext+'/') > -1) {
                deletedNodes = saved_selections[boom].stopnodes;
                pinnedNodes = saved_selections[boom].pinnednodes;
                console.log(deletedNodes);
                console.log(pinnedNodes);
                if (deletedNodes.length > 0) {
                  socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                  if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                  }
                }
              }
            }
          }
          else if (selected_keywords && selected_keywords.length > 0) {
            pinnedNodes = selected_keywords.split("+");


              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }


          }

      }
      // TODO clear that
      else if (selected_keywords && selected_keywords.length > 0) {
        pinnedNodes = selected_keywords.split("+");


          if (pinnedNodes.length > 0) {
            filter_statements(pinnedNodes);
          }


      }



    }, 3000);

    // TODO above is ridiculously bad - fix this timing issue


    //downloadPNG();






})();
</script>




<% include statsbelow %>
</body>
</html>
