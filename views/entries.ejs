<!DOCTYPE html>
<html>
<%- include('components/entries/header') %>
<%- include('dependencies/entries') %>
<%- include('components/common/index') %>
<%- include('components/entries/index') %>
<body>
<% include statsabove %>
<div id="layout">
    <!-- Menu toggle -->
    <a href="#menu" id="menuLink" class="menu-link editorpane">
    <!-- Hamburger icon -->
    <span></span>
    </a>
     <div id="menu">
        <div class="pure-menu pure-menu-open">
        <% if (locals.user || perceivername) { %>
            <% if (perceivername) { %>
            <a class="pure-menu-heading" href="/<%= perceivername %>"><%= perceivername %></a>
            <% } else { %>
            <a class="pure-menu-heading" href="/apps"><%= user.name %></a>
            <% } %>
                <br>
                <ul id="contexts" class="contexts">

                </ul>
            &nbsp;<br><br>

        <% } else { %>
            <%- include('components/common/menu', {contextlist:contextlist}); %>

        <% } %>
        </div>
   </div>
     <div id='content'>

          <%- include('components/entries/StatementMenu'); %>
           
          <%- include('components/entries/StatementSidePanel/index',
                {entries, perceivername, addcontext, user, context, contextpublic, url, urltitle}); %>

          <%- include('components/entries/Graph/GraphCanvas'); %>

          <%- include('components/entries/Analytics/BiasSlider'); %>   

          <%- include('components/entries/VoiceInput/VoiceInputLiveText'); %>

          <%- include('components/entries/Analytics/AnalyticsPane'); %>

      </div>

    </div>

</div>

<%- include('components/entries/ContextMenu') %>
<%- include('components/entries/Graph/Graph') %>
<%- include('components/entries/Graph/GraphEdit') %>
<%- include('components/entries/Graph/GraphTags') %>
<%- include('components/entries/Graph/GraphMenu') %>
<%- include('components/entries/Graph/Walkthrough') %>
<%- include('components/entries/MidiController') %>
<%- include('components/entries/VoiceInput/VoiceInputController') %>

<script>
;(function(){


// MAIN SETTINGS START


var current_context_field = [];


// These are the nodes clicked in the graph

var global_totalnodes = 0;

// These are for Summary / Insight functionality

var most_inf_nodes = [];

var most_inf_comm_nodes = {};

var polysingularity_score = 0;

// Whats the clicked nodes in the graph
var clickedNodes = [];

// What are the shown nodes on the graph;
var shownNodes = [];

// Inactivity timeout
var inactiveTimeout = null;

// This variable shows if there was a meaningful interaction with the graph yet
var graphInteraction = null;

// Loaded with graph only?
var graphOnly = null;












// This is for the option to emit and receive MIDI signals for the graph

var midi = '';

// TODO for desktop browses that support webwork (not iphone): webworker: true, slowdown: 300










var adding_entry = false;

// This is a very stupid way to change the interface color to dark if the setting is on (through URL or user settings)

if (background == 'dark') {
  $('#graph-container').addClass('graph-dark');
  $('#analyticsbutton').addClass('analyticsbutton-dark');
  $('.entry').addClass('entry-dark');
  $('.entry-text').addClass('entry-text-dark');
  $('#analytics').addClass('analytics-dark');
  $('#entryform').addClass('entryform-dark');
  $('#addnodeinput').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('#statement').css({'backgroundColor': 'rgba(250, 250, 250, 0.2)', 'border': 'none', 'box-shadow': 'none', 'color': '#aaaab5'});
  $('body').css('color', '#aaaab5');
  // $('li.pure-menu-selected-top a').css('backgroundColor', '#888888');
  $('.menu-link').css('background', 'rgba(250, 250, 250, 0.4)');
  $('#graph-link').addClass('graph-link-dark');
  $('#chat-link').addClass('chat-dark');
  $('#addnode').addClass('addnode-dark');
  $('#go_next').addClass('go_next-dark');
  $('#reloadbutton').addClass('reloadbutton-dark');
  $('#improve-layout').addClass('improve-layout-dark');
  $('#abstract-layout').addClass('abstract-layout-dark');
  $('#walkthrough').addClass('walkthrough-dark');
  $('#zoom-in').addClass('zoom-in-dark');
  $('#zoom-out').addClass('zoom-out-dark');
  $('#microphone-link').css({'background-image': "url('/images/microphone-white.png')", "opacity": "0.6"});
  $('#addcontext-link').css({'background-image': "url('/images/compare-white.png')", "opacity": "0.6"});
  $('#deletecontextbutton').addClass('deletecontextbutton-dark');
  $('#collaborate-link').addClass('collaborate-link-dark');
  $('#import-link').addClass('import-link-dark');
  $('#windowdown-link').addClass('windowdown-link-dark');
  $('#statements-link').addClass('statements-link-dark');
  $('#timer-link').addClass('timer-link-dark');
  $('#watch-link').addClass('watch-link-dark');
  if (graphPalette == 'contrast') {
      deselected_nodes_color = '#555';
  }
  else {
      deselected_nodes_color = '#444';
  }
}








    // When scroll happens if the dynamic graph is on, show which uids are visible

    var scroll_signal;

    $("#entries").scroll(function() { //.box is the class of the div

          if (dynamic_graph == 1) {

            var ventries = [];


              $('#entries').children(".entry").each(function(){
                  var vresult;
                  vresult = checkInView(this,true);
                  if (vresult == true) {
                      if (ventries.indexOf($(this).attr('data-uid')) == -1) {
                          ventries.push($(this).attr('data-uid'));
                      }
                  }

                //  result2 += " " +  checkInView($(e),true);
               });

              entryScroll(ventries);



              if (!$(this).is(':animated')) {

                var current_scroll = ($(this).scrollTop());
                var max_scroll = $(this)[0].scrollHeight - $(this).height();

                if (current_scroll == max_scroll && scroll_signal != 'bottom') {
                  $(this).scrollTop(0);
                  scroll_signal = 'top';
                }
                else if (current_scroll == 0 && scroll_signal != 'top') {
                  $(this).scrollTop($(this)[0].scrollHeight);
                  scroll_signal = 'bottom';
                }

              }


          }

    });


    // Dynamically watch the graph unfold

    $("#watch-link").click(function(e) {

      if (dynamic_watch == 0) {
          var speed_scroll = 1000;
          dynamic_watch = 1;

          $('#watch-link').addClass('watch-link-on');

          if (dynamic_graph == 0) {
            $("#timer-link").trigger('click');
          }

          var max_scroll = $('#entries')[0].scrollHeight - $('#entries').height();

          function autoScrollUp(){
            var current_scroll = ($('#entries').scrollTop());
            var scroll_to = max_scroll;
            var num_entries =  $('.entry').length;

            if (current_scroll == max_scroll) {
              $('#entries').scrollTop(0);
              current_scroll = $('#entries').scrollTop();
            }
            var play_time = Math.round(((max_scroll - current_scroll)/max_scroll) * num_entries * speed_scroll);

            $("#entries").animate({scrollTop: scroll_to},play_time,"linear", autoScrollUp); // and animate
          }
          autoScrollUp();

      }
      else  {
        dynamic_watch = 0;
        $('#watch-link').removeClass('watch-link-on');
        $("#entries").stop();

      }
    });

    // TODO move this general function out — this is just to check which elements inside (#entries) are visible for the dynamic graph feature above

    function checkInView(elem,partial)
      {
          var container = $("#entries");
          var contHeight = container.height();
          var contTop = container.scrollTop();
          var contBottom = contTop + contHeight ;

          var elemTop = $(elem).offset().top - container.offset().top;
          var elemBottom = elemTop + $(elem).height();

          var isTotal = (elemTop >= 0 && elemBottom <=contHeight);
          var isPart = ((elemTop < 0 && elemBottom > 0 ) || (elemTop > 0 && elemTop <= container.height())) && partial ;

          return  isTotal  || isPart ;
      }



    // When the document loaded, add some hooks to the submit form

    document.addEventListener("DOMContentLoaded", function(event) {


        submitFormProcess();


    });



// Auto-resize to fill content;

    // This launches only when all other stuff from above have loaded
    $(document).ready(function(){

     
         // Add hooks on all tooltips
        $('.tooltip').tooltipster({
            theme: 'tooltipster-noir',
            position: 'left',
            maxWidth: 200,
            delay: 1000
        });

        // Some more settings from the URL or user settings passed from routes/entries.js and defined above in global parameters


        function toTitleCase(str)
        {
            return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
        }

        

        var uproll = $('#entryform').height();

        if (hide_edit) {
          uproll = 50;
        }

        $('#entries').css({height:  $(window).height() - uproll - 100});

        $(window).resize(function() {
              $('#entries').css({height:  $(window).height() - uproll - 100});
              $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);
        });


        $("#entries").animate({ scrollTop: $('#entries')[0].scrollHeight }, 1000);


        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {
                var filter = ui.item.value;
            }
        });

        // Function to search the graph for the nodes selected

        search_graph();

        // Make texarea automatically resizeable
        $('textarea').autosize();

        visibleentries_original = $(".entry:visible").length;

        // Statement edit / delete functionality

        var filteringstarted = 0;

        // Add the hooks to the newly rendered entries again
        entryClick();

        // If it's NOT some other user watching the graph, then statements can be edited. Otherwise - no.
        <% if (!perceivername) { %>
        entryDoubleClick();
        <% } %>


        // Highlight statement if clicked once

        // Deal with each date

        $(".entry-date").each(function() {
            var convertedTime = timeConverter($(this).text()) ;
            $(this).text(convertedTime);
        });

        // TODO move the fucntion out
        function timeConverter(UNIX_timestamp){
            var modTimestamp = UNIX_timestamp.substr(0, UNIX_timestamp.length - 4);
            var time = moment(modTimestamp, 'x').fromNow();
            return time;
        }


        // Some more graph interface settings

     

        // Did we receive a global setting to hide the editor pane?

        if (hide_edit) {
          $('.editorpane').each(function() {
            $(this).hide();
          });
        }


   

        if (localStorage.getItem('graph') == 1 && !graphOnly && !hide_always && !hide_when_small) {
            var isHidden__ = $("#statements").is(":hidden");
            if (!isHidden__) {
                $('#statements').fadeOut();
                $("#chat-link").toggleClass('chat-highlight','add');
            }
        }

        if (localStorage.getItem('timer') == 1) {
          ($("#timer-link").trigger('click'));
        }


        // Document Ready end

        });


    
    // Remove context filters function - launched only when a context is clicked

    function renderGraph(contextsToFilter) {

        // Creating the context index
        var nodesToKeep = [];

        var keepNodes = [];

        var keepEdges = [];

        // First, let's reiterate the graph and make a list of nodes and edges to keep

        if (contextsToFilter.length > 0) {

            sigma.instances(0).graph.edges().forEach(function(e) {

                // Reiterating through edges, leaving only the nodes that appear in at least one filtered context

                contextsToFilter.forEach(function(element){

                    if (contextNodeID[element].indexOf(e.source) > -1) {
                        keepNodes.push(e.source);
                    }

                    if (contextNodeID[element].indexOf(e.target) > -1) {
                        keepNodes.push(e.target);
                    }

                });

                // Keep edges that are in at least one of the filtered contexts

                if (contextsToFilter.indexOf(e.edge_context) > -1) {
                    keepEdges.push(e.id);
                }


            });
        }

        // Uniqualize to avoid duplicates

        keepNodes = $.unique(keepNodes);
        keepEdges = $.unique(keepEdges);


        // Then let's reiterate the graph edges and only show nodes that belong to the contexts created

        sigma.instances(0).graph.edges().forEach(function(e) {

            if (contextsToFilter.length == 0) {
                // Show the edge if there's no contexts at all
                e.color = e.originalColor;
            }

            else if (keepEdges.indexOf(e.id) > -1) {
                // The edge is in the list to keep => show it normal color
                e.color = e.originalColor;

                // The source of the edge is in the list to keep, so we will keep it.
                if (keepNodes.indexOf(e.source) > -1) {
                    nodesToKeep.push(e.source);
                }
                // The target of the edge is in the list to keep, so we will keep it also.
                if (keepNodes.indexOf(e.target) > -1) {
                    nodesToKeep.push(e.target);
                }
                // PS We only do this check for the nodes that belong to the edges that we keep
            }
            else {
                // Otherwise (the edge IS in the list for removal), so we color the edge invisible
                e.color = deselected_nodes_color;
            }



        });



        // Ensure no duplicates
        nodesToKeep = $.unique(nodesToKeep);

        // Now that we know which nodes to keep, let's reiterate through them all

        sigma.instances(0).graph.nodes().forEach(function(n) {

            // Is there no contexts at all? Show the node.
            if (contextsToFilter.length == 0) {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }

            // The node is not in the list to keep? Hide it!
            else if (nodesToKeep.indexOf(n.id) < 0)  {
                n.color = deselected_nodes_color;
                n.label = '';
            }

            // Looks like there is a filtering context function AND the node is in the keep list, so make it show!
            else {
                n.color = n.originalColor;
                n.label = n.originalLabel;
            }
        });


        // Refresh the graph (we do it through instances(0) as we're a bit outside of Sigma now)
        sigma.instances(0).refresh();


    }




    function search_graph() {

        // Autocomplete for search input
        $("#search").autocomplete({
            source: nodeNames,
            minLength: 1,
            delay: 500,
            messages: {
                noResults: '',
                results: function() {}
            },
            select: function(event, ui) {

                var filter = ui.item.value;



            }

        });


        $("#searchform").submit(function(event) {

            event.preventDefault();

            // What are we searching?
            var searchPhrase = $('#search').val();

            if (searchPhrase.length > 1) {

                // Clean up the search string
                searchPhrase = searchPhrase.replace(/\s+/g,' ').trim();

                // Separate terms into array
                var searchArray = searchPhrase.toLowerCase().split(" ");

                var searchPhraseLemmas = [];


                for (var j = 0; j < searchArray.length; j++) {

                    // Is the search term cyrillic?
                    var search_cyrillic = searchArray[j].match(/[а-яА-Я]/);

                    // SEARCHMOD
                    // var search_lemma = window.jstemmer(searchArray[j]);

                    var search_lemma = searchArray[j];

                    searchPhraseLemmas.push(search_lemma);

                }

                for (var k = 0; k < searchPhraseLemmas.length; k++) {
                    if (pinnedNodes.indexOf(searchPhraseLemmas[k]) < 0) {
                        pinnedNodes.push(searchPhraseLemmas[k]);
                    }
                }

                filter_statements(pinnedNodes, "search");

            }


        });
    }

    // TODO to move to a separate file that will load after all
    // This function checks if the user had any nodes selected and selects them for him, but only after the graph is loaded

    var selected_keywords = getUrlVars()["keywords"];

    setTimeout(function() {
      if (localStorage.getItem("selections")) {

          var saved_selections = JSON.parse(localStorage.getItem("selections"));

          if (saved_selections[window.location.href]) {
            deletedNodes = saved_selections[window.location.href].stopnodes;
            pinnedNodes = saved_selections[window.location.href].pinnednodes;
            if (deletedNodes.length > 0) {
              socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
            }
            else {
              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }
            }



          }
          else if (interpret) {
            console.log(saved_selections);
            for (var boom in saved_selections) {
              if (boom.indexOf('/'+addcontext+'/') > -1) {
                deletedNodes = saved_selections[boom].stopnodes;
                pinnedNodes = saved_selections[boom].pinnednodes;
                console.log(deletedNodes);
                console.log(pinnedNodes);
                if (deletedNodes.length > 0) {
                  socket.emit('node delete', {pinnedNodes: deletedNodes, delete_from: "localstorage"});
                }
                else {
                  if (pinnedNodes.length > 0) {
                    filter_statements(pinnedNodes);
                  }
                }
              }
            }
          }
          else if (selected_keywords && selected_keywords.length > 0) {
            pinnedNodes = selected_keywords.split("+");


              if (pinnedNodes.length > 0) {
                filter_statements(pinnedNodes);
              }


          }

      }
      // TODO clear that
      else if (selected_keywords && selected_keywords.length > 0) {
        pinnedNodes = selected_keywords.split("+");


          if (pinnedNodes.length > 0) {
            filter_statements(pinnedNodes);
          }


      }



    }, 3000);

    // TODO above is ridiculously bad - fix this timing issue


    //downloadPNG();



})();
</script>




<% include statsbelow %>
</body>
</html>
